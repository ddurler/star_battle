<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","cell_value.rs"],"content":"//! Énumération des valeurs possibles d'une case de la grille\r\n\r\n/// Valeur possible d'une case de la grille\r\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\r\npub enum CellValue {\r\n    /// Case dont le contenu est inconnu\r\n    #[default]\r\n    Unknown,\r\n\r\n    /// Case dont le contenu est une étoile\r\n    Star,\r\n\r\n    /// Case dont le contenu n'est pas une étoile\r\n    NoStar,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid.rs"],"content":"//! Contenu des case de la grille.\n\nuse std::fmt::Display;\n\nuse crate::CellValue;\nuse crate::GridCell;\nuse crate::GridHandler;\nuse crate::LineColumn;\n\n/// Cases de la grille\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Grid {\n    /// Dimensions de la grille\n    size: LineColumn,\n\n    /// Cases de la grille\n    cells: Vec\u003cVec\u003cGridCell\u003e\u003e,\n}\n\nimpl Display for Grid {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        for line in 0..self.nb_lines() {\n            for column in 0..self.nb_columns() {\n                match self.cell(LineColumn::new(line, column)).value {\n                    CellValue::Star =\u003e write!(f, \" *\")?,\n                    CellValue::NoStar =\u003e write!(f, \" -\")?,\n                    CellValue::Unknown =\u003e write!(f, \" ?\")?,\n                }\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}\n\nimpl From\u003c\u0026GridHandler\u003e for Grid {\n    fn from(value: \u0026GridHandler) -\u003e Self {\n        let nb_lines = value.nb_lines();\n        let nb_columns = value.nb_columns();\n        let mut cells = Vec::with_capacity(nb_lines);\n        for line in 0..nb_lines {\n            let mut cells_line = Vec::with_capacity(nb_columns);\n            for column in 0..nb_columns {\n                let line_column = LineColumn::new(line, column);\n                let grid_cell = GridCell {\n                    line_column,\n                    region: value.cell_region(line_column),\n                    value: CellValue::Unknown,\n                };\n                cells_line.push(grid_cell);\n            }\n            cells.push(cells_line);\n        }\n        Self {\n            size: LineColumn::new(nb_lines, nb_columns),\n            cells,\n        }\n    }\n}\n\nimpl Grid {\n    /// Nombre de lignes de la grille\n    #[must_use]\n    pub const fn nb_lines(\u0026self) -\u003e usize {\n        self.size.line\n    }\n\n    /// Nombre de colonnes de la grille\n    #[must_use]\n    pub const fn nb_columns(\u0026self) -\u003e usize {\n        self.size.column\n    }\n\n    /// Retourne la case (non mutable) de la grille en (line, column)\n    #[must_use]\n    pub fn cell(\u0026self, line_column: LineColumn) -\u003e \u0026GridCell {\n        \u0026self.cells[line_column.line][line_column.column]\n    }\n\n    /// Retourne la case (mutable) de la grille en (line, column)\n    #[must_use]\n    pub fn cell_mut(\u0026mut self, line_column: LineColumn) -\u003e \u0026mut GridCell {\n        \u0026mut self.cells[line_column.line][line_column.column]\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::GridParser;\n\n    #[test]\n    fn test_from_grid_handler() {\n        let parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n        let grid = Grid::from(\u0026handler);\n\n        assert_eq!(grid.nb_lines(), 5);\n        assert_eq!(grid.nb_columns(), 5);\n\n        for line in 0..grid.nb_lines() {\n            for column in 0..grid.nb_columns() {\n                let line_column = LineColumn::new(line, column);\n                assert_eq!(grid.cell(line_column).value, CellValue::Unknown);\n            }\n        }\n    }\n\n    #[test]\n    fn test_clone_cell_mut() {\n        let parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n        let grid = Grid::from(\u0026handler);\n\n        let mut grid_cloned = grid.clone();\n        let line_column = LineColumn::new(0, 0);\n        grid_cloned.cell_mut(line_column).value = CellValue::Star;\n        assert_eq!(grid.cell(line_column).value, CellValue::Unknown);\n        assert_eq!(grid_cloned.cell(line_column).value, CellValue::Star);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":23,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":24,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":30,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":37,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":38,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":39,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":40,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":41,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":42,"address":[],"length":0,"stats":{"Line":12610078956637388800}},{"line":43,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":44,"address":[],"length":0,"stats":{"Line":16501189034685497344}},{"line":47,"address":[],"length":0,"stats":{"Line":16501189034685497344}},{"line":50,"address":[],"length":0,"stats":{"Line":16501189034685497344}},{"line":52,"address":[],"length":0,"stats":{"Line":12610078956637388812}},{"line":55,"address":[],"length":0,"stats":{"Line":4395513236313604097}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783809}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783809}},{"line":70,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":71,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":76,"address":[],"length":0,"stats":{"Line":16212958658533785600}},{"line":77,"address":[],"length":0,"stats":{"Line":16212958658533785600}},{"line":82,"address":[],"length":0,"stats":{"Line":7421932185907138691}},{"line":83,"address":[],"length":0,"stats":{"Line":7421932185907138691}}],"covered":27,"coverable":29},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_action.rs"],"content":"//! Action possible sur une grille.\n\nuse std::fmt::Display;\n\nuse crate::CellValue;\nuse crate::Grid;\nuse crate::LineColumn;\n\n/// Énumération des actions possibles sur le contenu d'une grille\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\npub enum GridAction {\n    /// L'action d'indiquer le contenu indéfini d'une case\n    SetUnknown(LineColumn),\n\n    /// L'action d'ajouter une étoile à une case\n    SetStar(LineColumn),\n\n    /// L'action de supprimer la possibilité d'une étoile à une case\n    SetNoStar(LineColumn),\n}\n\nimpl Display for GridAction {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::SetUnknown(line_column) =\u003e write!(f, \"{line_column}-\u003e Inconnu\"),\n            Self::SetStar(line_column) =\u003e write!(f, \"{line_column}-\u003eEtoile\"),\n            Self::SetNoStar(line_column) =\u003e write!(f, \"{line_column}-\u003ePas d'étoile\"),\n        }\n    }\n}\n\n/// Affichage d'une liste d'actions\npub fn display_vec_actions(actions: \u0026Vec\u003cGridAction\u003e) -\u003e String {\n    let mut str_actions = String::new();\n    for action in actions {\n        if !str_actions.is_empty() {\n            str_actions.push_str(\", \");\n        }\n        str_actions.push_str(\u0026action.to_string());\n    }\n    str_actions\n}\n\nimpl GridAction {\n    /// Retourne la `LineColumn` correspondant à l'action\n    #[must_use]\n    pub const fn line_column(\u0026self) -\u003e LineColumn {\n        match self {\n            Self::SetUnknown(line_column)\n            | Self::SetStar(line_column)\n            | Self::SetNoStar(line_column) =\u003e *line_column,\n        }\n    }\n\n    /// Retourne la `CellValue` correspondant à l'action\n    #[must_use]\n    pub const fn value(\u0026self) -\u003e CellValue {\n        match self {\n            Self::SetUnknown(_) =\u003e CellValue::Unknown,\n            Self::SetStar(_) =\u003e CellValue::Star,\n            Self::SetNoStar(_) =\u003e CellValue::NoStar,\n        }\n    }\n\n    /// Applique une action à la grille\n    pub fn apply_action(\u0026self, grid: \u0026mut Grid) {\n        match self {\n            Self::SetUnknown(line_column) =\u003e {\n                grid.cell_mut(*line_column).value = CellValue::Unknown;\n            }\n            Self::SetStar(line_column) =\u003e {\n                grid.cell_mut(*line_column).value = CellValue::Star;\n            }\n            Self::SetNoStar(line_column) =\u003e {\n                grid.cell_mut(*line_column).value = CellValue::NoStar;\n            }\n        }\n    }\n}\n\nimpl Grid {\n    /// Applique une action à la grille\n    pub fn apply_action(\u0026mut self, action: \u0026GridAction) {\n        match action {\n            GridAction::SetUnknown(line_column) =\u003e {\n                self.cell_mut(*line_column).value = CellValue::Unknown;\n            }\n            GridAction::SetStar(line_column) =\u003e {\n                self.cell_mut(*line_column).value = CellValue::Star;\n            }\n            GridAction::SetNoStar(line_column) =\u003e {\n                self.cell_mut(*line_column).value = CellValue::NoStar;\n            }\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":24,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":27,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":33,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":34,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":35,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":36,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":37,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":39,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":41,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":8574853690513426954}},{"line":84,"address":[],"length":0,"stats":{"Line":8574853690513426954}},{"line":85,"address":[],"length":0,"stats":{"Line":2558}},{"line":86,"address":[],"length":0,"stats":{"Line":2558}},{"line":88,"address":[],"length":0,"stats":{"Line":7205759403792793610}},{"line":89,"address":[],"length":0,"stats":{"Line":7205759403792793610}},{"line":91,"address":[],"length":0,"stats":{"Line":1369094286720630786}},{"line":92,"address":[],"length":0,"stats":{"Line":1369094286720630786}}],"covered":19,"coverable":38},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_bad_ruler.rs"],"content":"//! Vérification de la validité d'une grille.\r\n//!\r\n//! Ce module déroule les règles de cohérence pour les cases d'un grille et signale les\r\n//! éventuels problèmes détectés dans la construction d'une solution pour la grille.\r\n\r\nuse crate::CellValue;\r\nuse crate::Grid;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\nuse crate::LineColumn;\r\n\r\n/// Erreur de cohérence de la grille\r\n#[derive(thiserror::Error, Debug, PartialEq, Eq)]\r\npub enum BadRuleError {\r\n    /// Etoile adjacente à une autre étoile\r\n    #[error(\"Etoile {0} adjacente à l'étoile {1}\")]\r\n    StarAdjacent(LineColumn, LineColumn),\r\n\r\n    /// Trop d'étoiles dans une 'zone'\r\n    #[error(\"Trop d'étoiles dans '{0}'\")]\r\n    TooManyStarsInZone(GridSurfer),\r\n\r\n    /// Impossible de placer toutes les étoiles dans une 'zone'\r\n    #[error(\"Impossible de placer toutes les étoiles dans '{0}'\")]\r\n    NotEnoughStarsInZone(GridSurfer),\r\n}\r\n\r\n/// Vérification de la validité d'une grille\r\n///\r\n/// ### Errors\r\n/// Retourne un [`BadRuleError`] si la grille n'est pas valide\r\npub fn check_bad_rules(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Result\u003c(), BadRuleError\u003e {\r\n    check_no_star_adjacent(handler, grid)?;\r\n    for region in handler.regions() {\r\n        check_zone(handler, grid, \u0026GridSurfer::Region(region))?;\r\n    }\r\n    for line in 0..handler.nb_lines() {\r\n        check_zone(handler, grid, \u0026GridSurfer::Line(line))?;\r\n    }\r\n    for column in 0..handler.nb_columns() {\r\n        check_zone(handler, grid, \u0026GridSurfer::Column(column))?;\r\n    }\r\n    Ok(())\r\n}\r\n\r\n/// Parcours les cases de la grille pour vérifier qu'aucune étoile n'est adjacent à une autre étoile\r\nfn check_no_star_adjacent(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Result\u003c(), BadRuleError\u003e {\r\n    for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\r\n        let cell = grid.cell(line_column);\r\n        if cell.value == CellValue::Star {\r\n            for adjacent_line_column in handler.adjacent_cells(line_column) {\r\n                let adjacent_cell = grid.cell(adjacent_line_column);\r\n                if adjacent_cell.value == CellValue::Star {\r\n                    return Err(BadRuleError::StarAdjacent(\r\n                        line_column,\r\n                        adjacent_line_column,\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\n/// Vérifie la validité du nombre d'étoile sur une zone (line, colonne ou région).\u003cbr\u003e\r\nfn check_zone(handler: \u0026GridHandler, grid: \u0026Grid, surfer: \u0026GridSurfer) -\u003e Result\u003c(), BadRuleError\u003e {\r\n    let mut nb_stars = 0;\r\n    let mut nb_possible_stars = 0;\r\n\r\n    for line_column in handler.surfer(grid, surfer) {\r\n        match grid.cell(line_column).value {\r\n            CellValue::Star =\u003e nb_stars += 1,\r\n            CellValue::Unknown =\u003e nb_possible_stars += 1,\r\n            CellValue::NoStar =\u003e (),\r\n        }\r\n    }\r\n\r\n    if nb_stars \u003e handler.nb_stars() {\r\n        return Err(BadRuleError::TooManyStarsInZone(surfer.clone()));\r\n    } else if nb_stars + nb_possible_stars \u003c handler.nb_stars() {\r\n        return Err(BadRuleError::NotEnoughStarsInZone(surfer.clone()));\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_no_star_adjacent() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // On place volontairement 2 étoiles dans 2 cases adjacentes de la grille\r\n        grid.cell_mut(LineColumn::new(0, 0)).value = CellValue::Star;\r\n        grid.cell_mut(LineColumn::new(1, 1)).value = CellValue::Star;\r\n\r\n        match check_bad_rules(\u0026grid_handler, \u0026grid) {\r\n            Err(BadRuleError::StarAdjacent(_, _)) =\u003e (),\r\n            _ =\u003e panic!(\"Échec détection de 2 étoiles adjacentes dans la grille\"),\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_too_many_stars_in_region() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement 2 étoiles non adjacentes dans la zone 'B' de la grille\r\n        grid.cell_mut(LineColumn::new(0, 1)).value = CellValue::Star;\r\n        grid.cell_mut(LineColumn::new(0, 4)).value = CellValue::Star;\r\n\r\n        if let Err(BadRuleError::TooManyStarsInZone(GridSurfer::Region(region))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(\r\n                region, 'B',\r\n                \"Échec détection trop d'étoiles dans la région 'B' (region '{region}' identifiée)\"\r\n            );\r\n        } else {\r\n            panic!(\"Échec détection trop d'étoiles dans une région\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_not_enough_stars_in_region() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement pas d'étoile dans les 2 case la zone 'A' de la grille\r\n        grid.cell_mut(LineColumn::new(0, 0)).value = CellValue::NoStar;\r\n        grid.cell_mut(LineColumn::new(1, 0)).value = CellValue::NoStar;\r\n\r\n        if let Err(BadRuleError::NotEnoughStarsInZone(GridSurfer::Region(region))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(region, 'A',\r\n                    \"Échec détection impossible de placer une étoile dans la région 'A' (region '{region}' identifiée)\");\r\n        } else {\r\n            panic!(\"Échec détection impossible de placer une étoile dans une région\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_too_many_stars_in_line() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement 2 étoiles non adjacentes dans 2eme ligne de la grille\r\n        grid.cell_mut(LineColumn::new(1, 0)).value = CellValue::Star;\r\n        grid.cell_mut(LineColumn::new(1, 4)).value = CellValue::Star;\r\n\r\n        if let Err(BadRuleError::TooManyStarsInZone(GridSurfer::Line(line))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(\r\n                line, 1,\r\n                \"Échec détection trop d'étoiles dans la ligne '1' (ligne '{line}' identifiée)\"\r\n            );\r\n        } else {\r\n            panic!(\"Échec détection trop d'étoiles dans une ligne\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_not_enough_stars_in_line() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement pas d'étoile dans les cases de la 2eme ligne de la grille\r\n        for column in 0..grid_handler.nb_columns() {\r\n            grid.cell_mut(LineColumn::new(1, column)).value = CellValue::NoStar;\r\n        }\r\n\r\n        if let Err(BadRuleError::NotEnoughStarsInZone(GridSurfer::Line(line))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(line, 1,\r\n                    \"Échec détection impossible de placer une étoile dans la ligne '1' (ligne '{line}' identifiée)\");\r\n        } else {\r\n            panic!(\"Échec détection impossible de placer une étoile dans une ligne\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_too_many_stars_in_column() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement 2 étoiles non adjacentes dans 2eme colonne de la grille\r\n        grid.cell_mut(LineColumn::new(0, 1)).value = CellValue::Star;\r\n        grid.cell_mut(LineColumn::new(4, 1)).value = CellValue::Star;\r\n\r\n        if let Err(BadRuleError::TooManyStarsInZone(GridSurfer::Column(column))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(\r\n                column, 1,\r\n                \"Échec détection trop d'étoiles dans la colonne '1' (colonne '{column}' identifiée)\"\r\n            );\r\n        } else {\r\n            panic!(\"Échec détection trop d'étoiles dans une colonne\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_not_enough_stars_in_colonne() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement pas d'étoile dans les cases de la 2eme colonne de la grille\r\n        for line in 0..grid_handler.nb_lines() {\r\n            grid.cell_mut(LineColumn::new(line, 1)).value = CellValue::NoStar;\r\n        }\r\n\r\n        if let Err(BadRuleError::NotEnoughStarsInZone(GridSurfer::Column(column))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(column, 1,\r\n                    \"Échec détection impossible de placer une étoile dans la colonne '1' (colonne '{column}' identifiée)\");\r\n        } else {\r\n            panic!(\"Échec détection impossible de placer une étoile dans une colonne\");\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":18158513697557839873}},{"line":33,"address":[],"length":0,"stats":{"Line":13618885273168380203}},{"line":34,"address":[],"length":0,"stats":{"Line":9871890383196127133}},{"line":35,"address":[],"length":0,"stats":{"Line":6269010681299730722}},{"line":37,"address":[],"length":0,"stats":{"Line":9511602413006487903}},{"line":38,"address":[],"length":0,"stats":{"Line":18158513697557840064}},{"line":40,"address":[],"length":0,"stats":{"Line":8358680908399644127}},{"line":41,"address":[],"length":0,"stats":{"Line":1297036692682704589}},{"line":43,"address":[],"length":0,"stats":{"Line":7061644215716937745}},{"line":47,"address":[],"length":0,"stats":{"Line":18158513697557841453}},{"line":48,"address":[],"length":0,"stats":{"Line":504403158265497225}},{"line":49,"address":[],"length":0,"stats":{"Line":792633534417207388}},{"line":50,"address":[],"length":0,"stats":{"Line":792633534417207388}},{"line":51,"address":[],"length":0,"stats":{"Line":792633534417228661}},{"line":52,"address":[],"length":0,"stats":{"Line":4251398048237749336}},{"line":53,"address":[],"length":0,"stats":{"Line":4251398048237749336}},{"line":54,"address":[],"length":0,"stats":{"Line":13907115649320091854}},{"line":55,"address":[],"length":0,"stats":{"Line":13907115649320091854}},{"line":56,"address":[],"length":0,"stats":{"Line":13907115649320091854}},{"line":62,"address":[],"length":0,"stats":{"Line":4251398048237748522}},{"line":66,"address":[],"length":0,"stats":{"Line":10088063165309917960}},{"line":67,"address":[],"length":0,"stats":{"Line":10088063165309917960}},{"line":68,"address":[],"length":0,"stats":{"Line":10088063165309917960}},{"line":70,"address":[],"length":0,"stats":{"Line":14627691589699383022}},{"line":71,"address":[],"length":0,"stats":{"Line":4539628424389465062}},{"line":72,"address":[],"length":0,"stats":{"Line":1801439850948244506}},{"line":73,"address":[],"length":0,"stats":{"Line":11889503016258065910}},{"line":74,"address":[],"length":0,"stats":{"Line":9295429630892706262}},{"line":78,"address":[],"length":0,"stats":{"Line":10088063165309916173}},{"line":79,"address":[],"length":0,"stats":{"Line":18374686479671628813}},{"line":80,"address":[],"length":0,"stats":{"Line":10160120759347838976}},{"line":81,"address":[],"length":0,"stats":{"Line":15708555500268290055}},{"line":84,"address":[],"length":0,"stats":{"Line":12898309332789100574}}],"covered":33,"coverable":33},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_cell.rs"],"content":"//! Case de la grille\n\nuse crate::CellValue;\nuse crate::LineColumn;\nuse crate::Region;\n\n/// Case de la grille\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct GridCell {\n    /// Coordonnées de la case dans la grille\n    pub line_column: LineColumn,\n\n    /// Région de la case\n    pub region: Region,\n\n    /// Valeur de la case\n    pub value: CellValue,\n}\n\nimpl GridCell {\n    /// Retourne `true` si la case n'est pas définie\n    #[must_use]\n    pub fn is_unknown(\u0026self) -\u003e bool {\n        self.value == CellValue::Unknown\n    }\n\n    /// Retourne `true` si la case ne peut pas être une étoile\n    #[must_use]\n    pub fn is_no_star(\u0026self) -\u003e bool {\n        self.value == CellValue::NoStar\n    }\n\n    /// Retourne `true` si la case est une étoile\n    #[must_use]\n    pub fn is_star(\u0026self) -\u003e bool {\n        self.value == CellValue::Star\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":9079256848778919937}},{"line":24,"address":[],"length":0,"stats":{"Line":9079256848778919937}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":1801439850948201992}},{"line":36,"address":[],"length":0,"stats":{"Line":1801439850948201992}}],"covered":4,"coverable":6},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","collector.rs"],"content":"//! Examine toutes les possibilités pour poser les étoiles manquantes dans une zone et recherche\r\n//! si des cases sont invariantes pour toutes ces possibilités.\u003cbr\u003e\r\n\r\nuse crate::check_bad_rules;\r\nuse crate::CellValue;\r\nuse crate::Grid;\r\nuse crate::GridHandler;\r\nuse crate::LineColumn;\r\n\r\n/// Structure pour la recherche des combinaisons possibles qui positionnent\r\n/// le nombre attendu d'étoiles dans une zone.\u003cbr\u003e\r\n///\r\n/// Une zone est ici une région, une ligne, une colonne ou un groupe de lignes ou de colonnes.\r\n///\r\n/// Cette structure propose 2 méthodes pour la recherche des grilles possibles :\r\n///\r\n/// * `collect_possible_grids` : Recherche les combinaisons possibles dans la zone uniquement\r\n/// * `collect_recursive_possible_grids` : Recherche les combinaison de manière récursive en\r\n///   examinant les autres cases des grilles possibles\r\n///\r\n/// Pour cela, cette structure `Collector` s'utilise comme suit :\r\n///\r\n/// - On détermine la zone à examiner pour cette règle. C'est un vecteur de `LineColumn` issu d'un `GridSurfer`\r\n/// - On construit un `collector` pour cette zone `Collector::new(handler, grid, zone, nb_stars)`\r\n/// - On appelle la méthode `collect_possible_grids` ou `collect_recursive_possible_grids` pour rechercher toutes\r\n///   les grilles possibles pour cette zone\r\n///\r\n/// Ensuite, la fonction `Variant::check_for_invariants` permet examiner les différentes grilles possibles\r\n/// pour en extraire d'éventuelles cases invariantes dans toutes les combinaisons\r\npub struct Collector\u003c'a\u003e {\r\n    /// Handler de la grille à étudier\r\n    handler: \u0026'a GridHandler,\r\n\r\n    /// Contenu de la grille à étudier\r\n    grid: \u0026'a Grid,\r\n\r\n    /// Liste des cases de la zone à étudier\r\n    zone: \u0026'a Vec\u003cLineColumn\u003e,\r\n\r\n    /// Nombre d'étoiles à placer dans la zone\r\n    nb_stars: usize,\r\n\r\n    /// Liste des combinaisons de grilles possibles pour placer le nombre d'étoiles demandés dans la zone\r\n    pub possible_grids: Vec\u003cGrid\u003e,\r\n}\r\n\r\nimpl\u003c'a\u003e Collector\u003c'a\u003e {\r\n    /// Constructeur d'une zone à examiner\r\n    pub const fn new(\r\n        handler: \u0026'a GridHandler,\r\n        grid: \u0026'a Grid,\r\n        zone: \u0026'a Vec\u003cLineColumn\u003e,\r\n        nb_stars: usize,\r\n    ) -\u003e Self {\r\n        Self {\r\n            handler,\r\n            grid,\r\n            zone,\r\n            nb_stars,\r\n            possible_grids: Vec::new(),\r\n        }\r\n    }\r\n\r\n    /// Cherche les combinaisons possibles qui positionnent le nombre attendu d'étoiles dans la zone.\r\n    ///\r\n    /// On utilise ici la 'force brute' pour tester toutes les façons de poser les étoiles manquantes\r\n    /// dans la zone.\r\n    ///\r\n    /// S'il y a n étoiles à placer (n \u003e 0) dans les m cases non définies d'une zone,\r\n    /// on explore tous les nombres de 1 à 2**m -1 qui ont n bits à 1 et on positionne des étoiles\r\n    /// dans tous les i-eme cases si me i-eme bit est 1.\r\n    /// Si la grille obtenue est 'viable', on la retient comme combinaison possible.\r\n    pub fn collect_possible_grids(\u0026mut self) {\r\n        let mut cur_nb_stars = 0; // Nombre d'étoiles déjà placées dans la région\r\n        let mut cur_nb_unknown = 0; // Nombre de cases non définies dans la grille\r\n        let mut cur_line_column_unknown = Vec::new(); // Coordonnées des cases non définies dans la région\r\n        for line_column in self.zone {\r\n            match self.grid.cell(*line_column).value {\r\n                CellValue::Star =\u003e cur_nb_stars += 1,\r\n                CellValue::NoStar =\u003e (),\r\n                CellValue::Unknown =\u003e {\r\n                    cur_nb_unknown += 1;\r\n                    cur_line_column_unknown.push(*line_column);\r\n                }\r\n            }\r\n        }\r\n\r\n        if cur_nb_stars \u003e= self.nb_stars {\r\n            // Toutes les étoiles sont placées dans la région.\r\n            // Rien à explorer dans cette région\r\n            return;\r\n        }\r\n\r\n        // Nombre d'étoiles qui restent à placer dans la région\r\n        let nb_to_do_star = self.nb_stars - cur_nb_stars;\r\n\r\n        assert!(\r\n            nb_to_do_star \u003c= cur_nb_unknown,\r\n            \"Situation inattendue lors de l'examen de la région !\"\r\n        );\r\n\r\n        // Boucle sur toutes les façons de poser `nb_to_do_star` étoiles dans les\r\n        // `cur_nb_unknown` cases non définies.\r\n        for combinaison in 1..usize::pow(\r\n            2,\r\n            u32::try_from(cur_nb_unknown).expect(\"Région trop grande (32 cases inconnues max) !\"),\r\n        ) {\r\n            // On a besoin d'autant de bits à 1 dans combinaison qu'on d'étoiles à placer\r\n            if count_ones(combinaison) == nb_to_do_star {\r\n                // On crée un nouvelle grille possible avec toutes les étoiles positionnées dans la région\r\n                let mut new_grid = self.grid.clone();\r\n                for (i, line_column) in cur_line_column_unknown.iter().enumerate() {\r\n                    new_grid.cell_mut(*line_column).value = {\r\n                        if combinaison \u0026 (1 \u003c\u003c i) == 0 {\r\n                            CellValue::NoStar\r\n                        } else {\r\n                            CellValue::Star\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Si cette nouvelle grille est viable... on l'ajoute à la liste des grilles possibles\r\n                if check_bad_rules(self.handler, \u0026new_grid).is_ok() {\r\n                    self.possible_grids.push(new_grid);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Cherche récursivement les combinaisons possibles qui positionnent le nombre attendu d'étoiles dans la zone.\r\n    ///\r\n    /// L'algorithme de recherche 'récursif' avec un cheminement comme suit :\r\n    ///\r\n    /// - On repère la première case possible de la zone qui peut contenir une étoile\r\n    /// - On pose une étoile dans cette case et on recherche les grilles possibles avec cette combinaison.\r\n    ///   Cette recherche se fait en appelant à nouveau le même algorithme de recherche\r\n    /// - Puis, on définit qu'il n'y a pas d'étoile dans cette case et on recherche à nouveau les grilles possibles\r\n    ///   avec cette combinaison. Cette recherche se fait en appelant à nouveau le même algorithme de recherche\r\n    /// - En final, toutes les grilles possibles collectées 'récursivement' sont des grilles possibles pour la zone\r\n    pub fn collect_recursive_possible_grids(\u0026mut self) {\r\n        // Décompte du nombre d'étoiles qui restent à placer dans la zone\r\n        let nb_current_stars = self\r\n            .zone\r\n            .iter()\r\n            .filter(|line_column| self.grid.cell(**line_column).value == CellValue::Star)\r\n            .count();\r\n\r\n        if nb_current_stars == self.nb_stars {\r\n            // Toutes les étoiles sont placées dans la zone\r\n            // La grille courante est la seule possibilité dans ce cas...\r\n            // On complète les cases non définies de cette zone par des cases sans étoile\r\n            let mut new_grid = self.grid.clone();\r\n            for line_column in self.zone {\r\n                if new_grid.cell(*line_column).value == CellValue::Unknown {\r\n                    new_grid.cell_mut(*line_column).value = CellValue::NoStar;\r\n                }\r\n            }\r\n            self.possible_grids.push(new_grid);\r\n            // ...qu'on retourne\r\n            return;\r\n        }\r\n\r\n        // Au moins une étoile est à placer. On cherche la première case possible dans la zone pour cela\r\n        if let Some(line_column) = self.first_possible_line_column_for_a_star() {\r\n            // On construit alors une nouvelle grille possible\r\n            // Et on pose une étoile dans cette case dans une nouvelle grille possible\r\n            // et on invalide la possibilité d'une étoile pour toutes les cases adjacentes\r\n            let mut new_grid = self.grid.clone();\r\n            self.set_star(\u0026mut new_grid, line_column);\r\n            // Si cette nouvelle grille est viable...\r\n            if check_bad_rules(self.handler, \u0026new_grid).is_ok() {\r\n                // ...on recherche les grilles possibles pour cette nouvelle grille\r\n                let mut new_collector =\r\n                    Collector::new(self.handler, \u0026new_grid, self.zone, self.nb_stars);\r\n                new_collector.collect_recursive_possible_grids();\r\n                // Toutes les grilles trouvées par ce nouveau collector sont des grilles possibles pour la grille courante\r\n                self.possible_grids.extend(new_collector.possible_grids);\r\n            }\r\n\r\n            //  Puis on construit une autre grille possible pour la zone sans une étoile dans cette case\r\n            let mut new_grid = self.grid.clone();\r\n            new_grid.cell_mut(line_column).value = CellValue::NoStar;\r\n            // On recherche les grilles possibles pour cette nouvelle grille\r\n            let mut new_collector =\r\n                Collector::new(self.handler, \u0026new_grid, self.zone, self.nb_stars);\r\n            new_collector.collect_recursive_possible_grids();\r\n            // Toutes les grilles trouvées par ce nouveau collector sont des grilles possibles pour la grille courante\r\n            self.possible_grids.extend(new_collector.possible_grids);\r\n        }\r\n\r\n        // On retourne les grilles trouvées jusqu'ici\r\n    }\r\n\r\n    /// Recherche la première case possible pour poser une étoile dans la zone\r\n    fn first_possible_line_column_for_a_star(\u0026self) -\u003e Option\u003cLineColumn\u003e {\r\n        for line_column in self.zone {\r\n            // Case possible pour poser une étoile ?\r\n            if self.grid.cell(*line_column).is_unknown() {\r\n                // Il ne faut pas d'étoiles dans les cases adjacentes à cette case\r\n                if self\r\n                    .handler\r\n                    .adjacent_cells(*line_column)\r\n                    .iter()\r\n                    .filter(|line_column| self.grid.cell(**line_column).value == CellValue::Star)\r\n                    .count()\r\n                    == 0\r\n                {\r\n                    return Some(*line_column);\r\n                }\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Pose une étoile sur une grille possible et indique que toutes les cases autour de cette étoile\r\n    /// ne peuvent pas être une étoile\r\n    fn set_star(\u0026self, new_grid: \u0026mut Grid, line_column: LineColumn) {\r\n        // Pose une étoile dans cette case dans une nouvelle grille possible\r\n        new_grid.cell_mut(line_column).value = CellValue::Star;\r\n        // On indique que toutes les cases autour de cette étoile ne peuvent pas être une étoile\r\n        for adjacent_line_column in self.handler.adjacent_cells(line_column) {\r\n            match self.grid.cell(adjacent_line_column).value {\r\n                CellValue::Star =\u003e panic!(\"Bug dans l'algo !!! La case {adjacent_line_column} ne devrait pas être une étoile\"),\r\n                CellValue::NoStar =\u003e (),\r\n                CellValue::Unknown =\u003e new_grid.cell_mut(adjacent_line_column).value = CellValue::NoStar,\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Compte le nombre de bits à 1 dans un usize\r\nconst fn count_ones(n: usize) -\u003e usize {\r\n    let mut count = 0;\r\n    let mut num = n;\r\n\r\n    while num \u003e 0 {\r\n        count += num \u0026 1; // Ajoute 1 si le bit de poids faible est 1\r\n        num \u003e\u003e= 1; // Décale num vers la droite\r\n    }\r\n\r\n    count\r\n}\r\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":60,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":73,"address":[],"length":0,"stats":{"Line":17293822569102704778}},{"line":74,"address":[],"length":0,"stats":{"Line":17293822569102704778}},{"line":75,"address":[],"length":0,"stats":{"Line":17293822569102704778}},{"line":76,"address":[],"length":0,"stats":{"Line":17293822569102704778}},{"line":77,"address":[],"length":0,"stats":{"Line":9223372036854776116}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":9079256848778919968}},{"line":80,"address":[],"length":0,"stats":{"Line":15780613094306217994}},{"line":81,"address":[],"length":0,"stats":{"Line":17221764975064776708}},{"line":82,"address":[],"length":0,"stats":{"Line":17221764975064776708}},{"line":83,"address":[],"length":0,"stats":{"Line":17221764975064776708}},{"line":88,"address":[],"length":0,"stats":{"Line":17293822569102704700}},{"line":91,"address":[],"length":0,"stats":{"Line":8502796096475496458}},{"line":95,"address":[],"length":0,"stats":{"Line":8791026472627208242}},{"line":97,"address":[],"length":0,"stats":{"Line":8791026472627208242}},{"line":98,"address":[],"length":0,"stats":{"Line":8791026472627208242}},{"line":99,"address":[],"length":0,"stats":{"Line":41}},{"line":104,"address":[],"length":0,"stats":{"Line":17293822569102704658}},{"line":105,"address":[],"length":0,"stats":{"Line":8791026472627208201}},{"line":106,"address":[],"length":0,"stats":{"Line":8791026472627208201}},{"line":109,"address":[],"length":0,"stats":{"Line":8502796096475496457}},{"line":111,"address":[],"length":0,"stats":{"Line":7493989779944575883}},{"line":112,"address":[],"length":0,"stats":{"Line":2377900603251692541}},{"line":113,"address":[],"length":0,"stats":{"Line":13330654897016668274}},{"line":114,"address":[],"length":0,"stats":{"Line":13330654897016668274}},{"line":115,"address":[],"length":0,"stats":{"Line":9151314442816850015}},{"line":117,"address":[],"length":0,"stats":{"Line":4179340454199818259}},{"line":123,"address":[],"length":0,"stats":{"Line":360287970189640116}},{"line":124,"address":[],"length":0,"stats":{"Line":11313042263954686170}},{"line":140,"address":[],"length":0,"stats":{"Line":17293822569102706350}},{"line":142,"address":[],"length":0,"stats":{"Line":17293822569102706350}},{"line":143,"address":[],"length":0,"stats":{"Line":17293822569102706350}},{"line":145,"address":[],"length":0,"stats":{"Line":17582052945254419804}},{"line":148,"address":[],"length":0,"stats":{"Line":17293822569102706350}},{"line":152,"address":[],"length":0,"stats":{"Line":12898309332789100671}},{"line":153,"address":[],"length":0,"stats":{"Line":2666130979403333960}},{"line":154,"address":[],"length":0,"stats":{"Line":16933534598913064987}},{"line":155,"address":[],"length":0,"stats":{"Line":16933534598913064987}},{"line":158,"address":[],"length":0,"stats":{"Line":12898309332789100564}},{"line":160,"address":[],"length":0,"stats":{"Line":12898309332789100564}},{"line":164,"address":[],"length":0,"stats":{"Line":17654110539292345872}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":3242591731706757151}},{"line":173,"address":[],"length":0,"stats":{"Line":3242591731706757151}},{"line":174,"address":[],"length":0,"stats":{"Line":3242591731706757151}},{"line":175,"address":[],"length":0,"stats":{"Line":3242591731706757151}},{"line":177,"address":[],"length":0,"stats":{"Line":3242591731706757151}},{"line":181,"address":[],"length":0,"stats":{"Line":17654110539292344399}},{"line":182,"address":[],"length":0,"stats":{"Line":17654110539292344399}},{"line":184,"address":[],"length":0,"stats":{"Line":17654110539292344399}},{"line":185,"address":[],"length":0,"stats":{"Line":17654110539292344399}},{"line":186,"address":[],"length":0,"stats":{"Line":17654110539292344399}},{"line":188,"address":[],"length":0,"stats":{"Line":17654110539292344399}},{"line":195,"address":[],"length":0,"stats":{"Line":4395513236313604423}},{"line":196,"address":[],"length":0,"stats":{"Line":16717361816799281095}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":17654110539292343840}},{"line":201,"address":[],"length":0,"stats":{"Line":17654110539292343840}},{"line":202,"address":[],"length":0,"stats":{"Line":17654110539292343840}},{"line":203,"address":[],"length":0,"stats":{"Line":17654110539292343840}},{"line":204,"address":[],"length":0,"stats":{"Line":7566047373982434387}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":17654110539292344340}},{"line":212,"address":[],"length":0,"stats":{"Line":5188146770730812295}},{"line":217,"address":[],"length":0,"stats":{"Line":17654110539292344395}},{"line":219,"address":[],"length":0,"stats":{"Line":17654110539292344395}},{"line":221,"address":[],"length":0,"stats":{"Line":7566047373982433430}},{"line":222,"address":[],"length":0,"stats":{"Line":8358680908399640651}},{"line":223,"address":[],"length":0,"stats":{"Line":493}},{"line":224,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":225,"address":[],"length":0,"stats":{"Line":5260204364768738910}},{"line":232,"address":[],"length":0,"stats":{"Line":8502796096475496698}},{"line":233,"address":[],"length":0,"stats":{"Line":8502796096475496698}},{"line":234,"address":[],"length":0,"stats":{"Line":8502796096475496698}},{"line":236,"address":[],"length":0,"stats":{"Line":14555633995661584400}},{"line":237,"address":[],"length":0,"stats":{"Line":3026418949593043851}},{"line":238,"address":[],"length":0,"stats":{"Line":3026418949593043851}},{"line":241,"address":[],"length":0,"stats":{"Line":8502796096475496698}}],"covered":76,"coverable":82},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","good_rule.rs"],"content":"//! Règles de construction/résolution d'une grille.\n//!\n//! Ce module expose les différentes règles permettant d'avancer dans la résolution d'une grille.\n\nuse std::fmt::Display;\n\nuse crate::check_bad_rules;\nuse crate::grid_action::display_vec_actions;\nuse crate::BadRuleError;\nuse crate::Grid;\nuse crate::GridAction;\nuse crate::GridHandler;\nuse crate::GridSurfer;\nuse crate::LineColumn;\nuse crate::Region;\n\nuse super::rule_no_star_adjacent_to_star::rule_no_star_adjacent_to_star;\nuse super::rule_region_combinations::{\n    rule_region_1_combinations, rule_region_2_combinations, rule_region_3_combinations,\n    rule_region_4_combinations,\n};\nuse super::rule_region_exclusions::{\n    rule_region_1_exclusions, rule_region_2_exclusions, rule_region_3_exclusions,\n    rule_region_4_exclusions,\n};\nuse super::rule_region_possible_stars::rule_region_possible_stars;\nuse super::rule_value_completed::rule_value_completed;\nuse super::rule_zone_possible_stars::{\n    rule_line_column_recursive_possible_stars, rule_multi_2_lines_columns_recursive_possible_stars,\n    rule_multi_3_lines_columns_recursive_possible_stars,\n    rule_multi_4_lines_columns_recursive_possible_stars, rule_region_recursive_possible_stars,\n};\n\n/// Énumération des règles applicables à la construction/résolution d'une grille\n#[derive(Clone, Debug)]\npub enum GoodRule {\n    /// Indique les cases adjacentes à une étoile qui ne peuvent pas contenir une étoile\n    NoStarAdjacentToStar(LineColumn, Vec\u003cGridAction\u003e),\n\n    /// Indique les cases restantes dans une zone ne peuvent pas être des étoiles\n    ZoneNoStarCompleted(GridSurfer, Vec\u003cGridAction\u003e),\n\n    /// Indique que les cases restantes des régions en dehors d'une combinaison de lignes ou colonnes\n    /// ne peuvent pas contenir des étoiles\n    ZoneExclusions(Vec\u003cRegion\u003e, GridSurfer, Vec\u003cGridAction\u003e),\n\n    /// Indique que les cases restantes en dehors d'une combinaison de régions/lignes ou colonnes\n    /// ne peuvent pas contenir des étoiles\n    ZoneCombinations(Vec\u003cRegion\u003e, GridSurfer, Vec\u003cGridAction\u003e),\n\n    /// Indique les cases restantes dans une zone sont forcement des étoiles\n    ZoneStarCompleted(GridSurfer, Vec\u003cGridAction\u003e),\n\n    /// Indique que quelle que soit la façon de placer les étoiles dans une zone, des cases n'ont\n    /// toujours qu'une seule et même possibilité\n    InvariantWithZone(GridSurfer, Vec\u003cGridAction\u003e),\n}\n\nimpl Display for GoodRule {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        // Texte pour une ligne de régions\n        fn display_vec_regions(regions: \u0026[Region]) -\u003e String {\n            let mut str_regions = String::new();\n            for region in regions {\n                if !str_regions.is_empty() {\n                    str_regions.push('+');\n                }\n                str_regions.push(*region);\n            }\n            str_regions\n        }\n\n        match self {\n            Self::NoStarAdjacentToStar(line_column, actions) =\u003e {\n                write!(f, \"Les cases adjacentes à l'étoile en {line_column} ne peuvent pas contenir une étoile : {}\", display_vec_actions(actions))\n            }\n            Self::ZoneNoStarCompleted(grid_surfer, actions) =\u003e {\n                write!(\n                    f,\n                    \"Les cases restantes pour {grid_surfer} ne peuvent pas contenir une étoile : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n            Self::ZoneExclusions(regions, grid_surfer, actions) =\u003e {\n                let str_regions = display_vec_regions(regions);\n                write!(\n                    f,\n                    \"Les cases restantes des regions {str_regions} qui ne sont pas dans {grid_surfer} ne peuvent être une étoile : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n            Self::ZoneCombinations(regions, grid_surfer, actions) =\u003e {\n                let str_regions = display_vec_regions(regions);\n                write!(\n                    f,\n                    \"Les cases restantes sur {grid_surfer} qui ne sont pas dans les régions {str_regions} ne peuvent être une étoile : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n            Self::ZoneStarCompleted(grid_surfer, actions) =\u003e {\n                write!(\n                    f,\n                    \"Les cases restantes pour {grid_surfer} peuvent être qu'une étoile : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n            Self::InvariantWithZone(surfer, actions) =\u003e {\n                write!(\n                    f,\n                    \"Toutes les possibilités pour {surfer} impliquent la seule possibilité : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n        }\n    }\n}\n\nimpl Grid {\n    /// Application d'une règle de construction sur une grille\n    pub fn apply_good_rule(\u0026mut self, rule: \u0026GoodRule) {\n        match rule {\n            GoodRule::NoStarAdjacentToStar(_, actions)\n            | GoodRule::ZoneNoStarCompleted(_, actions)\n            | GoodRule::ZoneExclusions(_, _, actions)\n            | GoodRule::ZoneCombinations(_, _, actions)\n            | GoodRule::ZoneStarCompleted(_, actions)\n            | GoodRule::InvariantWithZone(_, actions) =\u003e {\n                for action in actions {\n                    self.apply_action(action);\n                }\n            }\n        }\n    }\n}\n\n/// Identification d'une règle de construction applicable à la grille.\u003cbr\u003e\n/// Retourne une règle applicable à la construction/résolution de la grille si trouvé. None sinon.\n/// ### Errors\n/// Retourne un [`BadRuleError`] si la grille n'est pas valide\n#[allow(clippy::module_name_repetitions)]\npub fn get_good_rule(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Result\u003cOption\u003cGoodRule\u003e, BadRuleError\u003e {\n    // Grille viable ?\n    check_bad_rules(handler, grid)?;\n\n    // Grille terminée ?\n    if handler.is_done(grid) {\n        return Ok(None);\n    }\n\n    for f in [\n        rule_no_star_adjacent_to_star,\n        rule_value_completed,\n        rule_region_1_exclusions,\n        rule_region_1_combinations,\n        rule_region_possible_stars,\n        rule_region_2_exclusions,\n        rule_region_2_combinations,\n        rule_region_recursive_possible_stars,\n        rule_region_3_exclusions,\n        rule_region_3_combinations,\n        rule_line_column_recursive_possible_stars,\n        rule_region_4_exclusions,\n        rule_region_4_combinations,\n        rule_multi_2_lines_columns_recursive_possible_stars,\n        rule_multi_3_lines_columns_recursive_possible_stars,\n        rule_multi_4_lines_columns_recursive_possible_stars,\n    ] {\n        if let Some(rule) = f(handler, grid) {\n            return Ok(Some(rule));\n        }\n    }\n\n    Ok(None)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::fs::File;\n    use std::io::Read;\n\n    use crate::GridParser;\n\n    // Liste des grilles d'exemple\n    const TEST_GRIDS_FILENAME_AND_NB_STARS: \u0026[(\u0026str, usize)] = \u0026[\n        (\"./test_grids/test01.txt\", 1),\n        (\"./test_grids/facile01_2.txt\", 2),\n        (\"./test_grids/moyen01_2.txt\", 2),\n        (\"./test_grids/difficile01_2.txt\", 2),\n        (\"./test_grids/expert01_2.txt\", 2),\n        (\"./test_grids/facile02_2.txt\", 2),\n        (\"./test_grids/moyen02_2.txt\", 2),\n        (\"./test_grids/difficile02_2.txt\", 2),\n        (\"./test_grids/expert02_2.txt\", 2),\n        (\"./test_grids/facile03_2.txt\", 2),\n        (\"./test_grids/moyen03_2.txt\", 2),\n        (\"./test_grids/difficile03_2.txt\", 2),\n        (\"./test_grids/expert03_2.txt\", 2),\n        (\"./test_grids/facile04_2.txt\", 2),\n        (\"./test_grids/moyen04_2.txt\", 2),\n        (\"./test_grids/difficile04_2.txt\", 2),\n        (\"./test_grids/expert04_2.txt\", 2),\n    ];\n\n    // #[test]\n    // fn test_grid_dd_debug() {\n    //     test_all_test_grids(\"facile03\");\n    // }\n\n    #[test]\n    fn test_grid_test() {\n        test_all_test_grids(\"test\");\n    }\n\n    #[test]\n    fn test_grid_facile() {\n        test_all_test_grids(\"facile\");\n    }\n\n    #[test]\n    fn test_grid_moyen() {\n        test_all_test_grids(\"moyen\");\n    }\n\n    #[test]\n    fn test_grid_difficile() {\n        test_all_test_grids(\"difficile\");\n    }\n\n    #[test]\n    fn test_grid_expert() {\n        test_all_test_grids(\"expert\");\n    }\n\n    /// Primitive générique qui teste les grilles de tests dont le nom de leur fichier contient\n    /// la chaîne `filename_part`\n    /// (Evite de tout tester silencieusement car c'est un peu long...)\n    fn test_all_test_grids(filename_part: \u0026str) {\n        for (grid_file_name, nb_stars) in TEST_GRIDS_FILENAME_AND_NB_STARS {\n            if grid_file_name.contains(filename_part) {\n                // Ouverture du fichier\n                println!(\"Fichier : {grid_file_name}\");\n                let mut file = File::open(grid_file_name).unwrap();\n                // Lecture du fichier\n                let mut file_contents = String::new();\n                file.read_to_string(\u0026mut file_contents).unwrap();\n                // Conversion en Grid\n                let grid_parser = GridParser::try_from(file_contents.as_str()).unwrap();\n                let grid_handler = GridHandler::new(\u0026grid_parser, *nb_stars);\n                let mut grid = Grid::from(\u0026grid_handler);\n                // Boucle de résolution\n                loop {\n                    match get_good_rule(\u0026grid_handler, \u0026grid) {\n                        Ok(option_good_rule) =\u003e {\n                            if option_good_rule.is_some() {\n                                let good_rule = option_good_rule.unwrap();\n                                grid.apply_good_rule(\u0026good_rule);\n                            } else {\n                                break;\n                            }\n                        }\n                        Err(bad_rule) =\u003e {\n                            panic!(\"{bad_rule} !!!\");\n                        }\n                    }\n                }\n\n                println!(\n                    \"\\nFILE {grid_file_name}\\n{}\",\n                    grid_handler.display(\u0026grid, true)\n                );\n                assert!(grid_handler.is_done(\u0026grid));\n            }\n        }\n    }\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":108,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":109,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":111,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":120,"address":[],"length":0,"stats":{"Line":3963167672086036488}},{"line":121,"address":[],"length":0,"stats":{"Line":3963167672086036488}},{"line":122,"address":[],"length":0,"stats":{"Line":864691128455135235}},{"line":123,"address":[],"length":0,"stats":{"Line":9007199254740992004}},{"line":124,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":125,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":126,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":127,"address":[],"length":0,"stats":{"Line":3386706919782612993}},{"line":128,"address":[],"length":0,"stats":{"Line":5404319552844595211}},{"line":129,"address":[],"length":0,"stats":{"Line":6629298651489370113}},{"line":141,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":143,"address":[],"length":0,"stats":{"Line":5692549928996306948}},{"line":146,"address":[],"length":0,"stats":{"Line":5692549928996306940}},{"line":147,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":150,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":168,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":169,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":173,"address":[],"length":0,"stats":{"Line":4}}],"covered":24,"coverable":51},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","invariant.rs"],"content":"//! Recherche des cases invariantes dans une collection de grilles\r\n\r\nuse crate::CellValue;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\n\r\n/// Énumération de la situation pour les cases possiblement variantes dans toutes les\r\n/// combinaisons possibles de grilles\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\npub enum Variant {\r\n    // Case initialement inconnue\r\n    Init,\r\n\r\n    // Case vue comme une étoile dans une des grilles possibles\r\n    Star,\r\n\r\n    // Case vue comme sans étoile dans une des grilles possibles\r\n    NoStar,\r\n\r\n    // Case vue comme inconnue dans une des grilles possibles\r\n    Unknown,\r\n\r\n    // Case vue avec différentes possibilités dans les grilles possibles\r\n    Variable,\r\n}\r\n\r\nimpl Variant {\r\n    /// Retourne l'état `Variant` résultant de la combinaison de 2 `Variant`\r\n    pub const fn combine(self, other: Self) -\u003e Self {\r\n        match (self, other) {\r\n            /* Toutes les cases combinées avec un Variant::Init devient l'autre variant */\r\n            /* Une Variant::Star ne peut se combiner qu'avec un autre Variant::Star sinon c'est Variant::Variant */\r\n            /* Idem pour les Variant::NoStar */\r\n            /* Idem pour les Variant::Unknown */\r\n            /* Les Variant::Variant ne peuvent que rester Variant::Variant */\r\n            (Self::Init, other) | (other, Self::Init) =\u003e other,\r\n            (Self::Star, Self::Star) =\u003e Self::Star,\r\n            (Self::NoStar, Self::NoStar) =\u003e Self::NoStar,\r\n            (Self::Unknown, Self::Unknown) =\u003e Self::Unknown,\r\n            (Self::Star | Self::NoStar | Self::Unknown | Self::Variable, _) =\u003e Self::Variable,\r\n        }\r\n    }\r\n\r\n    /// Examine un ensemble des grilles possibles collectées à partir d'une grille initiale à la recherche\r\n    /// de cases invariantes pour toutes les possibilités de grilles\r\n    pub fn check_for_invariants(\r\n        handler: \u0026GridHandler,\r\n        grid: \u0026Grid,\r\n        possible_grids: \u0026Vec\u003cGrid\u003e,\r\n    ) -\u003e Vec\u003cGridAction\u003e {\r\n        // Liste des cases non déterminées dans la grille initiale\r\n        let mut cells = Vec::new();\r\n        // Liste des 'Variant' de ces cases\r\n        let mut variants = Vec::new();\r\n        for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\r\n            if grid.cell(line_column).is_unknown() {\r\n                cells.push(line_column);\r\n                variants.push(Self::Init);\r\n            }\r\n        }\r\n\r\n        // Parcours de toutes les grilles possibles collectées\r\n        for grid in possible_grids {\r\n            // On combine toutes les cases à examiner avec ce qu'on a déjà observé\r\n            for (line_column, variant) in cells.iter().zip(variants.iter_mut()) {\r\n                let prev_variant = *variant;\r\n                let new_variant = prev_variant.combine(match grid.cell(*line_column).value {\r\n                    CellValue::Star =\u003e Self::Star,\r\n                    CellValue::NoStar =\u003e Self::NoStar,\r\n                    CellValue::Unknown =\u003e Self::Unknown,\r\n                });\r\n                *variant = new_variant;\r\n            }\r\n        }\r\n\r\n        // Liste des invariants dans toutes les grilles examinées\r\n        let mut invariants_actions = Vec::new();\r\n        for (line_column, variant) in cells.iter().zip(variants.iter()) {\r\n            match variant {\r\n                Self::Star =\u003e {\r\n                    /* Cette case est toujours une étoile dans toutes les grilles possibles */\r\n                    invariants_actions.push(GridAction::SetStar(*line_column));\r\n                }\r\n                Self::NoStar =\u003e {\r\n                    /* Cette case n'est jamais une étoile dans toutes les grilles possibles */\r\n                    invariants_actions.push(GridAction::SetNoStar(*line_column));\r\n                }\r\n                _ =\u003e (),\r\n            }\r\n        }\r\n\r\n        invariants_actions\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_combine_variants() {\r\n        let expected = vec![\r\n            /* (variant1, variant2), expected variant1.combine(variant2) */\r\n\r\n            /* Toutes les cases combinées avec un Variant::Init devient l'autre variant */\r\n            ((Variant::Init, Variant::Init), Variant::Init),\r\n            ((Variant::Init, Variant::Star), Variant::Star),\r\n            ((Variant::Init, Variant::NoStar), Variant::NoStar),\r\n            ((Variant::Init, Variant::Unknown), Variant::Unknown),\r\n            ((Variant::Init, Variant::Variable), Variant::Variable),\r\n            ((Variant::Star, Variant::Init), Variant::Star),\r\n            ((Variant::NoStar, Variant::Init), Variant::NoStar),\r\n            ((Variant::Unknown, Variant::Init), Variant::Unknown),\r\n            ((Variant::Variable, Variant::Init), Variant::Variable),\r\n            /* Une Variant::Star ne peut se combiner qu'avec un autre Variant::Star sinon c'est Variant::Variant */\r\n            ((Variant::Star, Variant::Star), Variant::Star),\r\n            ((Variant::Star, Variant::NoStar), Variant::Variable),\r\n            ((Variant::Star, Variant::Unknown), Variant::Variable),\r\n            ((Variant::Star, Variant::Variable), Variant::Variable),\r\n            /* Une Variant::NoStar ne peut se combiner qu'avec un autre Variant::NoStar sinon c'est Variant::Variant */\r\n            ((Variant::NoStar, Variant::Star), Variant::Variable),\r\n            ((Variant::NoStar, Variant::NoStar), Variant::NoStar),\r\n            ((Variant::NoStar, Variant::Unknown), Variant::Variable),\r\n            ((Variant::NoStar, Variant::Variable), Variant::Variable),\r\n            /* Une Variant::Unknown ne peut se combiner qu'avec un autre Variant::Unknown sinon c'est Variant::Variant */\r\n            ((Variant::Unknown, Variant::Star), Variant::Variable),\r\n            ((Variant::Unknown, Variant::NoStar), Variant::Variable),\r\n            ((Variant::Unknown, Variant::Unknown), Variant::Unknown),\r\n            ((Variant::Unknown, Variant::Variable), Variant::Variable),\r\n            /* Les Variant::Variant ne peuvent que rester Variant::Variant */\r\n            ((Variant::Variable, Variant::Star), Variant::Variable),\r\n            ((Variant::Variable, Variant::NoStar), Variant::Variable),\r\n            ((Variant::Variable, Variant::Unknown), Variant::Variable),\r\n            ((Variant::Variable, Variant::Variable), Variant::Variable),\r\n        ];\r\n\r\n        for ((v1, v2), expected) in expected {\r\n            assert_eq!(v1.combine(v2), expected);\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":32,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":38,"address":[],"length":0,"stats":{"Line":12393906174523603650}},{"line":39,"address":[],"length":0,"stats":{"Line":5620492334958379348}},{"line":40,"address":[],"length":0,"stats":{"Line":15060037153926945035}},{"line":41,"address":[],"length":0,"stats":{"Line":1271}},{"line":42,"address":[],"length":0,"stats":{"Line":15492382718154506240}},{"line":48,"address":[],"length":0,"stats":{"Line":13690942867206307856}},{"line":54,"address":[],"length":0,"stats":{"Line":13690942867206307856}},{"line":56,"address":[],"length":0,"stats":{"Line":13690942867206307856}},{"line":57,"address":[],"length":0,"stats":{"Line":10088063165309911070}},{"line":58,"address":[],"length":0,"stats":{"Line":2089670227099911336}},{"line":59,"address":[],"length":0,"stats":{"Line":5692549928996308122}},{"line":60,"address":[],"length":0,"stats":{"Line":5692549928996308122}},{"line":65,"address":[],"length":0,"stats":{"Line":6773413839565227306}},{"line":67,"address":[],"length":0,"stats":{"Line":12898309332789100558}},{"line":68,"address":[],"length":0,"stats":{"Line":12898309332789100558}},{"line":69,"address":[],"length":0,"stats":{"Line":7349874591868649500}},{"line":70,"address":[],"length":0,"stats":{"Line":6845471433603162630}},{"line":71,"address":[],"length":0,"stats":{"Line":2449958197289550119}},{"line":72,"address":[],"length":0,"stats":{"Line":3602879701896387809}},{"line":79,"address":[],"length":0,"stats":{"Line":13690942867206307986}},{"line":80,"address":[],"length":0,"stats":{"Line":936748722493063328}},{"line":81,"address":[],"length":0,"stats":{"Line":5692549928996306958}},{"line":82,"address":[],"length":0,"stats":{"Line":5332261958806666555}},{"line":83,"address":[],"length":0,"stats":{"Line":5332261958806666555}},{"line":84,"address":[],"length":0,"stats":{"Line":5332261958806666555}},{"line":86,"address":[],"length":0,"stats":{"Line":17726168133330272976}},{"line":87,"address":[],"length":0,"stats":{"Line":17726168133330272976}},{"line":88,"address":[],"length":0,"stats":{"Line":17726168133330272976}},{"line":90,"address":[],"length":0,"stats":{"Line":1080863910568919043}},{"line":94,"address":[],"length":0,"stats":{"Line":13690942867206309152}}],"covered":32,"coverable":32},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","mod.rs"],"content":"//! Gestion des règles de construction/résolution d'une grille\r\n\r\nmod collector;\r\nmod good_rule;\r\nmod invariant;\r\nmod rule_generic_possible_stars;\r\nmod rule_no_star_adjacent_to_star;\r\nmod rule_region_combinations;\r\nmod rule_region_exclusions;\r\nmod rule_region_possible_stars;\r\nmod rule_value_completed;\r\nmod rule_zone_possible_stars;\r\nmod star_adjacent;\r\n\r\npub use good_rule::{get_good_rule, GoodRule};\r\nuse rule_generic_possible_stars::{rule_generic_possible_stars, ZoneToExamine};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_generic_possible_stars.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche générique des cases invariantes pour toutes les combinaisons possibles d'une zone.\r\n//!\r\n\r\nuse crate::CellValue;\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\n\r\nuse super::collector::Collector;\r\nuse super::invariant::Variant;\r\nuse super::star_adjacent::StarAdjacent;\r\n\r\n/// Énumération des différentes zones possibles pour être examinées\r\n#[derive(Debug, PartialEq, Eq, Clone, Copy)]\r\npub enum ZoneToExamine {\r\n    Region,\r\n    LineAndColumn,\r\n    MultipleLinesAndColumns(usize),\r\n}\r\n\r\n/// Méthode générique qui cherche toutes les combinaisons possibles dans les différentes zones ou régions\r\npub fn rule_generic_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    zone_to_examine: ZoneToExamine,\r\n    recursive: bool,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    // Pour simplifier la règle présentée à un humain, on retient la région qui génère un minimum\r\n    // de grilles pour placer toutes les étoiles\r\n    #[derive(Debug, Default)]\r\n    struct BestCollector {\r\n        grid_surfer: Option\u003cGridSurfer\u003e,\r\n        nb_possible_grids: usize,\r\n        invariant_actions: Vec\u003cGridAction\u003e,\r\n    }\r\n\r\n    // zones: [(GridSurfer, nb_stars, combinaisons_count)]\r\n    let mut zones = Vec::new();\r\n\r\n    // Closure pour compléter la liste des zones à examiner (évite les répétitions de paramètres)\r\n    let mut add_zone = |grid_surfer: GridSurfer, nb_stars: usize| {\r\n        let nb_combinaisons = combinaisons_count(handler, grid, \u0026grid_surfer, nb_stars);\r\n        zones.push((grid_surfer, nb_stars, nb_combinaisons));\r\n    };\r\n\r\n    match zone_to_examine {\r\n        ZoneToExamine::Region =\u003e {\r\n            // Parcours de toutes les régions\r\n            for region in handler.regions() {\r\n                add_zone(GridSurfer::Region(region), handler.nb_stars());\r\n            }\r\n        }\r\n        ZoneToExamine::LineAndColumn =\u003e {\r\n            // Parcours de toutes les lignes\r\n            for line in 0..handler.nb_lines() {\r\n                add_zone(GridSurfer::Line(line), handler.nb_stars());\r\n            }\r\n            // Parcours de toutes les colonnes\r\n            for column in 0..handler.nb_columns() {\r\n                add_zone(GridSurfer::Column(column), handler.nb_stars());\r\n            }\r\n        }\r\n        ZoneToExamine::MultipleLinesAndColumns(2) =\u003e {\r\n            // Double-lignes\r\n            for line in 0..handler.nb_lines() - 1 {\r\n                add_zone(GridSurfer::Lines(line..=line + 1), 2 * handler.nb_stars());\r\n            }\r\n\r\n            // Double-colonnes\r\n            for column in 0..handler.nb_columns() - 1 {\r\n                add_zone(\r\n                    GridSurfer::Columns(column..=column + 1),\r\n                    2 * handler.nb_stars(),\r\n                );\r\n            }\r\n        }\r\n        ZoneToExamine::MultipleLinesAndColumns(3) =\u003e {\r\n            // Double-lignes\r\n            for line in 0..handler.nb_lines() - 2 {\r\n                add_zone(GridSurfer::Lines(line..=line + 2), 3 * handler.nb_stars());\r\n            }\r\n\r\n            // Double-colonnes\r\n            for column in 0..handler.nb_columns() - 2 {\r\n                add_zone(\r\n                    GridSurfer::Columns(column..=column + 2),\r\n                    3 * handler.nb_stars(),\r\n                );\r\n            }\r\n        }\r\n        ZoneToExamine::MultipleLinesAndColumns(4) =\u003e {\r\n            // Double-lignes\r\n            for line in 0..handler.nb_lines() - 3 {\r\n                add_zone(GridSurfer::Lines(line..=line + 3), 4 * handler.nb_stars());\r\n            }\r\n\r\n            // Double-colonnes\r\n            for column in 0..handler.nb_columns() - 3 {\r\n                add_zone(\r\n                    GridSurfer::Columns(column..=column + 3),\r\n                    4 * handler.nb_stars(),\r\n                );\r\n            }\r\n        }\r\n        ZoneToExamine::MultipleLinesAndColumns(_) =\u003e {\r\n            todo!(\r\n                \"rule_multi_lines_columns_recursive_possible_stars pour plus de 4 lignes/colonnes\"\r\n            )\r\n        }\r\n    }\r\n\r\n    // Tri des différentes zones par ordre croissant de combinaisons possible\r\n    zones.sort_by(|a, b| a.2.cmp(\u0026b.2));\r\n\r\n    let mut best_collector = BestCollector::default();\r\n    // Examine les différentes zones\r\n    for (grid_surfer, nb_stars, _) in zones {\r\n        let (invariant_actions, nb_possible_grids) =\r\n            try_star_complete(handler, grid, \u0026grid_surfer, nb_stars, recursive);\r\n        if !invariant_actions.is_empty()\r\n        // La règle s'applique pour cette zone...\r\n            \u0026\u0026 (best_collector.grid_surfer.is_none()\r\n            // ... et c'est la première zone qui permet d'appliquer la règle...\r\n                || nb_possible_grids \u003c best_collector.nb_possible_grids)\r\n        // ... ou le nombre de grilles possibles est moindre que ce qu'on a déjà vu\r\n        {\r\n            best_collector = BestCollector {\r\n                grid_surfer: Some(grid_surfer),\r\n                nb_possible_grids,\r\n                invariant_actions,\r\n            };\r\n        }\r\n    }\r\n    // Règle trouvée ?\r\n    if best_collector.grid_surfer.is_some() {\r\n        Some(GoodRule::InvariantWithZone(\r\n            best_collector.grid_surfer.unwrap(),\r\n            best_collector.invariant_actions,\r\n        ))\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n/// Calcul le nombre de combinaisons possible pour placer toutes les étoiles dans une zone\r\nfn combinaisons_count(\r\n    grid_handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    grid_surfer: \u0026GridSurfer,\r\n    nb_stars: usize,\r\n) -\u003e usize {\r\n    // Nombre d'étoiles déjà placées dans la zone\r\n    let cur_nb_stars =\r\n        grid_handler.surfer_cells_with_value_count(grid, grid_surfer, \u0026CellValue::Star);\r\n    if cur_nb_stars \u003e= nb_stars {\r\n        return usize::MAX; // Pas de combinaison possible\r\n    }\r\n    // Nombre d'étoiles restant à placer dans la zone\r\n    let nb_stars_left = nb_stars - cur_nb_stars;\r\n    // Nombre de case non définies dans la zone\r\n    let mut nb_cells =\r\n        grid_handler.surfer_cells_with_value_count(grid, grid_surfer, \u0026CellValue::Unknown);\r\n    if nb_cells \u003c= nb_stars_left {\r\n        return 0; // Pas de combinaison possible\r\n    }\r\n    let mut nb_combinaisons = 1;\r\n    for _ in 0..nb_stars_left {\r\n        // Pour chaque étoile restant à placer, on ajoute le nombre de combinaisons possible\r\n        nb_combinaisons *= nb_cells;\r\n        nb_cells -= 1;\r\n    }\r\n    nb_combinaisons\r\n}\r\n\r\n/// Vérifie si la règle est applicable sur la région définie.\u003cbr\u003e\r\n/// Si applicable, retourne la liste des actions déduites par la règle et le nombre de grilles possibles\r\n/// qui ont été examinées pour ces actions\r\nfn try_star_complete(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    grid_surfer: \u0026GridSurfer,\r\n    nb_stars: usize,\r\n    recursive: bool,\r\n) -\u003e (Vec\u003cGridAction\u003e, usize) {\r\n    let surfer = handler.surfer(grid, grid_surfer);\r\n    let mut collector = Collector::new(handler, grid, \u0026surfer, nb_stars);\r\n    if recursive {\r\n        collector.collect_recursive_possible_grids();\r\n    } else {\r\n        collector.collect_possible_grids();\r\n    }\r\n    // Liste des invariants dans la région pour toutes les grilles possibles\r\n    let mut invariants = Variant::check_for_invariants(handler, grid, \u0026collector.possible_grids);\r\n    // Qu'on complète avec les cases autour des régions qui sont toujours adjacentes à une étoile dans la\r\n    // région pour toutes les grilles possibles (et qui ne sont pas déjà présentes dans les invariants)\r\n    let star_adjacents =\r\n        StarAdjacent::check_for_star_adjacents(handler, grid, \u0026collector.possible_grids);\r\n    for action in star_adjacents {\r\n        if !invariants.contains(\u0026action) {\r\n            invariants.push(action);\r\n        }\r\n    }\r\n    (invariants, collector.possible_grids.len())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n    use crate::LineColumn;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_combinaisons_count() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // La zone A contient 2 cases non définies =\u003e 2 combinaisons pour placer une étoile\r\n        assert_eq!(\r\n            combinaisons_count(\u0026grid_handler, \u0026grid, \u0026GridSurfer::Region('A'), 1),\r\n            2\r\n        );\r\n\r\n        // La ligne 0 contient 5 cases non définies =\u003e 5 x 4 = 20 combinaisons pour placer 2 étoiles\r\n        assert_eq!(\r\n            combinaisons_count(\u0026grid_handler, \u0026grid, \u0026GridSurfer::Line(0), 2),\r\n            20\r\n        );\r\n\r\n        // On place une étoile en (0, 0)\r\n        grid.cell_mut(LineColumn::new(0, 0)).value = CellValue::Star;\r\n\r\n        // La colonne 0 contient 1 étoiles et 4 cases non définies =\u003e 4 combinaisons pour placer 2 étoiles\r\n        assert_eq!(\r\n            combinaisons_count(\u0026grid_handler, \u0026grid, \u0026GridSurfer::Column(0), 2),\r\n            4\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":10376293541461622793}},{"line":42,"address":[],"length":0,"stats":{"Line":10376293541461622793}},{"line":45,"address":[],"length":0,"stats":{"Line":5620492334958379030}},{"line":46,"address":[],"length":0,"stats":{"Line":13690942867206307853}},{"line":47,"address":[],"length":0,"stats":{"Line":13690942867206307853}},{"line":50,"address":[],"length":0,"stats":{"Line":10376293541461622793}},{"line":53,"address":[],"length":0,"stats":{"Line":12826251738751172618}},{"line":54,"address":[],"length":0,"stats":{"Line":2161727821137838081}},{"line":59,"address":[],"length":0,"stats":{"Line":10952754293765046273}},{"line":60,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":63,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":64,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":69,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":70,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":74,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":76,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":77,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":26}},{"line":98,"address":[],"length":0,"stats":{"Line":13}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":17077649786988920846}},{"line":121,"address":[],"length":0,"stats":{"Line":864691128455135258}},{"line":126,"address":[],"length":0,"stats":{"Line":7061644215716937741}},{"line":128,"address":[],"length":0,"stats":{"Line":3674937295934324748}},{"line":131,"address":[],"length":0,"stats":{"Line":7205759403792793602}},{"line":132,"address":[],"length":0,"stats":{"Line":7205759403792793602}},{"line":133,"address":[],"length":0,"stats":{"Line":7205759403792793602}},{"line":134,"address":[],"length":0,"stats":{"Line":7205759403792793602}},{"line":139,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":140,"address":[],"length":0,"stats":{"Line":3386706919782612993}},{"line":141,"address":[],"length":0,"stats":{"Line":3386706919782612993}},{"line":142,"address":[],"length":0,"stats":{"Line":3386706919782612993}},{"line":145,"address":[],"length":0,"stats":{"Line":6989586621679009791}},{"line":150,"address":[],"length":0,"stats":{"Line":13907115649320091649}},{"line":157,"address":[],"length":0,"stats":{"Line":13907115649320091649}},{"line":158,"address":[],"length":0,"stats":{"Line":13907115649320091649}},{"line":159,"address":[],"length":0,"stats":{"Line":13907115649320091649}},{"line":160,"address":[],"length":0,"stats":{"Line":15276209936040722446}},{"line":163,"address":[],"length":0,"stats":{"Line":17077649786988920819}},{"line":165,"address":[],"length":0,"stats":{"Line":17077649786988920819}},{"line":166,"address":[],"length":0,"stats":{"Line":17077649786988920819}},{"line":167,"address":[],"length":0,"stats":{"Line":17077649786988920819}},{"line":168,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":170,"address":[],"length":0,"stats":{"Line":17005592192950992882}},{"line":171,"address":[],"length":0,"stats":{"Line":6557241057451442174}},{"line":173,"address":[],"length":0,"stats":{"Line":7998392938210000908}},{"line":174,"address":[],"length":0,"stats":{"Line":7998392938210000908}},{"line":176,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":182,"address":[],"length":0,"stats":{"Line":13690942867206307863}},{"line":189,"address":[],"length":0,"stats":{"Line":13690942867206307863}},{"line":190,"address":[],"length":0,"stats":{"Line":13690942867206307863}},{"line":191,"address":[],"length":0,"stats":{"Line":10088063165309911077}},{"line":192,"address":[],"length":0,"stats":{"Line":14843864371813154830}},{"line":194,"address":[],"length":0,"stats":{"Line":17293822569102704649}},{"line":197,"address":[],"length":0,"stats":{"Line":13690942867206307863}},{"line":200,"address":[],"length":0,"stats":{"Line":13690942867206307863}},{"line":201,"address":[],"length":0,"stats":{"Line":13690942867206307863}},{"line":202,"address":[],"length":0,"stats":{"Line":5188146770730811444}},{"line":203,"address":[],"length":0,"stats":{"Line":6052837899185946627}},{"line":204,"address":[],"length":0,"stats":{"Line":6052837899185946627}},{"line":207,"address":[],"length":0,"stats":{"Line":13690942867206307846}}],"covered":60,"coverable":68},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_no_star_adjacent_to_star.rs"],"content":"//! Règle de construction/résolution d'une grille.\n//!\n//! Recherche les cases adjacentes à une étoile qui ne peuvent pas contenir une étoile.\n\nuse crate::GoodRule;\nuse crate::Grid;\nuse crate::GridAction;\nuse crate::GridHandler;\nuse crate::GridSurfer;\n\n/// Cherche si une étoile déjà placée à des cases adjacentes non définies.\n/// Si oui, ces cases peuvent être définie comme `NoStar`\npub fn rule_no_star_adjacent_to_star(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\n    for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\n        if grid.cell(line_column).is_star() {\n            let unknown_adjacent_cells: Vec\u003cGridAction\u003e = handler\n                .adjacent_cells(line_column)\n                .iter()\n                .filter(|line_column| grid.cell(**line_column).is_unknown())\n                .map(|line_column| GridAction::SetNoStar(*line_column))\n                .collect();\n            if !unknown_adjacent_cells.is_empty() {\n                return Some(GoodRule::NoStarAdjacentToStar(\n                    line_column,\n                    unknown_adjacent_cells,\n                ));\n            }\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use crate::GridParser;\n    use crate::LineColumn;\n\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\n        let grid_parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\n        let grid = Grid::from(\u0026grid_handler);\n        (grid_handler, grid)\n    }\n\n    #[test]\n    fn test_no_star_adjacent_to_star() {\n        let (grid_handler, mut grid) = get_test_grid();\n\n        // On place volontairement 1 étoile au centre de la grille\n        let center_line_column = LineColumn::new(2, 2);\n        grid.apply_action(\u0026GridAction::SetStar(center_line_column));\n\n        // Les 8 cases adjacentes ne peuvent pas contenir une étoile\n        let good_rule = rule_no_star_adjacent_to_star(\u0026grid_handler, \u0026grid);\n        match good_rule {\n            Some(GoodRule::NoStarAdjacentToStar(line_column, actions)) =\u003e {\n                assert_eq!(line_column, center_line_column);\n                assert_eq!(actions.len(), 8);\n                let adjacent_to_center_line_column =\n                    grid_handler.surfer(\u0026grid, \u0026GridSurfer::Adjacent(center_line_column));\n                for action in actions {\n                    match action {\n                        GridAction::SetNoStar(line_column) =\u003e {\n                            assert!(adjacent_to_center_line_column.contains(\u0026line_column));\n                        }\n                        _ =\u003e panic!(\"L'action n'est pas détectée\"),\n                    }\n                }\n            }\n            _ =\u003e panic!(\"La règle n'est pas détectée\"),\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":14,"address":[],"length":0,"stats":{"Line":4827858800541171713}},{"line":15,"address":[],"length":0,"stats":{"Line":1441151880758558721}},{"line":16,"address":[],"length":0,"stats":{"Line":9943947977234055466}},{"line":17,"address":[],"length":0,"stats":{"Line":9943947977234055466}},{"line":19,"address":[],"length":0,"stats":{"Line":11529215046068470385}},{"line":20,"address":[],"length":0,"stats":{"Line":12682136550675317534}},{"line":22,"address":[],"length":0,"stats":{"Line":9943947977234055466}},{"line":23,"address":[],"length":0,"stats":{"Line":936748722493063171}},{"line":24,"address":[],"length":0,"stats":{"Line":936748722493063171}},{"line":25,"address":[],"length":0,"stats":{"Line":936748722493063171}},{"line":30,"address":[],"length":0,"stats":{"Line":2449958197289549828}}],"covered":12,"coverable":12},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_region_combinations.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche des combinaisons de 'n' régions occupent 'n' lignes ou 'n' colonnes.\u003cbr\u003e\r\n//! Dans ce cas, toutes les cases dans ces 'n' lignes ou colonnes qui n'appartiennent pas aux\r\n//! régions ne peuvent pas être des étoiles.\r\n//!\r\n//! En effect, les 'n' régions sur 'n' lignes positionnent toutes les étoiles sur ces 'n' lignes\r\n//! et il ne peut donc pas y avoir d'autres étoiles sur ce 'n' lignes.\u003cbr\u003e\r\n//! Idem pour les colonnes.\r\n//!\r\n//! //! Cette règle est l'opposée de la règle [`rule_region_exclusions`]\r\n\r\n/// Crate qui recherche n combinaisons possibles dans un vecteur d'elements\r\nuse combination::combine;\r\n\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\nuse crate::LineColumn;\r\n\r\n/// Recherche les régions de 1 ligne ou 1 colonne. Les autres cases de cette ligne ou colonne\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_1_combinations(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_combinations(handler, grid, 1)\r\n}\r\n\r\n/// Recherche les couples de régions sur 2 ligne ou 2 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_2_combinations(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_combinations(handler, grid, 2)\r\n}\r\n\r\n/// Recherche les triplets de régions sur 3 ligne ou 3 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_3_combinations(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_combinations(handler, grid, 3)\r\n}\r\n\r\n/// Recherche les quadruplets de régions sur 4 ligne ou 4 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_4_combinations(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_combinations(handler, grid, 4)\r\n}\r\n\r\n/// Cherche les combinaisons de 'n' régions occupent exactement 'n' lignes ou 'n' colonnes.\u003cbr\u003e\r\n/// Si des cases appartement à d'autres régions sont dans ces lignes ou colonnes, elles ne peuvent\r\n/// pas être des étoiles\r\nfn rule_region_generic_combinations(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    n: usize,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    // On utilise le crate 'combination' pour trouver toutes les combinaisons possibles\r\n    for vec_regions in combine::from_vec_at(\u0026handler.regions(), n) {\r\n        // On cherche les cases qui sont dans la combinaison et on détermine les lignes/colonnes minimales/maximales\r\n        let all_cells = handler.surfer(grid, \u0026GridSurfer::AllCells);\r\n        let mut min_line = usize::MAX;\r\n        let mut max_line = 0;\r\n        let mut min_column = usize::MAX;\r\n        let mut max_column = 0;\r\n        for line_column in all_cells {\r\n            let cell = grid.cell(line_column);\r\n            if vec_regions.contains(\u0026cell.region) {\r\n                // Cette case de la grille est dans une des régions de la combinaison\r\n                let (line, column) = (cell.line_column.line, cell.line_column.column);\r\n                if line \u003c min_line {\r\n                    min_line = line;\r\n                }\r\n                if line \u003e max_line {\r\n                    max_line = line;\r\n                }\r\n                if column \u003c min_column {\r\n                    min_column = column;\r\n                }\r\n                if column \u003e max_column {\r\n                    max_column = column;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (max_line - min_line + 1) == n {\r\n            // Les 'n' régions occupent exactement 'n' lignes\r\n            // Existe-t-il des cases dans ces lignes qui n'appartiennent pas à ces régions et qui sont indéfinies ?\r\n            let grid_surfer = GridSurfer::Lines(min_line..=max_line);\r\n            let surfer = handler.surfer(grid, \u0026grid_surfer);\r\n            let candidates: Vec\u003cLineColumn\u003e = surfer\r\n                .iter()\r\n                .filter(|line_column| grid.cell(**line_column).is_unknown())\r\n                .filter(|line_column| !vec_regions.contains(\u0026grid.cell(**line_column).region))\r\n                .copied()\r\n                .collect();\r\n\r\n            if !candidates.is_empty() {\r\n                let mut actions = Vec::new();\r\n                for line_column in candidates {\r\n                    actions.push(GridAction::SetNoStar(line_column));\r\n                }\r\n\r\n                return Some(GoodRule::ZoneCombinations(\r\n                    vec_regions,\r\n                    grid_surfer,\r\n                    actions,\r\n                ));\r\n            }\r\n        }\r\n\r\n        if (max_column - min_column + 1) == n {\r\n            // Les 'n' regions occupent exactement 'n'\r\n            // Existe-t-il des cases dans ces colonnes qui n'appartiennent pas à ces régions et qui sont indéfinies ?\r\n            let grid_surfer = GridSurfer::Columns(min_column..=max_column);\r\n            let surfer = handler.surfer(grid, \u0026grid_surfer);\r\n            let candidates: Vec\u003cLineColumn\u003e = surfer\r\n                .iter()\r\n                .filter(|line_column| grid.cell(**line_column).is_unknown())\r\n                .filter(|line_column| !vec_regions.contains(\u0026grid.cell(**line_column).region))\r\n                .copied()\r\n                .collect();\r\n\r\n            if !candidates.is_empty() {\r\n                let mut actions = Vec::new();\r\n                for line_column in candidates {\r\n                    actions.push(GridAction::SetNoStar(line_column));\r\n                }\r\n\r\n                return Some(GoodRule::ZoneCombinations(\r\n                    vec_regions,\r\n                    grid_surfer,\r\n                    actions,\r\n                ));\r\n            }\r\n        }\r\n    }\r\n\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_region_combinations() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // Au moins la région 'A' ou 'C' déclenche cette règle\r\n        let option_good_rule = rule_region_1_combinations(\u0026grid_handler, \u0026grid);\r\n        assert!(\u0026option_good_rule.is_some());\r\n        let good_rule = option_good_rule.unwrap();\r\n        grid.apply_good_rule(\u0026good_rule);\r\n\r\n        // println!(\"Rule: {}\", \u0026good_rule);\r\n        // println!(\"Grid :\\n{}\", grid_handler.display(\u0026grid, true));\r\n        // panic!(\"stop test\")\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":26,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":31,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":32,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":37,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":38,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":50,"address":[],"length":0,"stats":{"Line":12538021362599460864}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":5908722711110090753}},{"line":59,"address":[],"length":0,"stats":{"Line":5908722711110090753}},{"line":60,"address":[],"length":0,"stats":{"Line":5908722711110090753}},{"line":61,"address":[],"length":0,"stats":{"Line":5908722711110090753}},{"line":62,"address":[],"length":0,"stats":{"Line":5908722711110090753}},{"line":63,"address":[],"length":0,"stats":{"Line":6196953087261801674}},{"line":67,"address":[],"length":0,"stats":{"Line":13402712491054594444}},{"line":68,"address":[],"length":0,"stats":{"Line":864691128455133580}},{"line":69,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":71,"address":[],"length":0,"stats":{"Line":15204152342002794496}},{"line":72,"address":[],"length":0,"stats":{"Line":15204152342002794496}},{"line":74,"address":[],"length":0,"stats":{"Line":17870283321406128128}},{"line":75,"address":[],"length":0,"stats":{"Line":17870283321406128128}},{"line":77,"address":[],"length":0,"stats":{"Line":14123288431433875456}},{"line":78,"address":[],"length":0,"stats":{"Line":14123288431433875456}},{"line":83,"address":[],"length":0,"stats":{"Line":5908722711110092500}},{"line":86,"address":[],"length":0,"stats":{"Line":6917529027641081883}},{"line":87,"address":[],"length":0,"stats":{"Line":6917529027641081883}},{"line":88,"address":[],"length":0,"stats":{"Line":6917529027641081883}},{"line":90,"address":[],"length":0,"stats":{"Line":4899916394579099702}},{"line":91,"address":[],"length":0,"stats":{"Line":12105675798371893305}},{"line":95,"address":[],"length":0,"stats":{"Line":6917529027641081883}},{"line":96,"address":[],"length":0,"stats":{"Line":1008806316530991131}},{"line":97,"address":[],"length":0,"stats":{"Line":288230376151711852}},{"line":98,"address":[],"length":0,"stats":{"Line":5908722711110090779}},{"line":101,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":102,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":103,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":104,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":109,"address":[],"length":0,"stats":{"Line":4899916394579101369}},{"line":112,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":113,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":114,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":116,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":117,"address":[],"length":0,"stats":{"Line":6701356245527298052}},{"line":121,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":122,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":123,"address":[],"length":0,"stats":{"Line":6845471433603154331}},{"line":124,"address":[],"length":0,"stats":{"Line":7854277750134145161}},{"line":127,"address":[],"length":0,"stats":{"Line":1729382256910270465}},{"line":128,"address":[],"length":0,"stats":{"Line":1729382256910270465}},{"line":129,"address":[],"length":0,"stats":{"Line":1729382256910270465}},{"line":130,"address":[],"length":0,"stats":{"Line":1729382256910270465}},{"line":136,"address":[],"length":0,"stats":{"Line":9799832789158199323}}],"covered":54,"coverable":54},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_region_exclusions.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche des combinaisons de 'n' lignes ou colonnes qui ne sont occupées que 'n' régions.\u003cbr\u003e\r\n//! Dans ce cas, toutes les autres cases dans ces 'n' régions qui ne sont pas dans les 'n' lignes ou colonnes\r\n//! ne peuvent pas être des étoiles.\r\n//!\r\n//! S'il existe déjà des étoiles dans ces 'n' lignes ou colonnes, La règle n'est pas applicable.\r\n//!\r\n//! S'il existe des cases d'autres régions qui sont déjà définies comme pouvant pas être des étoiles,\r\n//! on peut les ignorer.\r\n//!\r\n//! En effect, les 'n' lignes ou colonnes positionnent toutes les étoiles pour ces 'n' régions\r\n//! et il ne peut donc pas y avoir d'autres étoiles dans ces 'n' régions.\r\n//!\r\n//! Par exemple, pour n = 1, si une seule région occupe toute une ligne (ou colonne) alors les étoiles de\r\n//! cette région sont sur cette ligne (ou colonne) et les cases des cette région qui ne sont pas dans cette\r\n//! ligne (ou colonne) ne peuvent pas être des étoiles.\r\n//!\r\n//! Cette règle est l'opposée de la règle [`rule_region_combinations`]\r\n\r\nuse crate::CellValue;\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\nuse crate::LineColumn;\r\nuse crate::Region;\r\n\r\n/// Recherche les régions de 1 ligne ou 1 colonne. Les autres cases de cette ligne ou colonne\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_1_exclusions(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_exclusions(handler, grid, 1)\r\n}\r\n\r\n/// Recherche les couples de régions sur 2 ligne ou 2 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_2_exclusions(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_exclusions(handler, grid, 2)\r\n}\r\n\r\n/// Recherche les triplets de régions sur 3 ligne ou 3 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_3_exclusions(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_exclusions(handler, grid, 3)\r\n}\r\n\r\n/// Recherche les quadruplets de régions sur 4 ligne ou 4 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_4_exclusions(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_exclusions(handler, grid, 4)\r\n}\r\n\r\n/// Cherche les combinaisons de 'n' lignes ou colonnes qui contiennent exactement 'n' régions.\u003cbr\u003e\r\n/// S'il existe des cases appartement à ces régions dans d'autres lignes ou colonnes, elles ne peuvent\r\n/// pas être des étoiles\r\n#[allow(clippy::range_minus_one)]\r\nfn rule_region_generic_exclusions(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    n: usize,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    for line in 0..=handler.nb_lines() - n {\r\n        let grid_surfer = GridSurfer::Lines(line..=line + n - 1);\r\n        if let Some((vec_regions, candidates)) =\r\n            rule_region_more_generic_exclusions(handler, grid, n, \u0026grid_surfer)\r\n        {\r\n            let mut actions = Vec::new();\r\n            for line_column in candidates {\r\n                actions.push(GridAction::SetNoStar(line_column));\r\n            }\r\n            return Some(GoodRule::ZoneExclusions(vec_regions, grid_surfer, actions));\r\n        }\r\n    }\r\n    for column in 0..=handler.nb_columns() - n {\r\n        let grid_surfer = GridSurfer::Columns(column..=column + n - 1);\r\n        if let Some((vec_regions, candidates)) =\r\n            rule_region_more_generic_exclusions(handler, grid, n, \u0026grid_surfer)\r\n        {\r\n            let mut actions = Vec::new();\r\n            for line_column in candidates {\r\n                actions.push(GridAction::SetNoStar(line_column));\r\n            }\r\n            return Some(GoodRule::ZoneExclusions(vec_regions, grid_surfer, actions));\r\n        }\r\n    }\r\n    None\r\n}\r\n\r\n/// Spécialisation de `rule_region_generic_exclusions` pour 'n' lignes ou 'n' colonnes.\u003cbr\u003e\r\n/// Compte combien de régions différentes sont présentes dans le `grid_surfer`. Si 'n' régions alors\r\n/// recherche des cases candidates qui ne sont pas définies pour ces régions en dehors de `grid_surfer`\r\nfn rule_region_more_generic_exclusions(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    n: usize,\r\n    grid_surfer: \u0026GridSurfer,\r\n) -\u003e Option\u003c(Vec\u003cRegion\u003e, Vec\u003cLineColumn\u003e)\u003e {\r\n    let surfer = handler.surfer(grid, grid_surfer);\r\n    let mut vec_regions = Vec::new();\r\n    for line_column in \u0026surfer {\r\n        match grid.cell(*line_column).value {\r\n            // S'il existe déjà des étoiles dans les n lignes ou colonnes, on abandonne la recherche\r\n            // (la règle n'est pas applicable)\r\n            CellValue::Star =\u003e return None,\r\n            // Si la case est déjà définie comme ne pouvant pas être une étoile, on l'ignore : Quelle que soit\r\n            // sa région, la règle reste applicable\r\n            CellValue::NoStar =\u003e continue,\r\n            // Case non définie, on comptabilise sa région\r\n            CellValue::Unknown =\u003e {\r\n                let region = grid.cell(*line_column).region;\r\n                if !vec_regions.contains(\u0026region) {\r\n                    vec_regions.push(region);\r\n                    if vec_regions.len() \u003e n {\r\n                        return None;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // vec_regions contient toutes les regions qui sont dans le 'grid_surfer' et il n'y a pas plus de 'n'.\r\n    // On cherche des cases non définies de ces régions qui ne sont pas dans 'grid_surfer'\r\n    let mut candidates = Vec::new();\r\n    for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\r\n        if !surfer.contains(\u0026line_column) {\r\n            let cell = grid.cell(line_column);\r\n            if cell.is_unknown() \u0026 vec_regions.contains(\u0026cell.region) {\r\n                candidates.push(line_column);\r\n            }\r\n        }\r\n    }\r\n\r\n    if candidates.is_empty() {\r\n        None\r\n    } else {\r\n        Some((vec_regions, candidates))\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_region_exclusions() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // Au moins la 4eme ligne 'DDDDD' déclenche cette règle\r\n        let option_good_rule = rule_region_1_exclusions(\u0026grid_handler, \u0026grid);\r\n        assert!(\u0026option_good_rule.is_some());\r\n        let good_rule = option_good_rule.unwrap();\r\n        grid.apply_good_rule(\u0026good_rule);\r\n\r\n        // println!(\"Rule: {}\", \u0026good_rule);\r\n        // println!(\"Grid :\\n{}\", grid_handler.display(\u0026grid, true));\r\n        // panic!(\"stop test\")\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":6989586621679009838}},{"line":33,"address":[],"length":0,"stats":{"Line":6989586621679009838}},{"line":38,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":39,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":44,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":45,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":13907115649320091648}},{"line":63,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":64,"address":[],"length":0,"stats":{"Line":18374686479671623681}},{"line":65,"address":[],"length":0,"stats":{"Line":864691128455135246}},{"line":66,"address":[],"length":0,"stats":{"Line":18374686479671623681}},{"line":68,"address":[],"length":0,"stats":{"Line":864691128455135246}},{"line":69,"address":[],"length":0,"stats":{"Line":9943947977234055182}},{"line":70,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":72,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":75,"address":[],"length":0,"stats":{"Line":8358680908399640578}},{"line":76,"address":[],"length":0,"stats":{"Line":13763000461244235777}},{"line":77,"address":[],"length":0,"stats":{"Line":576460752303423502}},{"line":78,"address":[],"length":0,"stats":{"Line":13763000461244235777}},{"line":80,"address":[],"length":0,"stats":{"Line":576460752303423502}},{"line":81,"address":[],"length":0,"stats":{"Line":7061644215716937742}},{"line":82,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":84,"address":[],"length":0,"stats":{"Line":576460752303423502}},{"line":87,"address":[],"length":0,"stats":{"Line":12465963768561532928}},{"line":93,"address":[],"length":0,"stats":{"Line":13690942867206307840}},{"line":99,"address":[],"length":0,"stats":{"Line":13690942867206307840}},{"line":100,"address":[],"length":0,"stats":{"Line":13690942867206307840}},{"line":101,"address":[],"length":0,"stats":{"Line":11961560610296037581}},{"line":105,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":108,"address":[],"length":0,"stats":{"Line":6485183463413514269}},{"line":111,"address":[],"length":0,"stats":{"Line":16573246628723425338}},{"line":112,"address":[],"length":0,"stats":{"Line":16573246628723425338}},{"line":113,"address":[],"length":0,"stats":{"Line":13114482114902884363}},{"line":114,"address":[],"length":0,"stats":{"Line":13114482114902884363}},{"line":115,"address":[],"length":0,"stats":{"Line":15564440312192434183}},{"line":123,"address":[],"length":0,"stats":{"Line":11961560610296037407}},{"line":124,"address":[],"length":0,"stats":{"Line":5476377146882523167}},{"line":125,"address":[],"length":0,"stats":{"Line":11961560610296037376}},{"line":126,"address":[],"length":0,"stats":{"Line":3458764513820540877}},{"line":127,"address":[],"length":0,"stats":{"Line":8646911284551352276}},{"line":128,"address":[],"length":0,"stats":{"Line":5188146770730811399}},{"line":133,"address":[],"length":0,"stats":{"Line":11961560610296037376}},{"line":134,"address":[],"length":0,"stats":{"Line":10520408729537478677}},{"line":136,"address":[],"length":0,"stats":{"Line":1441151880758558720}}],"covered":46,"coverable":46},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_region_possible_stars.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche les combinaisons d'étoiles possibles dans une région.\r\n//! Plus simplement que `rule_region_star_complete`, on n'examine ici que le contenu des différentes\r\n//! combinaisons dans une région sans examiner l'impact sur l'ensemble de la grille grille.\r\n//! On intègre également dans cette recherche, toutes les cases environnant une région qui sont\r\n//! forcément pas des étoles puisque toujours à proximité d'une étoile dans la région.\r\n//! Les règles qui apparaissent ainsi sont plus compréhensible pour un humain.\r\n\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridHandler;\r\n\r\nuse super::rule_generic_possible_stars;\r\nuse super::ZoneToExamine;\r\n\r\n/// Cherche toutes les combinaisons d'étoiles possibles dans les différentes régions.\r\n/// Version simplifiée de `rule_region_recursive_possible_stars` qui se limite au contenu des\r\n/// différentes régions pour une compréhension plus aisées pour un humain\r\npub fn rule_region_possible_stars(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(handler, grid, ZoneToExamine::Region, false)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_region_stars() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        println!(\"Grille initiale :\\n{}\", grid_handler.display(\u0026grid, true));\r\n\r\n        // Cette règle s'applique sur la région 'CC' dans la 3eme ligne : Les cases adjacentes ne peuvent\r\n        // pas être une étoile...\r\n        let option_good_rule = rule_region_possible_stars(\u0026grid_handler, \u0026grid);\r\n        assert!(option_good_rule.is_some());\r\n        grid.apply_good_rule(\u0026option_good_rule.unwrap());\r\n\r\n        // Cette règle s'applique sur l'avant dernière ligne de 'DDDDD' : On doit mettre une étoile\r\n        // sur cette ligne donc les D sur la ligne suivante ne peuvent pas être une étoile...\r\n        let option_good_rule = rule_region_possible_stars(\u0026grid_handler, \u0026grid);\r\n        assert!(option_good_rule.is_some());\r\n        grid.apply_good_rule(\u0026option_good_rule.unwrap());\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":21,"address":[],"length":0,"stats":{"Line":4035225266123964416}}],"covered":2,"coverable":2},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_value_completed.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche les cases implicites compte-tenu des autres cases dans une zone :\r\n//! * Une étoile si une seule possibilité pour la zone\r\n//! * Pas d'étoile si toutes les étoiles sont déjà placées dans la zone\r\n\r\nuse crate::CellValue;\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\n\r\n/// Cherche dans les régions, les lignes et les colonnes s'il y a des contenus de cases 'évidents :\r\n/// * Pas d'étoile si toutes les étoiles sont déjà placées dans la zone\r\n/// * Une étoile si une seule possibilité pour la zone\r\npub fn rule_value_completed(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    let mut zones = Vec::new();\r\n\r\n    // Parcours de toutes les régions\r\n    for region in handler.regions() {\r\n        zones.push(GridSurfer::Region(region));\r\n    }\r\n\r\n    // Parcours de toutes les lignes\r\n    for line in 0..handler.nb_lines() {\r\n        zones.push(GridSurfer::Line(line));\r\n    }\r\n\r\n    // Parcours de toutes les colonnes\r\n    for column in 0..handler.nb_columns() {\r\n        zones.push(GridSurfer::Column(column));\r\n    }\r\n\r\n    // Examine toutes les zones prévues\r\n    for zone in zones {\r\n        if let Some(good_rule) = try_value_completed(handler, grid, \u0026zone, handler.nb_stars()) {\r\n            return Some(good_rule);\r\n        }\r\n    }\r\n    None\r\n}\r\n\r\n/// Détermine s'il y a des contenus de cases 'évidents' pour une zone\r\nfn try_value_completed(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    grid_surfer: \u0026GridSurfer,\r\n    nb_stars: usize,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    let surfer = handler.surfer(grid, grid_surfer);\r\n\r\n    // Décompte de cases inconnue/avec étoile/sans étoile dans la zone\r\n    let mut cur_nb_stars = 0;\r\n    let mut _cur_nb_no_stars = 0;\r\n    // Nombre et cases restantes à placer dans la zone\r\n    let mut cur_nb_unknown = 0;\r\n    let mut line_column_unknown = Vec::new();\r\n    // On pourrait compter les types de valeurs avec `handler.surfer_cells_with_value_count` mais\r\n    // nécessiterait de créer à chaque fois un nouveau surfer (coûteux...)\r\n    for line_column in surfer {\r\n        match grid.cell(line_column).value {\r\n            CellValue::Star =\u003e cur_nb_stars += 1,\r\n            CellValue::NoStar =\u003e _cur_nb_no_stars += 1,\r\n            CellValue::Unknown =\u003e {\r\n                cur_nb_unknown += 1;\r\n                line_column_unknown.push(line_column);\r\n            }\r\n        }\r\n    }\r\n\r\n    if cur_nb_unknown \u003e 0 {\r\n        // Il reste des cases non définies dans la zone...\r\n        if cur_nb_stars == nb_stars {\r\n            // ...et la zone possède déjà toutes les étoiles attendues\r\n            // =\u003e les cases inconnues sont forcement sans étoile\r\n            let mut actions = Vec::new();\r\n            for line_column in line_column_unknown {\r\n                actions.push(GridAction::SetNoStar(line_column));\r\n            }\r\n            return Some(GoodRule::ZoneNoStarCompleted(grid_surfer.clone(), actions));\r\n        }\r\n        if cur_nb_unknown == nb_stars - cur_nb_stars {\r\n            // ... et il reste dans la zone autant de cases indéfinies qu'il reste d'étoiles à placer\r\n            // =\u003e les cases inconnues sont forcement avec une étoile\r\n            let mut actions = Vec::new();\r\n            for line_column in line_column_unknown {\r\n                actions.push(GridAction::SetStar(line_column));\r\n            }\r\n            return Some(GoodRule::ZoneStarCompleted(grid_surfer.clone(), actions));\r\n        }\r\n    }\r\n\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n    use crate::LineColumn;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_zone_no_star_completed() {\r\n        let (grid_handler, grid) = get_test_grid();\r\n\r\n        for line in 0..grid_handler.nb_lines() {\r\n            for column in 0..grid_handler.nb_columns() {\r\n                let mut test_grid = grid.clone();\r\n\r\n                // On place volontairement 1 étoile dans la grille\r\n                test_grid.apply_action(\u0026GridAction::SetStar(LineColumn::new(line, column)));\r\n\r\n                // La règle doit détecter une région qui doit être complétée avec des cases sans étoile\r\n                let good_rule = rule_value_completed(\u0026grid_handler, \u0026test_grid);\r\n                match good_rule {\r\n                    Some(GoodRule::ZoneNoStarCompleted(_, _)) =\u003e (),\r\n                    _ =\u003e panic!(\"La règle n'est pas détectée\"),\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_zone_star_completed() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // On place volontairement 1 case sans étoile dans la zone A de 2 cases\r\n        grid.apply_action(\u0026GridAction::SetNoStar(LineColumn::new(1, 0)));\r\n\r\n        // La règle doit détecter une région qui doit être complétée avec des cases avec étoile\r\n        let good_rule = rule_value_completed(\u0026grid_handler, \u0026grid);\r\n        match good_rule {\r\n            Some(GoodRule::ZoneStarCompleted(_, _)) =\u003e (),\r\n            _ =\u003e panic!(\"La règle n'est pas détectée\"),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":18,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":21,"address":[],"length":0,"stats":{"Line":6052837899185946630}},{"line":22,"address":[],"length":0,"stats":{"Line":10088063165309911043}},{"line":26,"address":[],"length":0,"stats":{"Line":6052837899185946658}},{"line":27,"address":[],"length":0,"stats":{"Line":10088063165309911043}},{"line":31,"address":[],"length":0,"stats":{"Line":6052837899185946658}},{"line":32,"address":[],"length":0,"stats":{"Line":10088063165309911043}},{"line":36,"address":[],"length":0,"stats":{"Line":6341068275337658370}},{"line":37,"address":[],"length":0,"stats":{"Line":15852670688344145921}},{"line":38,"address":[],"length":0,"stats":{"Line":15852670688344145921}},{"line":41,"address":[],"length":0,"stats":{"Line":6917529027641081916}},{"line":45,"address":[],"length":0,"stats":{"Line":8935141660703064065}},{"line":51,"address":[],"length":0,"stats":{"Line":8935141660703064065}},{"line":54,"address":[],"length":0,"stats":{"Line":8935141660703064065}},{"line":55,"address":[],"length":0,"stats":{"Line":8935141660703064065}},{"line":57,"address":[],"length":0,"stats":{"Line":8935141660703064065}},{"line":58,"address":[],"length":0,"stats":{"Line":8935141660703064065}},{"line":61,"address":[],"length":0,"stats":{"Line":3026418949592973740}},{"line":63,"address":[],"length":0,"stats":{"Line":6557241057451442417}},{"line":64,"address":[],"length":0,"stats":{"Line":1441151880758558782}},{"line":65,"address":[],"length":0,"stats":{"Line":7493989779944505388}},{"line":66,"address":[],"length":0,"stats":{"Line":7493989779944505388}},{"line":67,"address":[],"length":0,"stats":{"Line":7493989779944505388}},{"line":72,"address":[],"length":0,"stats":{"Line":8935141660703064332}},{"line":74,"address":[],"length":0,"stats":{"Line":10232178353385766974}},{"line":77,"address":[],"length":0,"stats":{"Line":10808639105689190401}},{"line":78,"address":[],"length":0,"stats":{"Line":14987979559889010689}},{"line":79,"address":[],"length":0,"stats":{"Line":13690942867206307840}},{"line":81,"address":[],"length":0,"stats":{"Line":10808639105689190445}},{"line":83,"address":[],"length":0,"stats":{"Line":17870283321406128189}},{"line":86,"address":[],"length":0,"stats":{"Line":5044031582654955534}},{"line":87,"address":[],"length":0,"stats":{"Line":12538021362599460881}},{"line":88,"address":[],"length":0,"stats":{"Line":8646911284551352321}},{"line":90,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":94,"address":[],"length":0,"stats":{"Line":11529215046068470013}}],"covered":36,"coverable":36},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_zone_possible_stars.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche les cases invariantes pour toutes les combinaisons possibles d'une zone\r\n\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridHandler;\r\n\r\nuse super::rule_generic_possible_stars;\r\nuse super::ZoneToExamine;\r\n\r\n/// Cherche toutes les combinaisons possibles dans les différentes régions.\r\npub fn rule_region_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(handler, grid, ZoneToExamine::Region, true)\r\n}\r\n\r\n/// Cherche toutes les combinaisons possibles dans les différentes ligne ou colonne.\r\npub fn rule_line_column_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(handler, grid, ZoneToExamine::LineAndColumn, true)\r\n}\r\n\r\n/// Cherche toutes les combinaisons possibles dans les groupes de 2 lignes ou 2 colonnes\r\npub fn rule_multi_2_lines_columns_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(\r\n        handler,\r\n        grid,\r\n        ZoneToExamine::MultipleLinesAndColumns(2),\r\n        true,\r\n    )\r\n}\r\n\r\n/// Cherche toutes les combinaisons possibles dans les groupes de 3 lignes ou 3 colonnes\r\npub fn rule_multi_3_lines_columns_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(\r\n        handler,\r\n        grid,\r\n        ZoneToExamine::MultipleLinesAndColumns(3),\r\n        true,\r\n    )\r\n}\r\n\r\n/// Cherche toutes les combinaisons possibles dans les groupes de 4 lignes ou 3 colonnes\r\npub fn rule_multi_4_lines_columns_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(\r\n        handler,\r\n        grid,\r\n        ZoneToExamine::MultipleLinesAndColumns(4),\r\n        true,\r\n    )\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_complete_start_number() {\r\n        // La grille de test peut être complètement résolue avec cette seule règle sur les zones\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        println!(\"Grille initiale :\\n{}\", grid_handler.display(\u0026grid, true));\r\n\r\n        loop {\r\n            let option_good_rule = rule_line_column_recursive_possible_stars(\u0026grid_handler, \u0026grid);\r\n            if option_good_rule.is_some() {\r\n                let good_rule = option_good_rule.unwrap();\r\n                println!(\"{good_rule}\");\r\n                grid.apply_good_rule(\u0026good_rule);\r\n\r\n                println!(\"\\n{}\", grid_handler.display(\u0026grid, true));\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        assert!(grid_handler.is_done(\u0026grid));\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":4467570830351532059}},{"line":17,"address":[],"length":0,"stats":{"Line":4467570830351532059}},{"line":21,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":25,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":16},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","star_adjacent.rs"],"content":"//! Recherche des cases toujours adjacentes à une étoile dans une collection de grilles\r\n\r\nuse crate::CellValue;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\n\r\n/// Énumération de la situation pour les cases possiblement toujours adjacentes à une étoile\r\n/// dans toutes les combinaisons possibles de grilles\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\npub enum StarAdjacent {\r\n    // Case initialement inconnue\r\n    Init,\r\n\r\n    // Case vue adjacente à une une étoile dans une des grilles possibles\r\n    Always,\r\n\r\n    // Case vue avec différentes possibilités dans les grilles possibles\r\n    Variable,\r\n}\r\n\r\nimpl StarAdjacent {\r\n    /// Examine un ensemble des grilles possibles collectées à partir d'une grille initiale à la recherche\r\n    /// de cases toujours adjacentes à une étoile pour toutes les possibilités de grilles\r\n    pub fn check_for_star_adjacents(\r\n        handler: \u0026GridHandler,\r\n        grid: \u0026Grid,\r\n        possible_grids: \u0026Vec\u003cGrid\u003e,\r\n    ) -\u003e Vec\u003cGridAction\u003e {\r\n        // Liste des cases non déterminées dans la grille initiale\r\n        let mut cells = Vec::new();\r\n        // Liste des 'Variant' de ces cases\r\n        let mut star_adjacents = Vec::new();\r\n        for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\r\n            if grid.cell(line_column).is_unknown() {\r\n                cells.push(line_column);\r\n                star_adjacents.push(Self::Init);\r\n            }\r\n        }\r\n\r\n        // Parcours de toutes les grilles possibles collectées\r\n        for grid in possible_grids {\r\n            // On combine toutes les cases à examiner avec ce qu'on a déjà observé\r\n            for (line_column, variant) in cells.iter().zip(star_adjacents.iter_mut()) {\r\n                // Seules les cases avec une situation différente de `CellValue::Star` peuvent prétendre\r\n                // à être toujours adjacentes à une étoile\r\n                if grid.cell(*line_column).value == CellValue::Star {\r\n                    *variant = Self::Variable;\r\n                } else {\r\n                    // Et qu'elles n'ont pas été déjà identifiées comme StarAdjacent::Variable\r\n                    if *variant != Self::Variable {\r\n                        // Liste des cases adjacentes\r\n                        let adjacents = handler.adjacent_cells(*line_column);\r\n                        if adjacents\r\n                            .iter()\r\n                            .any(|line_column| grid.cell(*line_column).value == CellValue::Star)\r\n                        {\r\n                            *variant = Self::Always;\r\n                        } else {\r\n                            *variant = Self::Variable;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Liste des cases toujours adjacentes à une étoile dans toutes les grilles examinées\r\n        let mut adjacent_star_actions = Vec::new();\r\n        for (line_column, star_adjacent) in cells.iter().zip(star_adjacents.iter()) {\r\n            if star_adjacent == \u0026Self::Always {\r\n                /* Cette case est toujours adjacent à une étoile dans toutes les grilles possibles */\r\n                adjacent_star_actions.push(GridAction::SetNoStar(*line_column));\r\n            }\r\n        }\r\n\r\n        adjacent_star_actions\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":13690942867206308333}},{"line":32,"address":[],"length":0,"stats":{"Line":13690942867206308333}},{"line":34,"address":[],"length":0,"stats":{"Line":13690942867206308333}},{"line":35,"address":[],"length":0,"stats":{"Line":10088063165309911547}},{"line":36,"address":[],"length":0,"stats":{"Line":2089670227099911336}},{"line":37,"address":[],"length":0,"stats":{"Line":5692549928996308122}},{"line":38,"address":[],"length":0,"stats":{"Line":5692549928996308122}},{"line":43,"address":[],"length":0,"stats":{"Line":6773413839565227306}},{"line":45,"address":[],"length":0,"stats":{"Line":12898309332789100558}},{"line":48,"address":[],"length":0,"stats":{"Line":1297036692682711572}},{"line":49,"address":[],"length":0,"stats":{"Line":6845471433603162630}},{"line":52,"address":[],"length":0,"stats":{"Line":6052837899185937928}},{"line":54,"address":[],"length":0,"stats":{"Line":12826251738751172903}},{"line":55,"address":[],"length":0,"stats":{"Line":12826251738751172903}},{"line":57,"address":[],"length":0,"stats":{"Line":7133701809754866554}},{"line":59,"address":[],"length":0,"stats":{"Line":14483576401623516016}},{"line":61,"address":[],"length":0,"stats":{"Line":16789419410837208503}},{"line":69,"address":[],"length":0,"stats":{"Line":13690942867206307986}},{"line":70,"address":[],"length":0,"stats":{"Line":936748722493063328}},{"line":71,"address":[],"length":0,"stats":{"Line":1441151880758559454}},{"line":72,"address":[],"length":0,"stats":{"Line":14195346025471804112}},{"line":73,"address":[],"length":0,"stats":{"Line":14195346025471804112}},{"line":77,"address":[],"length":0,"stats":{"Line":13690942867206308113}}],"covered":23,"coverable":23},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_handler.rs"],"content":"//! Structure d'une grille en cours de résolution.\n\nuse crate::check_bad_rules;\nuse crate::CellValue;\nuse crate::Grid;\nuse crate::GridParser;\nuse crate::LineColumn;\nuse crate::Region;\nuse crate::{display_column, display_line};\n\n/// Description d'une grille en cours de résolution\n#[derive(Debug)]\npub struct GridHandler {\n    /// Taille de la grille\n    size: LineColumn,\n\n    /// Nombre d'étoiles à placer dans chaque ligne, colonne ou région dans la grille\n    nb_stars: usize,\n\n    /// Liste des régions de la grille\n    regions: Vec\u003cRegion\u003e,\n\n    /// Liste des lignes avec la région correspondant à chaque case de la ligne\n    cells_region: Vec\u003cVec\u003cRegion\u003e\u003e,\n}\n\nimpl GridHandler {\n    /// Constructeur selon un grid parser et le nombre d'étoiles à placer dans la grille\n    /// # Panics\n    /// Panic si la taille de la grille est \u003c= 0 ou qu'il y a trop d'étoiles à placer selon la taille de la grille\n    #[must_use]\n    pub fn new(parser: \u0026GridParser, nb_stars: usize) -\u003e Self {\n        let nb_lines = parser.nb_lines();\n        let nb_columns = parser.nb_columns();\n        assert!(nb_lines \u003e 0, \"nb_lines doit être \u003e 0\");\n        assert!(nb_columns \u003e 0, \"nb_columns doit être \u003e 0\");\n        assert!(nb_stars \u003e 0, \"nb_stars doit être \u003e 0\");\n\n        // Liste des regions de la grille\n        let mut regions: Vec\u003cchar\u003e = parser.regions();\n        // Tri par taille de la region (en nombre de cases)\n        regions.sort_by(|a, b| {\n            parser\n                .region_cells(*a)\n                .len()\n                .cmp(\u0026parser.region_cells(*b).len())\n        });\n\n        // Pour mettre nb_stars sans qu'elles se touchent, il faut au moins ((2 * nb_stars) - 1) cases...\n        let min_nb_cells = (2 * nb_stars) - 1;\n        assert!(\n            nb_lines \u003e= min_nb_cells,\n            \"Trop d'étoiles à placer ({nb_stars}) pour une grille de {nb_lines} lignes\"\n        );\n        assert!(\n            nb_columns \u003e= min_nb_cells,\n            \"Trop d'étoiles à placer ({nb_stars}) pour une grille de {nb_columns} colonnes\"\n        );\n        for region in parser.regions() {\n            let nb_cells = parser.region_cells(region).len();\n            assert!(nb_cells \u003e= min_nb_cells,\n                \"Trop d'étoiles à placer ({nb_stars}) pour la region '{region}' de {nb_cells} cases dans la grille\");\n        }\n\n        // Reconstruction de la région de chaque case\n        let mut cells_region = Vec::with_capacity(nb_lines);\n        for line in 0..nb_lines {\n            let mut vec_line_regions = Vec::with_capacity(nb_columns);\n            for column in 0..nb_columns {\n                vec_line_regions.push(parser.cell(LineColumn::new(line, column)).unwrap().region);\n            }\n            cells_region.push(vec_line_regions);\n        }\n\n        Self {\n            size: LineColumn::new(nb_lines, nb_columns),\n            regions,\n            cells_region,\n            nb_stars,\n        }\n    }\n\n    /// Nombre de lignes de la grille\n    #[must_use]\n    pub const fn nb_lines(\u0026self) -\u003e usize {\n        self.size.line\n    }\n\n    /// Nombre de colonnes de la grille\n    #[must_use]\n    pub const fn nb_columns(\u0026self) -\u003e usize {\n        self.size.column\n    }\n\n    /// Nombre d'étoiles à placer dans la grille\n    #[must_use]\n    pub const fn nb_stars(\u0026self) -\u003e usize {\n        self.nb_stars\n    }\n\n    /// Liste des régions de la grille\n    #[must_use]\n    pub fn regions(\u0026self) -\u003e Vec\u003cRegion\u003e {\n        self.regions.clone()\n    }\n\n    /// Région d'une case de la grille\n    #[must_use]\n    pub fn cell_region(\u0026self, line_column: LineColumn) -\u003e Region {\n        self.cells_region[line_column.line][line_column.column]\n    }\n\n    /// Nombre de cases dans une région\n    #[must_use]\n    pub fn region_cells_count(\u0026self, region: Region) -\u003e usize {\n        let mut nb = 0;\n        for line in 0..self.nb_lines() {\n            for column in 0..self.nb_columns() {\n                if self.cell_region(LineColumn::new(line, column)) == region {\n                    nb += 1;\n                }\n            }\n        }\n        nb\n    }\n\n    /// Liste des cases adjacentes d'une case de la grille (y compris en diagonale)\n    #[must_use]\n    pub fn adjacent_cells(\u0026self, line_column: LineColumn) -\u003e Vec\u003cLineColumn\u003e {\n        let (line, column) = (line_column.line, line_column.column);\n        let mut adjacent_cells = vec![];\n        // North\n        if line \u003e 0 {\n            adjacent_cells.push(LineColumn::new(line - 1, column));\n            // North-West\n            if column \u003e 0 {\n                adjacent_cells.push(LineColumn::new(line - 1, column - 1));\n            }\n            // North-East\n            if column \u003c (self.nb_columns() - 1) {\n                adjacent_cells.push(LineColumn::new(line - 1, column + 1));\n            }\n        }\n        // West\n        if column \u003e 0 {\n            adjacent_cells.push(LineColumn::new(line, column - 1));\n            // South-West\n            if line \u003c (self.nb_lines() - 1) {\n                adjacent_cells.push(LineColumn::new(line + 1, column - 1));\n            }\n        }\n        // East\n        if line \u003c (self.nb_lines() - 1) {\n            adjacent_cells.push(LineColumn::new(line + 1, column));\n            // South-East\n            if column \u003c (self.nb_columns() - 1) {\n                adjacent_cells.push(LineColumn::new(line + 1, column + 1));\n            }\n        }\n        // South\n        if column \u003c (self.nb_columns() - 1) {\n            adjacent_cells.push(LineColumn::new(line, column + 1));\n        }\n        adjacent_cells\n    }\n\n    /// Retourne `true`si une des cases adjacentes de la case `line_column` est une étoile\n    #[must_use]\n    pub fn is_star_adjacent(\u0026self, grid: \u0026Grid, line_column: LineColumn) -\u003e bool {\n        for line_column in self.adjacent_cells(line_column) {\n            if grid.cell(line_column).is_star() {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Retourne true si toutes les cases de la grille sont définies et que la grille est 'viable'\n    #[must_use]\n    pub fn is_done(\u0026self, grid: \u0026Grid) -\u003e bool {\n        for line in 0..self.nb_lines() {\n            for column in 0..self.nb_columns() {\n                if grid.cell(LineColumn::new(line, column)).value == CellValue::Unknown {\n                    return false;\n                }\n            }\n        }\n        check_bad_rules(self, grid).is_ok()\n    }\n\n    /// Affichage du contenu d'une grille.\u003cbr\u003e\n    /// Si `with_coordinates` est `true`, affiche les coordonnées\n    /// horizontales ('A\", 'B', ...) et verticales (1, 2, ...)\n    #[must_use]\n    pub fn display(\u0026self, grid: \u0026Grid, with_coordinates: bool) -\u003e String {\n        let mut output = String::new();\n        if with_coordinates {\n            // On indique les lettre 'A', 'B', ... en entête pour les coordonnées horizontales\n            output.push_str(\"   \"); /* Espace pour les coordonnées verticales à gauche */\n            for column in 0..self.nb_columns() {\n                output.push_str(\u0026format!(\" {:\u003c2}\", display_column(column)));\n            }\n            output.push('\\n');\n            // Suivi d'une ligne de séparation\n            output.push_str(\"   \");\n            for _ in 0..self.nb_columns() {\n                output.push_str(\"---\");\n            }\n            output.push('\\n');\n        }\n        for line in 0..self.nb_lines() {\n            if with_coordinates {\n                // On indique les chiffres 1, 2, ... en entête pour les coordonnées verticales\n                output.push_str(\u0026format!(\"{:\u003e2}|\", display_line(line)));\n            }\n            for column in 0..self.nb_columns() {\n                let line_column = LineColumn::new(line, column);\n                let region = self.cell_region(line_column);\n                match grid.cell(line_column).value {\n                    CellValue::Star =\u003e output.push_str(\u0026format!(\" {region}*\")),\n                    CellValue::Unknown =\u003e output.push_str(\u0026format!(\" {region}?\")),\n                    CellValue::NoStar =\u003e output.push_str(\u0026format!(\" {region}-\")),\n                }\n            }\n            output.push('\\n');\n        }\n        output\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::collections::HashSet;\n\n    #[test]\n    #[allow(clippy::cognitive_complexity)]\n    fn test_ok() {\n        let parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n\n        assert_eq!(handler.nb_lines(), 5);\n        assert_eq!(handler.nb_columns(), 5);\n        assert_eq!(handler.nb_stars(), 1);\n        for region in ['A', 'B', 'C', 'D', 'E'] {\n            assert!(handler.regions().contains(\u0026region));\n        }\n\n        // Région A\n        assert_eq!(handler.cell_region(LineColumn::new(0, 0)), 'A');\n        assert_eq!(handler.cell_region(LineColumn::new(1, 0)), 'A');\n\n        // Région B\n        assert_eq!(handler.cell_region(LineColumn::new(0, 1)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(0, 2)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(0, 3)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(0, 4)), 'B');\n\n        assert_eq!(handler.cell_region(LineColumn::new(1, 1)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(1, 2)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(1, 3)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(1, 4)), 'B');\n\n        assert_eq!(handler.cell_region(LineColumn::new(2, 2)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(2, 3)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(2, 4)), 'B');\n\n        // Région C\n        assert_eq!(handler.cell_region(LineColumn::new(2, 0)), 'C');\n        assert_eq!(handler.cell_region(LineColumn::new(2, 1)), 'C');\n\n        // Région D\n        assert_eq!(handler.cell_region(LineColumn::new(3, 0)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(3, 1)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(3, 2)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(3, 3)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(3, 4)), 'D');\n\n        assert_eq!(handler.cell_region(LineColumn::new(4, 0)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(4, 4)), 'D');\n\n        // Région E\n        assert_eq!(handler.cell_region(LineColumn::new(4, 1)), 'E');\n        assert_eq!(handler.cell_region(LineColumn::new(4, 2)), 'E');\n        assert_eq!(handler.cell_region(LineColumn::new(4, 3)), 'E');\n    }\n\n    #[test]\n    #[rustfmt::skip]\n    fn test_adjacent() {\n        fn assert_adjacents(handler: \u0026GridHandler, (line, column):(usize, usize), expected: Vec\u003c(usize, usize)\u003e, ) {\n            let adjacent_cells:HashSet\u003cLineColumn\u003e = handler.adjacent_cells(LineColumn::new(line, column)).into_iter().collect();\n            let expected_cells:HashSet\u003cLineColumn\u003e = expected.into_iter().map(|(line, column)| LineColumn::new(line, column)).collect();\n            assert_eq!(adjacent_cells, expected_cells);\n        }\n\n        //  A A A\n        //  B B B\n        //  C C C\n        let parser =\n            GridParser::try_from(vec![\"AAA\", \"BBB\", \"CCC\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n\n        assert_adjacents(\u0026handler, (0, 0), vec![(0, 1), (1, 0), (1, 1)]);\n        assert_adjacents(\u0026handler, (0, 1), vec![(0, 0), (0, 2), (1, 0), (1, 1), (1, 2)]);\n        assert_adjacents(\u0026handler, (0, 2), vec![(0, 1), (1, 1), (1, 2)]);\n        assert_adjacents(\u0026handler, (1, 0), vec![(0, 0), (0, 1), (1, 1), (2, 0), (2, 1)]);\n        assert_adjacents(\u0026handler, (1, 1), vec![(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]);\n        assert_adjacents(\u0026handler, (1, 2), vec![(0, 1), (0, 2), (1, 1), (2, 1), (2, 2)]);\n        assert_adjacents(\u0026handler, (2, 0), vec![(1, 0), (1, 1), (2, 1),]);\n        assert_adjacents(\u0026handler, (2, 1), vec![(1, 0), (1, 1), (1, 2), (2, 0), (2, 2)]);\n        assert_adjacents(\u0026handler, (2, 2), vec![(1, 1), (1, 2), (2, 1)]);\n    }\n\n    #[test]\n    fn test_is_star_adjacent() {\n        let parser = GridParser::try_from(vec![\"AAA\", \"BBB\", \"CCC\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n        let mut grid = Grid::from(\u0026handler);\n\n        let line_column = LineColumn::new(0, 0);\n        assert!(!handler.is_star_adjacent(\u0026grid, line_column));\n\n        let adjacent_line_column = LineColumn::new(1, 1);\n        grid.cell_mut(adjacent_line_column).value = crate::CellValue::Star;\n        assert!(handler.is_star_adjacent(\u0026grid, line_column));\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":33,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":34,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":35,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":36,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":37,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":40,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":42,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":43,"address":[],"length":0,"stats":{"Line":17582052945254416384}},{"line":44,"address":[],"length":0,"stats":{"Line":17582052945254416384}},{"line":45,"address":[],"length":0,"stats":{"Line":17582052945254416384}},{"line":46,"address":[],"length":0,"stats":{"Line":17582052945254416384}},{"line":50,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":51,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":52,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":56,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":17726168133330272256}},{"line":60,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":61,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":67,"address":[],"length":0,"stats":{"Line":17726168133330272256}},{"line":68,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":69,"address":[],"length":0,"stats":{"Line":14195346025471803392}},{"line":70,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":72,"address":[],"length":0,"stats":{"Line":13186539708940812300}},{"line":76,"address":[],"length":0,"stats":{"Line":4539628424389459969}},{"line":85,"address":[],"length":0,"stats":{"Line":12321848580485677057}},{"line":86,"address":[],"length":0,"stats":{"Line":12321848580485677057}},{"line":91,"address":[],"length":0,"stats":{"Line":11961560610296047291}},{"line":92,"address":[],"length":0,"stats":{"Line":11961560610296047291}},{"line":97,"address":[],"length":0,"stats":{"Line":6052837899186003421}},{"line":98,"address":[],"length":0,"stats":{"Line":6052837899186003421}},{"line":103,"address":[],"length":0,"stats":{"Line":11529215046068480096}},{"line":104,"address":[],"length":0,"stats":{"Line":11529215046068480096}},{"line":109,"address":[],"length":0,"stats":{"Line":16573246628723425492}},{"line":110,"address":[],"length":0,"stats":{"Line":16573246628723425492}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":3674937295934324759}},{"line":130,"address":[],"length":0,"stats":{"Line":3674937295934324759}},{"line":131,"address":[],"length":0,"stats":{"Line":3674937295934324759}},{"line":133,"address":[],"length":0,"stats":{"Line":3674937295934324759}},{"line":134,"address":[],"length":0,"stats":{"Line":3386706919782615168}},{"line":136,"address":[],"length":0,"stats":{"Line":8430738502437572576}},{"line":137,"address":[],"length":0,"stats":{"Line":5044031582654957408}},{"line":140,"address":[],"length":0,"stats":{"Line":18014398509481987809}},{"line":141,"address":[],"length":0,"stats":{"Line":14627691589699372641}},{"line":145,"address":[],"length":0,"stats":{"Line":3674937295934325868}},{"line":146,"address":[],"length":0,"stats":{"Line":12105675798371893483}},{"line":148,"address":[],"length":0,"stats":{"Line":2305843009213696088}},{"line":149,"address":[],"length":0,"stats":{"Line":8646911284551354221}},{"line":154,"address":[],"length":0,"stats":{"Line":10160120759347840667}},{"line":156,"address":[],"length":0,"stats":{"Line":1513209474796490258}},{"line":157,"address":[],"length":0,"stats":{"Line":9799832789158201207}},{"line":161,"address":[],"length":0,"stats":{"Line":648518346341353051}},{"line":162,"address":[],"length":0,"stats":{"Line":648518346341353051}},{"line":169,"address":[],"length":0,"stats":{"Line":144115188075857734}},{"line":170,"address":[],"length":0,"stats":{"Line":504403158265497414}},{"line":171,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":172,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":180,"address":[],"length":0,"stats":{"Line":8142508126285856768}},{"line":181,"address":[],"length":0,"stats":{"Line":2810246167479189508}},{"line":182,"address":[],"length":0,"stats":{"Line":4251398048237748232}},{"line":183,"address":[],"length":0,"stats":{"Line":9583660007044415492}},{"line":184,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":188,"address":[],"length":0,"stats":{"Line":4827858800541171721}},{"line":195,"address":[],"length":0,"stats":{"Line":2882303761517117502}},{"line":196,"address":[],"length":0,"stats":{"Line":2882303761517117502}},{"line":197,"address":[],"length":0,"stats":{"Line":2882303761517117502}},{"line":199,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":200,"address":[],"length":0,"stats":{"Line":13258597302978740224}},{"line":201,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":203,"address":[],"length":0,"stats":{"Line":2882303761517117441}},{"line":205,"address":[],"length":0,"stats":{"Line":2882303761517117441}},{"line":206,"address":[],"length":0,"stats":{"Line":8070450532247928833}},{"line":207,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":209,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":211,"address":[],"length":0,"stats":{"Line":8070450532247928894}},{"line":212,"address":[],"length":0,"stats":{"Line":10376293541461622785}},{"line":214,"address":[],"length":0,"stats":{"Line":5188146770730811393}},{"line":216,"address":[],"length":0,"stats":{"Line":3458764513820540929}},{"line":217,"address":[],"length":0,"stats":{"Line":16717361816799281153}},{"line":218,"address":[],"length":0,"stats":{"Line":16717361816799281153}},{"line":219,"address":[],"length":0,"stats":{"Line":16717361816799281153}},{"line":220,"address":[],"length":0,"stats":{"Line":6052837899185946634}},{"line":221,"address":[],"length":0,"stats":{"Line":6557241057451442165}},{"line":222,"address":[],"length":0,"stats":{"Line":4107282860161892354}},{"line":225,"address":[],"length":0,"stats":{"Line":5188146770730811393}},{"line":227,"address":[],"length":0,"stats":{"Line":2882303761517117441}}],"covered":90,"coverable":99},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_parser.rs"],"content":"//! Parser des lignes 'textuelles' de définition d'une grille.\r\n//!\r\n//! Un fichier au format 'texte' est utilisé pour définir la grille initiale.\r\n//!\r\n//! Dans ce fichier, chaque ligne de texte correspond à une ligne de la grille. Les différentes régions sont identifiées par une 'lettre' distincte dans la case correspondante.\r\n//!\r\n//! Les lignes 'vides' ou qui commencent par l'un des caractères suivants sont ignorées : '*', '#', '/' (considérées comme d'éventuels commentaires dans le fichier).\r\n//!\r\n//! Chaque ligne 'utile' de ce fichier doit définir le même nombre de cases. Elles doivent donc toutes avoir la même longueur.\r\n//!\r\n//! Par exemple :\r\n//!\r\n//! ```text\r\n//! # Exemple de grille 1★\r\n//! ABBBB\r\n//! ABBBB\r\n//! CCBBB\r\n//! DDDDD\r\n//! DEEED\r\n//! ```\r\n\r\nuse std::collections::HashSet;\r\n\r\nuse crate::CellValue;\r\nuse crate::GridCell;\r\nuse crate::GridParserChecker;\r\nuse crate::LineColumn;\r\nuse crate::Region;\r\n\r\n/// Caractères de commentaire au début d'une ligne du fichier pour une grille à résoudre\r\npub const COMMENT_CHARS: [char; 3] = ['#', ';', '@'];\r\n\r\n/// Caractères non admissibles comme symboles d'une région\r\nconst ILLEGAL_REGION_CHARS: [char; 4] = [' ', '\\t', '\\n', '\\r'];\r\n\r\n/// Ligne de la grille\r\n#[derive(Clone, Debug, Default)]\r\nstruct ParsedLine(Vec\u003cGridCell\u003e);\r\n\r\n/// Grille\r\n#[derive(Clone, Debug, Default)]\r\nstruct ParsedGrid(Vec\u003cParsedLine\u003e);\r\n\r\n/// Grid parser\r\n#[derive(Clone, Debug, Default)]\r\npub struct GridParser {\r\n    /// Symboles identifiés comme 'région' dans la grille\r\n    regions: HashSet\u003cRegion\u003e,\r\n\r\n    /// Grille parsée\r\n    parsed_grid: ParsedGrid,\r\n}\r\n\r\nimpl TryFrom\u003c\u0026Vec\u003cString\u003e\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: \u0026Vec\u003cString\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        let mut grid_parsed = Self::default();\r\n        // Parsing des lignes de la définition de la grille\r\n        for (num_line, text_line) in value.iter().enumerate() {\r\n            let text_line = text_line.trim();\r\n            if !text_line.is_empty() \u0026\u0026 !text_line.starts_with(COMMENT_CHARS) {\r\n                if let Err(e) = grid_parsed.parse_text_line(text_line) {\r\n                    return Err(format!(\r\n                        \"Erreur à la ligne #{} '{}': {}\",\r\n                        num_line + 1,\r\n                        text_line,\r\n                        e\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Des régions identifiées ?\r\n        if grid_parsed.regions.is_empty() || grid_parsed.parsed_grid.0.is_empty() {\r\n            return Err(\"La grille n'a aucune région définie\".to_string());\r\n        }\r\n\r\n        // Contrôle de la grille parsée\r\n        let checker = GridParserChecker::new(grid_parsed.clone());\r\n        checker.check()?;\r\n\r\n        Ok(grid_parsed)\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003cVec\u003cString\u003e\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: Vec\u003cString\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        Self::try_from(\u0026value)\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003c\u0026[String]\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: \u0026[String]) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        Self::try_from(value.to_vec())\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003c\u0026str\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        let lines: Vec\u003cString\u003e = value.split('\\n').map(|s: \u0026str| s.to_string()).collect();\r\n        Self::try_from(\u0026lines)\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003cVec\u003c\u0026str\u003e\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: Vec\u003c\u0026str\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        let lines: Vec\u003cString\u003e = value.iter().map(|\u0026s: \u0026\u0026str| s.to_string()).collect();\r\n        Self::try_from(lines)\r\n    }\r\n}\r\n\r\nimpl GridParser {\r\n    /// Nombre de lignes dans la grille parsée\r\n    #[must_use]\r\n    pub fn nb_lines(\u0026self) -\u003e usize {\r\n        self.parsed_grid.0.len()\r\n    }\r\n\r\n    /// Nombre de colonnes dans la grille parsée\r\n    #[must_use]\r\n    pub fn nb_columns(\u0026self) -\u003e usize {\r\n        self.parsed_grid.0[0].0.len()\r\n    }\r\n\r\n    /// Liste des régions de la grille parsée\r\n    #[must_use]\r\n    pub fn regions(\u0026self) -\u003e Vec\u003cRegion\u003e {\r\n        self.regions.iter().copied().collect()\r\n    }\r\n\r\n    /// Retourne la case de la grille en (line, column) (si existe)\r\n    #[must_use]\r\n    pub fn cell(\u0026self, line_column: LineColumn) -\u003e Option\u003cGridCell\u003e {\r\n        if line_column.line \u003c self.nb_lines() \u0026\u0026 line_column.column \u003c self.nb_columns() {\r\n            Some(self.parsed_grid.0[line_column.line].0[line_column.column].clone())\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// région de la case (line, column)\r\n    #[must_use]\r\n    pub fn cell_region(\u0026self, line_column: LineColumn) -\u003e Region {\r\n        self.parsed_grid.0[line_column.line].0[line_column.column].region\r\n    }\r\n\r\n    /// Liste des cases d'une grille parsée\r\n    #[must_use]\r\n    pub fn list_cells(\u0026self) -\u003e Vec\u003cGridCell\u003e {\r\n        let mut cells = vec![];\r\n        for line_parsed in \u0026self.parsed_grid.0 {\r\n            for cell in \u0026line_parsed.0 {\r\n                cells.push(cell.clone());\r\n            }\r\n        }\r\n        cells\r\n    }\r\n\r\n    /// Liste des cases d'une région d'une grille parsée\r\n    #[must_use]\r\n    pub fn region_cells(\u0026self, region: Region) -\u003e Vec\u003cGridCell\u003e {\r\n        self.list_cells()\r\n            .iter()\r\n            .filter(|c| c.region == region)\r\n            .cloned()\r\n            .collect()\r\n    }\r\n\r\n    /// Analyse une ligne textuelle de définition d'une ligne la grille.\r\n    /// Ici, la ligne textuelle n'est pas vide et n'est pas un commentaire.\r\n    fn parse_text_line(\u0026mut self, text_line: \u0026str) -\u003e Result\u003c(), String\u003e {\r\n        let mut line_parsed = ParsedLine::default();\r\n        let line = self.parsed_grid.0.len();\r\n\r\n        // Parsing de la ligne\r\n        for (column, region) in text_line.chars().enumerate() {\r\n            if ILLEGAL_REGION_CHARS.contains(\u0026region) {\r\n                return Err(format!(\r\n                    \"Le caractère '{region}' n'est pas valide pour identifier une région\"\r\n                ));\r\n            }\r\n            self.regions.insert(region);\r\n            let cur_cell = GridCell {\r\n                line_column: LineColumn::from((line, column)),\r\n                region,\r\n                value: CellValue::Unknown,\r\n            };\r\n            line_parsed.0.push(cur_cell);\r\n        }\r\n\r\n        // Nombre de colonnes correct ?\r\n        if !self.parsed_grid.0.is_empty() \u0026\u0026 self.parsed_grid.0[0].0.len() != line_parsed.0.len() {\r\n            return Err(\"La ligne de la grille n'est pas la même longueur\".to_string());\r\n        }\r\n\r\n        // Ajout de la ligne à la grille\r\n        self.parsed_grid.0.push(line_parsed);\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    #[allow(clippy::cognitive_complexity)]\r\n    fn test_try_from_ok() {\r\n        let result_grid = GridParser::try_from(\r\n            \"\r\n            # Exemple de grille 1★\r\n            ABBBB\r\n            ABBBB\r\n            CCBBB\r\n            DDDDD\r\n            DEEED\r\n        \",\r\n        );\r\n        assert!(result_grid.is_ok());\r\n\r\n        let grid = result_grid.unwrap();\r\n        assert_eq!(grid.nb_lines(), 5);\r\n        assert_eq!(grid.nb_columns(), 5);\r\n\r\n        // Région A\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 0)), 'A');\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 0)), 'A');\r\n\r\n        // Région B\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 1)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 2)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 3)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 4)), 'B');\r\n\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 1)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 2)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 3)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 4)), 'B');\r\n\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 2)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 3)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 4)), 'B');\r\n\r\n        // Région C\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 0)), 'C');\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 1)), 'C');\r\n\r\n        // Région D\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 0)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 1)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 2)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 3)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 4)), 'D');\r\n\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 0)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 4)), 'D');\r\n\r\n        // Région E\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 1)), 'E');\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 2)), 'E');\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 3)), 'E');\r\n    }\r\n\r\n    // Toutes les grilles suivantes sont invalides\r\n    const INVALID_GRIDS: [\u0026str; 4] = [\r\n        \"\r\n            # Grille invalide: Vide de toute définition\r\n            # Manque des définitions de symboles\r\n        \",\r\n        \"\r\n            # Grille invalide: Symboles non admissibles\r\n            A\\tA\r\n            BBB\r\n        \",\r\n        \"\r\n            # Grille invalide: Nombre inconsistant de colonnes\r\n            AAA\r\n            BB\r\n        \",\r\n        \"\r\n            # Grille invalide: Zone inconsistante\r\n            AAA\r\n            BBA\r\n            AAB\r\n        \",\r\n    ];\r\n\r\n    #[test]\r\n    fn test_try_from_nok() {\r\n        for s in INVALID_GRIDS {\r\n            let grid = GridParser::try_from(s);\r\n            assert!(grid.is_err());\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":4899916394579099678}},{"line":58,"address":[],"length":0,"stats":{"Line":4899916394579099678}},{"line":60,"address":[],"length":0,"stats":{"Line":7061644215716937758}},{"line":61,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":62,"address":[],"length":0,"stats":{"Line":2882303761517117438}},{"line":63,"address":[],"length":0,"stats":{"Line":14123288431433875454}},{"line":64,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":75,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":81,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":83,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":90,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":91,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":107,"address":[],"length":0,"stats":{"Line":15636497906230362112}},{"line":108,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":115,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":116,"address":[],"length":0,"stats":{"Line":14339461213547659265}},{"line":117,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":124,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":125,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":130,"address":[],"length":0,"stats":{"Line":360287970189639751}},{"line":131,"address":[],"length":0,"stats":{"Line":360287970189639751}},{"line":136,"address":[],"length":0,"stats":{"Line":13763000461244235847}},{"line":137,"address":[],"length":0,"stats":{"Line":13763000461244235847}},{"line":142,"address":[],"length":0,"stats":{"Line":11601272640106397696}},{"line":143,"address":[],"length":0,"stats":{"Line":4755801206503243834}},{"line":144,"address":[],"length":0,"stats":{"Line":11601272640106397696}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":1801439850948198458}},{"line":153,"address":[],"length":0,"stats":{"Line":1801439850948198458}},{"line":158,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":159,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":160,"address":[],"length":0,"stats":{"Line":11529215046068469693}},{"line":161,"address":[],"length":0,"stats":{"Line":2738188573441261523}},{"line":162,"address":[],"length":0,"stats":{"Line":12393906174523605003}},{"line":165,"address":[],"length":0,"stats":{"Line":6629298651489370201}},{"line":170,"address":[],"length":0,"stats":{"Line":6629298651489370863}},{"line":171,"address":[],"length":0,"stats":{"Line":6629298651489370863}},{"line":173,"address":[],"length":0,"stats":{"Line":7205759403792795102}},{"line":180,"address":[],"length":0,"stats":{"Line":13979173243358019595}},{"line":181,"address":[],"length":0,"stats":{"Line":13979173243358019595}},{"line":182,"address":[],"length":0,"stats":{"Line":13979173243358019595}},{"line":185,"address":[],"length":0,"stats":{"Line":17437937757178560523}},{"line":186,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":187,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":188,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":191,"address":[],"length":0,"stats":{"Line":3386706919782612991}},{"line":193,"address":[],"length":0,"stats":{"Line":3386706919782612991}},{"line":197,"address":[],"length":0,"stats":{"Line":3386706919782612991}},{"line":201,"address":[],"length":0,"stats":{"Line":4611686018427387905}},{"line":202,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":206,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":207,"address":[],"length":0,"stats":{"Line":13835058055282163713}}],"covered":58,"coverable":61},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_parser_checker.rs"],"content":"//! Vérifie la validité d'une grille parsée\n\nuse super::LineColumn;\nuse super::Region;\nuse super::{GridCell, GridParser};\n\npub struct GridParserChecker {\n    /// Grille parsée\n    parser: GridParser,\n}\n\nimpl GridParserChecker {\n    /// Constructeur d'un 'checker' d'une grille parsée\n    pub const fn new(parser: GridParser) -\u003e Self {\n        Self { parser }\n    }\n\n    /// Vérifie la validité d'une grille parsée\n    pub fn check(\u0026self) -\u003e Result\u003c(), String\u003e {\n        for region in \u0026self.parser.regions() {\n            if !self.region_ok(*region) {\n                return Err(format!(\n                    \"La region '{region}' n'est pas un bloc consistant dans cette grille\",\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Vérifie la validité d'une région de la grille\n    fn region_ok(\u0026self, region: Region) -\u003e bool {\n        // Liste des cases de la région\n        let all_region_cells = self.parser.region_cells(region);\n        if all_region_cells.is_empty() {\n            return false;\n        }\n\n        // Première case de la region\n        let first_cell = all_region_cells[0].clone();\n\n        // On construit la liste de toutes les cases adjacentes à cette 'first_cell'\n        // Pour cela, on a une liste des cases à parcourir qu'on initialise avec first_cell et qu'on\n        // enrichit des cases adjacentes qui sont dans la zone.\n        let mut cells_to_check = vec![first_cell];\n        let mut cells_checked = vec![];\n\n        while let Some(current_cell) = cells_to_check.pop() {\n            // Traitement d'une case à vérifier de la région\n            if !cells_checked.contains(\u0026current_cell) {\n                // Pas déjà vérifiée...\n                cells_checked.push(current_cell.clone());\n\n                // Liste des cases adjacentes à cette case dans la région...\n                let adjacent_region_cells = self.adjacent_region_cells(\u0026current_cell);\n\n                // ... qu'on ajoute à la liste des cases à traiter si pas déjà traitées\n                for adjacent_region_cell in \u0026adjacent_region_cells {\n                    if !cells_checked.contains(adjacent_region_cell) {\n                        cells_to_check.push(adjacent_region_cell.clone());\n                    }\n                }\n            }\n        }\n\n        // Ici, 'cells_checked' contient toutes les cases de la region.\n        // On doit en avoir le même nombre que celles de la grille\n        cells_checked.len() == all_region_cells.len()\n    }\n\n    // Liste des case adjacentes à une case\n    fn adjacent_cells(\u0026self, cell: \u0026GridCell) -\u003e Vec\u003cGridCell\u003e {\n        let mut cells = vec![];\n        let (line, column) = (cell.line_column.line, cell.line_column.column);\n\n        // North ?\n        if line \u003e 0 {\n            cells.push(self.parser.cell(LineColumn::new(line - 1, column)).unwrap());\n        }\n\n        // South ?\n        if line \u003c self.parser.nb_lines() - 1 {\n            cells.push(self.parser.cell(LineColumn::new(line + 1, column)).unwrap());\n        }\n\n        // West ?\n        if column \u003e 0 {\n            cells.push(self.parser.cell(LineColumn::new(line, column - 1)).unwrap());\n        }\n\n        // East ?\n        if column \u003c self.parser.nb_columns() - 1 {\n            cells.push(self.parser.cell(LineColumn::new(line, column + 1)).unwrap());\n        }\n\n        cells\n    }\n\n    /// Liste des cases adjacentes à la case (line, column) de la même région\n    fn adjacent_region_cells(\u0026self, cell: \u0026GridCell) -\u003e Vec\u003cGridCell\u003e {\n        self.adjacent_cells(cell)\n            .iter()\n            .filter(|c| c.region == cell.region)\n            .cloned()\n            .collect()\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":4683743612465316095}},{"line":19,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":20,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":21,"address":[],"length":0,"stats":{"Line":13618885273168379904}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":28,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":32,"address":[],"length":0,"stats":{"Line":13618885273168379905}},{"line":34,"address":[],"length":0,"stats":{"Line":13618885273168379905}},{"line":35,"address":[],"length":0,"stats":{"Line":13618885273168379905}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":13618885273168379904}},{"line":45,"address":[],"length":0,"stats":{"Line":13618885273168379904}},{"line":46,"address":[],"length":0,"stats":{"Line":13618885273168379904}},{"line":48,"address":[],"length":0,"stats":{"Line":9295429630892703752}},{"line":52,"address":[],"length":0,"stats":{"Line":2594073385365405699}},{"line":55,"address":[],"length":0,"stats":{"Line":2594073385365405699}},{"line":58,"address":[],"length":0,"stats":{"Line":13258597302978740281}},{"line":59,"address":[],"length":0,"stats":{"Line":11889503016258109454}},{"line":60,"address":[],"length":0,"stats":{"Line":11889503016258109454}},{"line":68,"address":[],"length":0,"stats":{"Line":13618885273168379904}},{"line":72,"address":[],"length":0,"stats":{"Line":2594073385365405710}},{"line":73,"address":[],"length":0,"stats":{"Line":2594073385365405710}},{"line":74,"address":[],"length":0,"stats":{"Line":2594073385365405710}},{"line":77,"address":[],"length":0,"stats":{"Line":9871890383196127259}},{"line":78,"address":[],"length":0,"stats":{"Line":7277816997830721549}},{"line":82,"address":[],"length":0,"stats":{"Line":10088063165309911065}},{"line":83,"address":[],"length":0,"stats":{"Line":7493989779944505355}},{"line":87,"address":[],"length":0,"stats":{"Line":10016005571271983129}},{"line":88,"address":[],"length":0,"stats":{"Line":7421932185906577419}},{"line":92,"address":[],"length":0,"stats":{"Line":9943947977234055193}},{"line":93,"address":[],"length":0,"stats":{"Line":7349874591868649483}},{"line":96,"address":[],"length":0,"stats":{"Line":2594073385365405710}},{"line":100,"address":[],"length":0,"stats":{"Line":2594073385365405707}},{"line":101,"address":[],"length":0,"stats":{"Line":2594073385365405707}},{"line":103,"address":[],"length":0,"stats":{"Line":16285016252571713558}}],"covered":36,"coverable":36},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_surfer.rs"],"content":"//! [`Surfer`] permet de déterminer une façon de naviguer à travers la grille.\u003cbr\u003e\n//!\n//! Applicable sur un objet [`GridHandler`] associé à une grille définie par un [`Grid`].\n\nuse std::fmt::Display;\nuse std::ops::RangeInclusive;\n\nuse crate::line_column::{display_column, display_line};\nuse crate::CellValue;\nuse crate::Grid;\nuse crate::GridCell;\nuse crate::GridHandler;\nuse crate::LineColumn;\nuse crate::Region;\n\n/// Navigation dans la grille\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum GridSurfer {\n    /// Navigation sur toutes les case de la grille\n    AllCells,\n\n    /// Navigation sur toutes les cases d'une région\n    Region(Region),\n\n    /// Navigation sur toutes les cases adjacentes à une case donnée (y compris les diagonales)\n    Adjacent(LineColumn),\n\n    /// Navigation sur toutes les cases d'un ligne\n    Line(usize),\n\n    /// Navigation sur toutes les cases d'une colonne\n    Column(usize),\n\n    /// Navigation sur plusieurs lignes\n    Lines(RangeInclusive\u003cusize\u003e),\n\n    /// Navigation sur plusieurs colonnes\n    Columns(RangeInclusive\u003cusize\u003e),\n}\n\nimpl Display for GridSurfer {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::AllCells =\u003e write!(f, \"Toute la grille\"),\n            Self::Region(region) =\u003e write!(f, \"Region '{region}'\"),\n            Self::Adjacent(line_column) =\u003e write!(f, \"Cases adjacentes à '{line_column}'\"),\n            Self::Line(line) =\u003e write!(f, \"Ligne {}\", display_line(*line)),\n            Self::Column(column) =\u003e write!(f, \"Colonne {}\", display_column(*column)),\n            Self::Lines(range) =\u003e {\n                if *range.start() == *range.end() {\n                    write!(f, \"Ligne {}\", display_line(*range.start()))\n                } else {\n                    write!(\n                        f,\n                        \"Lignes {}-{}\",\n                        display_line(*range.start()),\n                        display_line(*range.end())\n                    )\n                }\n            }\n            Self::Columns(range) =\u003e {\n                if *range.start() == *range.end() {\n                    write!(f, \"Colonne {}\", display_column(*range.start()))\n                } else {\n                    write!(\n                        f,\n                        \"Colonnes {}-{}\",\n                        display_column(*range.start()),\n                        display_column(*range.end())\n                    )\n                }\n            }\n        }\n    }\n}\n\nimpl GridHandler {\n    /// Retourne la liste des cases d'une grille qui satisfont à un certain critère.\u003cbr\u003e\n    /// Le critère est défini par l'énumération `GridSurfer`\n    #[must_use]\n    pub fn surfer(\u0026self, grid: \u0026Grid, surfer: \u0026GridSurfer) -\u003e Vec\u003cLineColumn\u003e {\n        let mut cells = Vec::new();\n        for line in 0..self.nb_lines() {\n            for column in 0..self.nb_columns() {\n                let line_column = LineColumn::new(line, column);\n                let cell: \u0026GridCell = grid.cell(line_column);\n                let cell_is_matching = match surfer {\n                    // Toutes les case de la grille\n                    GridSurfer::AllCells =\u003e true,\n                    // Toutes les cases d'une région\n                    GridSurfer::Region(region) =\u003e cell.region == *region,\n                    // Toutes les cases adjacentes à une case donnée (y compris les diagonales)\n                    GridSurfer::Adjacent(line_column) =\u003e {\n                        let adjacent_cells = self.adjacent_cells(*line_column);\n                        adjacent_cells\n                            .iter()\n                            .any(|cell| cell.line == line \u0026\u0026 cell.column == column)\n                    }\n                    // Toutes les cases d'une ligne\n                    GridSurfer::Line(select_line) =\u003e *select_line == line,\n                    // Toutes les cases d'une colonne\n                    GridSurfer::Column(select_column) =\u003e *select_column == column,\n                    // Toutes les cases de plusieurs lignes\n                    GridSurfer::Lines(line_range) =\u003e line_range.contains(\u0026line),\n                    // Toutes les cases de plusieurs colonnes\n                    GridSurfer::Columns(column_range) =\u003e column_range.contains(\u0026column),\n                };\n                if cell_is_matching {\n                    cells.push(line_column);\n                }\n            }\n        }\n\n        cells\n    }\n\n    /// Retourne le nombre de cases sans la zone définie par le `GridSurfer`\n    #[must_use]\n    pub fn surfer_cells_count(\u0026self, grid: \u0026Grid, surfer: \u0026GridSurfer) -\u003e usize {\n        self.surfer(grid, surfer).len()\n    }\n\n    /// Retourne le nombre de cases contenant une valeur particulière dans la zone définie par le `GridSurfer`\n    #[must_use]\n    pub fn surfer_cells_with_value_count(\n        \u0026self,\n        grid: \u0026Grid,\n        surfer: \u0026GridSurfer,\n        value: \u0026CellValue,\n    ) -\u003e usize {\n        self.surfer(grid, surfer)\n            .iter()\n            .filter(|line_column| grid.cell(**line_column).value == *value)\n            .count()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use crate::GridParser;\n\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\n        let parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let grid_handler = GridHandler::new(\u0026parser, 1);\n        let grid = Grid::from(\u0026grid_handler);\n        (grid_handler, grid)\n    }\n\n    #[test]\n    fn test_all_cells() {\n        let (grid_handler, grid) = get_test_grid();\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::AllCells);\n        assert_eq!(\n            surfer.len(),\n            grid_handler.nb_lines() * grid_handler.nb_columns()\n        );\n    }\n\n    #[test]\n    fn test_region() {\n        let (grid_handler, grid) = get_test_grid();\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Region('A'));\n        assert_eq!(surfer, vec![LineColumn::new(0, 0), LineColumn::new(1, 0)]);\n    }\n\n    #[test]\n    fn test_adjacent() {\n        let (grid_handler, grid) = get_test_grid();\n        // 8 cases adjacentes à la case (2, 2) au milieu de la grille\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Adjacent(LineColumn::new(2, 2)));\n        assert_eq!(surfer.len(), 8);\n    }\n\n    #[test]\n    fn test_line() {\n        let (grid_handler, grid) = get_test_grid();\n        // 5 cases de la 2eme ligne\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Line(1));\n        assert_eq!(surfer.len(), 5);\n        assert_eq!(\n            surfer\n                .iter()\n                .filter(|line_column| line_column.line == 1)\n                .count(),\n            5\n        );\n    }\n\n    #[test]\n    fn test_column() {\n        let (grid_handler, grid) = get_test_grid();\n        // 5 cases de la 2eme colonne\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Column(1));\n        assert_eq!(surfer.len(), 5);\n        assert_eq!(\n            surfer\n                .iter()\n                .filter(|line_column| line_column.column == 1)\n                .count(),\n            5\n        );\n    }\n\n    #[test]\n    fn test_multi_lines() {\n        let (grid_handler, grid) = get_test_grid();\n        // 15 cases de la 2eme, 3eme et 4eme lignes\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Lines(1..=3));\n        assert_eq!(surfer.len(), 15);\n        assert_eq!(\n            surfer\n                .iter()\n                .filter(|line_column| (1..=3).contains(\u0026line_column.line))\n                .count(),\n            15\n        );\n    }\n\n    #[test]\n    fn test_multi_columns() {\n        let (grid_handler, grid) = get_test_grid();\n        // 10 cases de la 4eme et dernière colonnes\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Columns(3..=4));\n        assert_eq!(surfer.len(), 10);\n        assert_eq!(\n            surfer\n                .iter()\n                .filter(|line_column| (3..=4).contains(\u0026line_column.column))\n                .count(),\n            10\n        );\n    }\n\n    #[test]\n    fn test_surfer_cells_count() {\n        let (grid_handler, grid) = get_test_grid();\n        assert_eq!(\n            grid_handler.surfer_cells_count(\u0026grid, \u0026GridSurfer::Region('A')),\n            2\n        );\n    }\n\n    #[test]\n    fn test_surfer_cells_with_value_count() {\n        let (grid_handler, mut grid) = get_test_grid();\n\n        // Par défaut, toutes les cases sont à la valeur `CellValue::Unknown`\n        // On place une étoile et une case qui ne peut pas contenir d'étoile sur la 1ere ligne\n        grid.cell_mut(LineColumn::new(0, 1)).value = CellValue::Star;\n        grid.cell_mut(LineColumn::new(0, 3)).value = CellValue::NoStar;\n\n        assert_eq!(\n            grid_handler.surfer_cells_with_value_count(\n                \u0026grid,\n                \u0026GridSurfer::Line(0),\n                \u0026CellValue::Star\n            ),\n            1\n        );\n        assert_eq!(\n            grid_handler.surfer_cells_with_value_count(\n                \u0026grid,\n                \u0026GridSurfer::Line(0),\n                \u0026CellValue::NoStar\n            ),\n            1\n        );\n        assert_eq!(\n            grid_handler.surfer_cells_with_value_count(\n                \u0026grid,\n                \u0026GridSurfer::Line(0),\n                \u0026CellValue::Unknown\n            ),\n            3\n        );\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639694}},{"line":43,"address":[],"length":0,"stats":{"Line":360287970189639694}},{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":12465963768561532936}},{"line":82,"address":[],"length":0,"stats":{"Line":12465963768561532936}},{"line":83,"address":[],"length":0,"stats":{"Line":4467570830351537669}},{"line":84,"address":[],"length":0,"stats":{"Line":1585267068834425850}},{"line":85,"address":[],"length":0,"stats":{"Line":9583660007044421117}},{"line":86,"address":[],"length":0,"stats":{"Line":9583660007044421117}},{"line":87,"address":[],"length":0,"stats":{"Line":720575940379290618}},{"line":89,"address":[],"length":0,"stats":{"Line":3458764513819666231}},{"line":91,"address":[],"length":0,"stats":{"Line":455352}},{"line":93,"address":[],"length":0,"stats":{"Line":3602879701896549479}},{"line":94,"address":[],"length":0,"stats":{"Line":3602879701896549479}},{"line":95,"address":[],"length":0,"stats":{"Line":3602879701896549479}},{"line":97,"address":[],"length":0,"stats":{"Line":6196953087262107855}},{"line":100,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":102,"address":[],"length":0,"stats":{"Line":14915921965851224419}},{"line":104,"address":[],"length":0,"stats":{"Line":9223372036854905179}},{"line":106,"address":[],"length":0,"stats":{"Line":11529215046068471017}},{"line":108,"address":[],"length":0,"stats":{"Line":17005592192950994139}},{"line":109,"address":[],"length":0,"stats":{"Line":17005592192950994139}},{"line":114,"address":[],"length":0,"stats":{"Line":12465963768561583548}},{"line":119,"address":[],"length":0,"stats":{"Line":72057594038004458}},{"line":120,"address":[],"length":0,"stats":{"Line":72057594038004458}},{"line":125,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":131,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":133,"address":[],"length":0,"stats":{"Line":18086456103519911936}}],"covered":30,"coverable":46},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","lib.rs"],"content":"/*!\r\nStar Battle Solver\r\n\r\nStar Battle est un puzzle logique avec des règles simples et des solutions stimulantes.\r\n\r\nLes règles de Star Battle sont simples :\r\nVous devez placer des étoiles sur la grille selon ces règles :\r\n\r\n* 2 étoiles ne peuvent pas être adjacentes horizontalement, verticalement ou en diagonale.\r\n* Pour les puzzles 1★, vous devez placer 1 étoile sur chaque ligne, colonne et région.\r\n* Pour les puzzles 2★, les étoiles par ligne, colonne et région doivent être 2, etc.\r\n* Il existe également des puzzles 3★.\r\n\r\n## Sites internet\r\n\r\n* [Site en français](https://fr.puzzle-star-battle.com/)\r\n* [Vidéo en français](https://www.youtube.com/watch?v=dG-xkOYYkwY)\r\n* [Site en anglais](https://starbattle.puzzlebaron.com/)\r\n\r\n## [`Region`]\r\n\r\n[`Region`] est une zone de cases dans laquelle il faut également placer le nombre d'étoiles attendus.\u003cbr\u003e\r\nPour ce crate, une région est identifiée par un [`char`] issu de la formalisation textuelle reconnue par le [`GridParser`].\r\n\r\n## [`GridParser`]\r\n\r\n[`GridParser`] construit une grille depuis une formalisation textuelle d'une grille à résoudre.\r\n\r\nLe constructeur est une forme de [`TryFrom`] pour l'un des types suivants :\r\n\r\n* `TryFrom\u003c\u0026Vec\u003cString\u003e\u003e for Parser`\r\n* `TryFrom\u003cVec\u003cString\u003e\u003e for Parser`\r\n* `TryFrom\u003c\u0026[String]\u003e for Parser`\r\n* `TryFrom\u003cVec\u003c\u0026str\u003e\u003e for `\r\n* `TryFrom\u003c\u0026str\u003e for Parser`\r\n\r\nChaque ligne du texte (ou chaque élément du vecteur) correspond à une ligne de la grille à résoudre.\u003cbr\u003e\r\nLes différentes régions de la grille sont identifiées par des caractères distincts dans les cases correspondantes.\u003cbr\u003e\r\nLes espaces ou séparateurs équivalents (e.g. TAB) sont ignorés.\u003cbr\u003e\r\nLes lignes 'vides' ou qui débutent par l'un des caractères suivants sont ignorées : '*', '#' ou '/'\r\n(considérés comme d'éventuels commentaires).\u003cbr\u003e\r\n\r\n```rust\r\nuse star_battle::GridParser;\r\n\r\n// Représentation textuelle d'une grille de 5 lignes et 5 colonnes contenant 5 régions\r\n// distinctes repérées par les lettres 'A', 'B', 'C', 'D' et 'E'.\r\nassert!(GridParser::try_from(\"\r\n    ABBBB\r\n    ABBBB\r\n    CCBBB\r\n    DDDDD\r\n    DEEED\r\n\").is_ok());\r\n```\r\n\r\nLe [`GridParser`] est utilisé pour définir la grille initiale. La cohérence de la grille est vérifiée:\r\n\r\n* Syntaxe correcte dans le texte descriptif de la grille\r\n* Nombre cohérent de colonnes dans chaque ligne\r\n* Régions connexes dans la grille\r\n\r\n## [`LineColumn`]\r\n\r\n[`LineColumn`] repère une case dans la grille par ses coordonnées (`line`, `column`) base 0.\r\n\r\nLorsque les coordonnées d'une case sont affichées (`Display`), les colonnes sont référencées par les lettres\r\n'A', 'B', ... et les lignes par des chiffres'1', '2'.\u003cbr\u003e\r\nLa case (0, 0) en haut et à gauche de la grille correspond donc avec 'A1'.\r\n\r\n```rust\r\nuse star_battle::LineColumn;\r\n\r\nlet line_column = LineColumn::new(0, 1);\r\n\r\nassert_eq!(line_column.line(), 0);\r\nassert_eq!(line_column.column(), 1);\r\nassert_eq!(format!(\"{}\", line_column), \"B1\");\r\n```\r\n\r\n## [`CellValue`]\r\n\r\n[`CellValue`] définit une valeur possible d'une case de la grille parmi:\r\n\r\n* `Unknown` : Contenu inconnu de la case (valeur par défaut)\r\n* `Star` : La case contient une étoile\r\n* `NoStar` : La case ne peut pas contenir une étoile\r\n\r\n```rust\r\nuse star_battle::CellValue;\r\nassert_eq!(CellValue::default(), CellValue::Unknown);\r\n```\r\n\r\n## [`GridCell`]\r\n\r\n[`GridCell`] décrit une case de la grille parsée par [`GridParser`] ou gérée par [`Grid`]:\r\n\r\n* `line_column`: [`LineColumn`] de la case dans la grille (base 0)\r\n* `region`: [`Region`] de la case\r\n* `value`: [`CellValue`] de la case. Par défaut, `CellValue::Unknown`.\r\n\r\n```rust\r\nuse star_battle::{GridParser, LineColumn, CellValue};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n\r\nassert_eq!(grid_parser.cell(LineColumn::new(0, 0)).unwrap().region, 'A');\r\nassert_eq!(grid_parser.cell(LineColumn::new(0, 0)).unwrap().value, CellValue::Unknown);\r\n```\r\n\r\n## [`GridHandler`]\r\n\r\n[`GridHandler`] définit les caractéristiques d'une grille à résoudre:\r\n\r\n* `nb_lines`: nombre de lignes de la grille\r\n* `nb_columns`: nombre de colonnes de la grille\r\n* `nb_stars`: nombre d'étoiles à placer dans chaque ligne, colonne et région de la grille\r\n* `regions`: liste des régions de la grille (par ordre de taille croissante)\r\n* `cell_region`: région d'une case de la grille\r\n\r\nLes contenus des cases de la grille ne sont pas définis dans la structure [`GridHandler`].\u003cbr\u003e\r\nC'est la structure [`Grid`] qui représente le contenu des cases de la grille.\r\n\r\nInitialement, le [`GridHandler`] est construite à partir d'un [`GridParser`] en indiquant le nombre d'étoiles à\r\nplacer sur chaque ligne, colonne et région.\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, LineColumn};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid = GridHandler::new(\u0026grid_parser, 1);\r\n\r\nassert_eq!(grid.nb_lines(), 5);\r\nassert_eq!(grid.nb_columns(), 5);\r\nassert_eq!(grid.nb_stars(), 1);\r\nassert_eq!(grid.regions().len(), 5);\r\nassert_eq!(grid.cell_region(LineColumn::new(0, 0)), 'A');\r\n```\r\n\r\nLa fonction [`GridHandler::is_done`] retourne `true` si toutes les cases de la grille ont une valeur définie.\r\n\r\n## [`Grid`]\r\n\r\n[`Grid`] est la structure avec le contenu des cases de la grille.\r\n\r\nCette structure est utilisée pour la resolution du jeu. Elle est allégée des informations détenues par la\r\nstructure associée [`GridHandler`]; Ce qui permet d'examiner des évolutions de la grille en optimisant\r\nl'occupation de mémoire.\r\n\r\nInitialement, la [`Grid`] est construite à partir d'un [`GridHandler`].\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet grid = Grid::from(\u0026grid_handler);\r\n\r\nassert_eq!(grid.nb_lines(), 5);\r\nassert_eq!(grid.nb_columns(), 5);\r\n```\r\n\r\nOn peut ainsi utiliser la structure [`Grid`] pour résoudre le jeu en clonant cette structure et en\r\npostulant sur la valeur des cases de la grille pour évaluer les possibilités.\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, LineColumn, CellValue};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet grid = Grid::from(\u0026grid_handler);\r\n\r\nlet mut grid_cloned = grid.clone();\r\nlet line_column = LineColumn::new(0, 0);\r\ngrid_cloned.cell_mut(line_column).value = CellValue::Star;\r\nassert_eq!(grid.cell(line_column).value, CellValue::Unknown);\r\nassert_eq!(grid_cloned.cell(line_column).value, CellValue::Star);\r\n```\r\n\r\n## [`GridSurfer`]\r\n\r\n[`GridSurfer`] est une  énumération qui permet de naviguer sur les case de la grille qui répondre à certains\r\ncritères pour parcourir les cases d'une grille.\r\n\r\n Cette énumération est applicable sur un objet [`GridHandler`] associé à une grille définie par un [`Grid`].\r\n\r\n On peut ainsi parcourir les cases de la grille suivant les critères suivants:\r\n\r\n* Toutes les cases de la grille\r\n* Toutes les cases d'une region\r\n* Toutes les cases adjacentes à une case donnée (y compris les diagonales)\r\n* Toutes les cases d'une ligne\r\n* Toutes les cases d'une colonne\r\n* Toutes les cases de plusieurs lignes consécutives\r\n* Toutes les cases de plusieurs colonnes consécutives\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, LineColumn, GridSurfer};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet grid = Grid::from(\u0026grid_handler);\r\n\r\n// Liste des cases d'une région\r\nlet grid_surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Region('A'));\r\nassert_eq!(grid_surfer, vec![LineColumn::new(0, 0), LineColumn::new(1, 0)]);\r\n```\r\n\r\n## [`BadRuleError`]\r\n\r\n[`BadRuleError`] identifie une situation qui invalide le contenu d'une grille.\r\n\r\nLa fonction [`check_bad_rules`] permet de vérifier qu'une une grille est valide ou non.\r\nCette fonction retourne une erreur [`BadRuleError`] si la grille n'est pas valide et `Ok(())` si la grille est valide.\r\n\r\nLes situations invalides étant :\r\n\r\n* 2 cases adjacentes contenant chacune une étoile\r\n* Une 'zone' qui contient trop d'étoiles\r\n* Une 'zone' dans laquelle il n'est pas possible de placer suffisamment d'étoiles\r\n\r\nIci une 'zone' étant :\r\n\r\n* Une [`Region`]\r\n* Une ligne de la grille\r\n* Une colonne de la grille\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, check_bad_rules};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet grid = Grid::from(\u0026grid_handler);\r\n\r\nassert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n```\r\n\r\n# [`GridAction`]\r\n\r\n[`GridAction`] représente une action possible sur une case de la grille :\r\n\r\n* Placer une étoile\r\n* Indiquer qu'une étoile n'est possible dans cette case\r\n* Indiquer que le contenu d'une case est inconnu\r\n\r\nCes actions sont liées au contenu possible d'une case de la grille défini par un [`CellValue`].\r\n\r\n[`GridAction`] implémente la méthode [`GridAction::apply_action`] qui permet d'appliquer une action sur une [`Grid`].\r\n\r\nSymétriquement, le module [`Grid`] implémente la méthode [`Grid::apply_action`] qui permet d'appliquer une\r\nde ces actions à une case de la grille.\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, CellValue, GridAction, LineColumn};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet mut grid = Grid::from(\u0026grid_handler);\r\n\r\ngrid.apply_action(\u0026GridAction::SetStar(LineColumn::new(1, 1)));\r\nassert_eq!(grid.cell(LineColumn::new(1, 1)).value, CellValue::Star);\r\n\r\nGridAction::SetNoStar(LineColumn::new(1, 1)).apply_action(\u0026mut grid);\r\nassert_eq!(grid.cell(LineColumn::new(1, 1)).value, CellValue::NoStar);\r\n```\r\n\r\n# [`GoodRule`]\r\n\r\n[`GoodRule`] identifie les règles qui permettent d'avancer dans la construction/résolution d\"une grille :\r\n\r\n* `NoStarAdjacentToStar(LineColumn, Vec\u003cGridAction\u003e)`:  Indique les cases adjacentes à une étoile qui ne peuvent\r\n   pas contenir une étoile et indique les actions à effectuer pour les définir\r\n* `ZoneNoStarCompleted`: Indique les cases restantes dans une zone ne peuvent pas être des étoiles\r\n* `ZoneStarCompleted`: Indique les cases restantes dans une zone sont forcement des étoiles\r\n* `InvariantWithZone(GridSurfer, Vec\u003cGridAction\u003e)`: Indique que quelle que soit la façon de placer les étoiles\r\n   dans une zone, des cases n'ont toujours qu'une seule et même possibilité\r\n\r\nLa fonction [`get_good_rule`] recherche une règle [`GoodRule`] applicable à une grille.\u003cbr\u003e\r\nCette fonction retourne une erreur [`BadRuleError`] si la grille n'est pas valide.\u003cbr\u003e\r\nSinon un `Option\u003cGoodRule\u003e` est retourné.\u003cbr\u003e\r\nNone signifie alors qu'aucune règle permettant d'avancer dans la construction de la grille n'a été trouvée.\r\n\r\nLes règles examinées sont :\r\n\r\n* Une case non définie et adjacente à une étoile ne peut pas être une étoile\r\n\r\n* Toutes les cases non définies dans une 'zone' (région, ligne ou colonne) qui possède déjà toutes ces étoiles\r\n  sont des cases qui ne peuvent pas contenir une étoile\r\n\r\n* S'il reste autant de cases non définies dans une 'zone' (région, ligne ou colonne) que d'étoiles manquantes\r\n  dans cette 'zone' alors ce sont forcément des étoiles\r\n\r\n* Si toutes les combinaisons possibles pour positioner les étoiles dans une région ont des cases toujours avec une\r\n  étoile (ou jamais une étoile) alors ces cases contiennent une étoile (ou ne peuvent pas contenir une étoile)\r\n\r\n* Si une case autour d'une région est toujours adjacente à une étoile pour toutes les combinaisons possibles d'étoiles\r\n  dans cette région alors cette case ne peut pas être des étoiles\r\n\r\n* On examine toutes les combinaisons de 1, 2, 3 ou 4 lignes ou colonnes qui sont occupées par max. 'n' régions :\r\n  S'il existe des cases de ces régions en dehors de ces 1, 2, 3 ou 4 lignes ou colonnes, elles ne peuvent pas\r\n  contenir une étoile puisque toutes les étoiles de ces régions sont forcement dans les 1, 2, 3 ou 4 lignes\r\n  ou colonnes examinés.\u003cbr\u003e\r\n  (cette règle est l'inverse de la suivante)\r\n\r\n* On examine toutes les combinaisons de 1, 2, 3 ou 4 régions qui occupent respectivement uniquement 1, 2, 3 ou 4 lignes\r\n  ou colonnes : S'il restent des cases n'appartenant pas à ces combinaisons dans ces lignes ou colonnes, elles ne\r\n  peuvent pas contenir une étoile.\u003cbr\u003e\r\n  (cette règle est l'inverse de la précédente)\r\n\r\n* Toutes les combinaisons possibles pour positionner une étoile dans une ligne ou colonne ont des\r\n  cases toujours avec une étoile ou jamais une étoile dans toutes les grilles possibles pour ces combinaisons\r\n\r\n* Toutes les combinaisons possibles pour positionner une étoile dans plusieurs ligne ou colonnes consécutives\r\n  (2, 3 ou 4) nt des cases toujours avec une étoile ou jamais une étoile dans toutes les grilles possibles\r\n  pour ces combinaisons\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, get_good_rule};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet mut grid = Grid::from(\u0026grid_handler);\r\n\r\nlet ok_good_rule = get_good_rule(\u0026grid_handler, \u0026grid);\r\nassert!(ok_good_rule.is_ok());\r\nlet some_good_rule = ok_good_rule.unwrap();\r\nassert!(some_good_rule.is_some());\r\nlet good_rule = some_good_rule.unwrap();\r\ngrid.apply_good_rule(\u0026good_rule);\r\n```\r\n\r\n*/\r\n\r\n/// Une région est identifiée par un caractère.\r\npub type Region = char;\r\n\r\n// Modules\r\nmod cell_value;\r\nmod grid;\r\nmod grid_action;\r\nmod grid_bad_ruler;\r\nmod grid_cell;\r\nmod grid_good_ruler;\r\nmod grid_handler;\r\nmod grid_parser;\r\nmod grid_parser_checker;\r\nmod grid_surfer;\r\nmod line_column;\r\n\r\n// Internal\r\nuse grid_parser_checker::GridParserChecker;\r\nuse line_column::{display_column, display_line};\r\n\r\n// Exported\r\npub use cell_value::CellValue;\r\npub use grid::Grid;\r\npub use grid_action::GridAction;\r\npub use grid_bad_ruler::{check_bad_rules, BadRuleError};\r\npub use grid_cell::GridCell;\r\npub use grid_good_ruler::{get_good_rule, GoodRule};\r\npub use grid_handler::GridHandler;\r\npub use grid_parser::GridParser;\r\npub use grid_surfer::GridSurfer;\r\npub use line_column::LineColumn;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","line_column.rs"],"content":"//! Help for grid line and column coordinates.\n\nuse std::fmt::Display;\n\n/// Coordonnées d'une case de la grille (`line`, `column`) base 0\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]\npub struct LineColumn {\n    /// Numéro de la ligne (base 0). Ligne 0 correspond à la première ligne u haut.\n    pub line: usize,\n\n    /// Numéro de la colonne (base 0). Colonne 0 correspond à la première colonne de gauche\n    pub column: usize,\n}\n\nimpl From\u003c(usize, usize)\u003e for LineColumn {\n    fn from((line, column): (usize, usize)) -\u003e Self {\n        Self { line, column }\n    }\n}\n\n/// Affichage du numéro de ligne : 0, 1, ... devient '1', '2', ...\npub fn display_line(line: usize) -\u003e String {\n    format!(\"{}\", line + 1)\n}\n\n/// Affichage du numéro de colonne 0, 1, ... devient 'A', 'B', ...\npub fn display_column(column: usize) -\u003e String {\n    std::char::from_u32(u32::from(b'A') + u32::try_from(column).unwrap())\n        .unwrap()\n        .to_string()\n}\n\nimpl Display for LineColumn {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        // On choisit d'utiliser les lettres 'A', 'B', 'C', 'D', 'E' pour les lignes\n        // La case de la ligne 0, colonne 0 est donc 'A1'.\n        write!(\n            f,\n            \"{}{}\",\n            display_column(self.column),\n            display_line(self.line)\n        )\n    }\n}\n\nimpl LineColumn {\n    /// Constructeur\n    #[must_use]\n    pub const fn new(line: usize, column: usize) -\u003e Self {\n        Self { line, column }\n    }\n\n    /// Ligne de la case dans la grille (base 0)\n    #[must_use]\n    pub const fn line(\u0026self) -\u003e usize {\n        self.line\n    }\n\n    /// Colonne de la case dans la grille (base 0)\n    #[must_use]\n    pub const fn column(\u0026self) -\u003e usize {\n        self.column\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_from() {\n        let lc = LineColumn::from((1, 2));\n        assert_eq!(lc.line(), 1);\n        assert_eq!(lc.column(), 2);\n    }\n\n    #[test]\n    fn test_new() {\n        let lc = LineColumn::new(2, 1);\n        assert_eq!(lc.line(), 2);\n        assert_eq!(lc.column(), 1);\n    }\n\n    #[test]\n    fn test_eq() {\n        assert_eq!(LineColumn::new(1, 2), LineColumn::from((1, 2)));\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":3530822107859752090}},{"line":22,"address":[],"length":0,"stats":{"Line":7205759403792793613}},{"line":23,"address":[],"length":0,"stats":{"Line":7205759403792793613}},{"line":27,"address":[],"length":0,"stats":{"Line":7133701809754865665}},{"line":28,"address":[],"length":0,"stats":{"Line":7133701809754865665}},{"line":34,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":37,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":38,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":40,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":41,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":49,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":55,"address":[],"length":0,"stats":{"Line":144115188076325538}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188076325538}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":15,"coverable":15},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","main.rs"],"content":"//! Star Battle Solver\n\nuse std::env;\nuse std::fs::File;\nuse std::io::Read;\n\nuse star_battle::get_good_rule;\nuse star_battle::Grid;\nuse star_battle::GridHandler;\nuse star_battle::GridParser;\n\n/// Message d'aide pour l'utilisateur\nconst HELP_MESSAGE: \u0026str = \"\nSTAR BATTLE Usage: ./star-battle \u003cgrille\u003e {\u003cnb étoiles\u003e}\n\n\u003cgrille\u003e est le nom d'un fichier contenant une grille à résoudre.\n\u003cnb_étoiles\u003e est le nombre d'étoiles à placer dans chaque ligne, colonne et région de la grille.\nPar défaut, ce nombre d'étoile est 1.\n\nLe fichier \u003cgrille\u003e définit chaque région de la grille par un caractère.\nPar exemple :\n\n# Exemple de grille 1★ avec 5 régions 'A', 'B', 'C', 'D' et 'E'\nABBBB\nABBBB\nCCBBB\nDDDDD\nDEEED\n\";\n\nfn main() {\n    // Nom du fichier contenant la grille à résoudre en paramètre\n    let args: Vec\u003cString\u003e = env::args().collect();\n    let (file_name, nb_stars) = match args.len() {\n        2 =\u003e (\u0026args[1], 1),\n        3 =\u003e (\n            \u0026args[1],\n            args[2]\n                .parse::\u003cusize\u003e()\n                .expect(\"Le nombre d'étoiles doit être un nombre\"),\n        ),\n        _ =\u003e {\n            println!(\"{HELP_MESSAGE}\");\n            return;\n        }\n    };\n\n    // Demande d'aide ?\n    if [\"-h\", \"--help\", \"aide\"].contains(\u0026file_name.to_lowercase().as_str()) {\n        println!(\"{HELP_MESSAGE}\");\n        return;\n    }\n\n    // Traitement du contenu du fichier\n    match read_lines(file_name) {\n        Ok(lines) =\u003e match GridParser::try_from(\u0026lines) {\n            Ok(grid_parsed) =\u003e solve(\u0026grid_parsed, nb_stars),\n\n            Err(e) =\u003e {\n                println!(\"Erreur dans le fichier {file_name}: {e}\");\n            }\n        },\n        Err(e) =\u003e println!(\"Erreur dans le fichier {file_name}: {e}\"),\n    }\n}\n\nfn solve(grid_parsed: \u0026GridParser, nb_stars: usize) {\n    let grid_handler = GridHandler::new(grid_parsed, nb_stars);\n    let mut grid = Grid::from(\u0026grid_handler);\n\n    println!(\"\\nGrid {nb_stars}★\\n{}\", grid_handler.display(\u0026grid, true));\n    loop {\n        match get_good_rule(\u0026grid_handler, \u0026grid) {\n            Ok(option_good_rule) =\u003e {\n                if option_good_rule.is_some() {\n                    let good_rule = option_good_rule.unwrap();\n                    println!(\"{good_rule}\");\n                    grid.apply_good_rule(\u0026good_rule);\n                    println!(\"\\n{}\", grid_handler.display(\u0026grid, true));\n                } else {\n                    break;\n                }\n            }\n            Err(bad_rule) =\u003e {\n                println!(\"{bad_rule} !!!\");\n                break;\n            }\n        }\n    }\n\n    if grid_handler.is_done(\u0026grid) {\n        println!(\"Grille résolue !\\n\");\n    } else {\n        println!(\"Grille non résolue :(\\n\");\n    }\n}\n\nfn read_lines(filename: \u0026str) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n    // Ouverture du fichier\n    let mut file = match File::open(filename) {\n        Ok(file) =\u003e file,\n        Err(e) =\u003e return Err(format!(\"Erreur ouverture du fichier {filename}: {e}\")),\n    };\n    // Lecture du fichier\n    let mut file_contents = String::new();\n    match file.read_to_string(\u0026mut file_contents) {\n        Ok(_) =\u003e {}\n        Err(e) =\u003e return Err(format!(\"Erreur lecture du fichier {filename}: {e}\")),\n    }\n\n    // Extraction des lignes du fichier\n    let lines: Vec\u003cString\u003e = file_contents\n        .split('\\n')\n        .map(|s: \u0026str| s.to_string())\n        .collect();\n    Ok(lines)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_main() {\n        // Liste de fichiers de tests avec des grilles à résoudre\n        let test_files = vec![\"./test_grids/test01.txt\"];\n\n        for test_file in test_files {\n            let lines = read_lines(test_file).unwrap();\n            let grid_parsed = GridParser::try_from(\u0026lines).unwrap();\n            let grid_handler = GridHandler::new(\u0026grid_parsed, 1);\n            let grid = Grid::from(\u0026grid_handler);\n            println!(\"Grid: \\n{grid}\");\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":100,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":6,"coverable":46}]};
        var previousData = {"files":[{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","cell_value.rs"],"content":"//! Énumération des valeurs possibles d'une case de la grille\r\n\r\n/// Valeur possible d'une case de la grille\r\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\r\npub enum CellValue {\r\n    /// Case dont le contenu est inconnu\r\n    #[default]\r\n    Unknown,\r\n\r\n    /// Case dont le contenu est une étoile\r\n    Star,\r\n\r\n    /// Case dont le contenu n'est pas une étoile\r\n    NoStar,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid.rs"],"content":"//! Contenu des case de la grille.\n\nuse std::fmt::Display;\n\nuse crate::CellValue;\nuse crate::GridCell;\nuse crate::GridHandler;\nuse crate::LineColumn;\n\n/// Cases de la grille\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Grid {\n    /// Dimensions de la grille\n    size: LineColumn,\n\n    /// Cases de la grille\n    cells: Vec\u003cVec\u003cGridCell\u003e\u003e,\n}\n\nimpl Display for Grid {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        for line in 0..self.nb_lines() {\n            for column in 0..self.nb_columns() {\n                match self.cell(LineColumn::new(line, column)).value {\n                    CellValue::Star =\u003e write!(f, \" *\")?,\n                    CellValue::NoStar =\u003e write!(f, \" -\")?,\n                    CellValue::Unknown =\u003e write!(f, \" ?\")?,\n                }\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}\n\nimpl From\u003c\u0026GridHandler\u003e for Grid {\n    fn from(value: \u0026GridHandler) -\u003e Self {\n        let nb_lines = value.nb_lines();\n        let nb_columns = value.nb_columns();\n        let mut cells = Vec::with_capacity(nb_lines);\n        for line in 0..nb_lines {\n            let mut cells_line = Vec::with_capacity(nb_columns);\n            for column in 0..nb_columns {\n                let line_column = LineColumn::new(line, column);\n                let grid_cell = GridCell {\n                    line_column,\n                    region: value.cell_region(line_column),\n                    value: CellValue::Unknown,\n                };\n                cells_line.push(grid_cell);\n            }\n            cells.push(cells_line);\n        }\n        Self {\n            size: LineColumn::new(nb_lines, nb_columns),\n            cells,\n        }\n    }\n}\n\nimpl Grid {\n    /// Nombre de lignes de la grille\n    #[must_use]\n    pub const fn nb_lines(\u0026self) -\u003e usize {\n        self.size.line\n    }\n\n    /// Nombre de colonnes de la grille\n    #[must_use]\n    pub const fn nb_columns(\u0026self) -\u003e usize {\n        self.size.column\n    }\n\n    /// Retourne la case (non mutable) de la grille en (line, column)\n    #[must_use]\n    pub fn cell(\u0026self, line_column: LineColumn) -\u003e \u0026GridCell {\n        \u0026self.cells[line_column.line][line_column.column]\n    }\n\n    /// Retourne la case (mutable) de la grille en (line, column)\n    #[must_use]\n    pub fn cell_mut(\u0026mut self, line_column: LineColumn) -\u003e \u0026mut GridCell {\n        \u0026mut self.cells[line_column.line][line_column.column]\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::GridParser;\n\n    #[test]\n    fn test_from_grid_handler() {\n        let parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n        let grid = Grid::from(\u0026handler);\n\n        assert_eq!(grid.nb_lines(), 5);\n        assert_eq!(grid.nb_columns(), 5);\n\n        for line in 0..grid.nb_lines() {\n            for column in 0..grid.nb_columns() {\n                let line_column = LineColumn::new(line, column);\n                assert_eq!(grid.cell(line_column).value, CellValue::Unknown);\n            }\n        }\n    }\n\n    #[test]\n    fn test_clone_cell_mut() {\n        let parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n        let grid = Grid::from(\u0026handler);\n\n        let mut grid_cloned = grid.clone();\n        let line_column = LineColumn::new(0, 0);\n        grid_cloned.cell_mut(line_column).value = CellValue::Star;\n        assert_eq!(grid.cell(line_column).value, CellValue::Unknown);\n        assert_eq!(grid_cloned.cell(line_column).value, CellValue::Star);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":23,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":24,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":30,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":37,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":38,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":39,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":40,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":41,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":42,"address":[],"length":0,"stats":{"Line":7421932185906577408}},{"line":43,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":44,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":47,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":50,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":52,"address":[],"length":0,"stats":{"Line":7421932185906577418}},{"line":55,"address":[],"length":0,"stats":{"Line":3819052484010180609}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783809}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783809}},{"line":70,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":71,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":76,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":77,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":82,"address":[],"length":0,"stats":{"Line":7782220156096597082}},{"line":83,"address":[],"length":0,"stats":{"Line":7782220156096597082}}],"covered":27,"coverable":29},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_action.rs"],"content":"//! Action possible sur une grille.\n\nuse std::fmt::Display;\n\nuse crate::CellValue;\nuse crate::Grid;\nuse crate::LineColumn;\n\n/// Énumération des actions possibles sur le contenu d'une grille\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\npub enum GridAction {\n    /// L'action d'indiquer le contenu indéfini d'une case\n    SetUnknown(LineColumn),\n\n    /// L'action d'ajouter une étoile à une case\n    SetStar(LineColumn),\n\n    /// L'action de supprimer la possibilité d'une étoile à une case\n    SetNoStar(LineColumn),\n}\n\nimpl Display for GridAction {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::SetUnknown(line_column) =\u003e write!(f, \"{line_column}-\u003e Inconnu\"),\n            Self::SetStar(line_column) =\u003e write!(f, \"{line_column}-\u003eEtoile\"),\n            Self::SetNoStar(line_column) =\u003e write!(f, \"{line_column}-\u003ePas d'étoile\"),\n        }\n    }\n}\n\n/// Affichage d'une liste d'actions\npub fn display_vec_actions(actions: \u0026Vec\u003cGridAction\u003e) -\u003e String {\n    let mut str_actions = String::new();\n    for action in actions {\n        if !str_actions.is_empty() {\n            str_actions.push_str(\", \");\n        }\n        str_actions.push_str(\u0026action.to_string());\n    }\n    str_actions\n}\n\nimpl GridAction {\n    /// Retourne la `LineColumn` correspondant à l'action\n    #[must_use]\n    pub const fn line_column(\u0026self) -\u003e LineColumn {\n        match self {\n            Self::SetUnknown(line_column)\n            | Self::SetStar(line_column)\n            | Self::SetNoStar(line_column) =\u003e *line_column,\n        }\n    }\n\n    /// Retourne la `CellValue` correspondant à l'action\n    #[must_use]\n    pub const fn value(\u0026self) -\u003e CellValue {\n        match self {\n            Self::SetUnknown(_) =\u003e CellValue::Unknown,\n            Self::SetStar(_) =\u003e CellValue::Star,\n            Self::SetNoStar(_) =\u003e CellValue::NoStar,\n        }\n    }\n\n    /// Applique une action à la grille\n    pub fn apply_action(\u0026self, grid: \u0026mut Grid) {\n        match self {\n            Self::SetUnknown(line_column) =\u003e {\n                grid.cell_mut(*line_column).value = CellValue::Unknown;\n            }\n            Self::SetStar(line_column) =\u003e {\n                grid.cell_mut(*line_column).value = CellValue::Star;\n            }\n            Self::SetNoStar(line_column) =\u003e {\n                grid.cell_mut(*line_column).value = CellValue::NoStar;\n            }\n        }\n    }\n}\n\nimpl Grid {\n    /// Applique une action à la grille\n    pub fn apply_action(\u0026mut self, action: \u0026GridAction) {\n        match action {\n            GridAction::SetUnknown(line_column) =\u003e {\n                self.cell_mut(*line_column).value = CellValue::Unknown;\n            }\n            GridAction::SetStar(line_column) =\u003e {\n                self.cell_mut(*line_column).value = CellValue::Star;\n            }\n            GridAction::SetNoStar(line_column) =\u003e {\n                self.cell_mut(*line_column).value = CellValue::NoStar;\n            }\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":24,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":27,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":33,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":34,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":35,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":36,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":37,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":39,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":41,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":17221764975064778548}},{"line":84,"address":[],"length":0,"stats":{"Line":17221764975064778548}},{"line":85,"address":[],"length":0,"stats":{"Line":1836}},{"line":86,"address":[],"length":0,"stats":{"Line":1836}},{"line":88,"address":[],"length":0,"stats":{"Line":15276209936040722439}},{"line":89,"address":[],"length":0,"stats":{"Line":15276209936040722439}},{"line":91,"address":[],"length":0,"stats":{"Line":1945555039024054273}},{"line":92,"address":[],"length":0,"stats":{"Line":1945555039024054273}}],"covered":19,"coverable":38},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_bad_ruler.rs"],"content":"//! Vérification de la validité d'une grille.\r\n//!\r\n//! Ce module déroule les règles de cohérence pour les cases d'un grille et signale les\r\n//! éventuels problèmes détectés dans la construction d'une solution pour la grille.\r\n\r\nuse crate::CellValue;\r\nuse crate::Grid;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\nuse crate::LineColumn;\r\n\r\n/// Erreur de cohérence de la grille\r\n#[derive(thiserror::Error, Debug, PartialEq, Eq)]\r\npub enum BadRuleError {\r\n    /// Etoile adjacente à une autre étoile\r\n    #[error(\"Etoile {0} adjacente à l'étoile {1}\")]\r\n    StarAdjacent(LineColumn, LineColumn),\r\n\r\n    /// Trop d'étoiles dans une 'zone'\r\n    #[error(\"Trop d'étoiles dans '{0}'\")]\r\n    TooManyStarsInZone(GridSurfer),\r\n\r\n    /// Impossible de placer toutes les étoiles dans une 'zone'\r\n    #[error(\"Impossible de placer toutes les étoiles dans '{0}'\")]\r\n    NotEnoughStarsInZone(GridSurfer),\r\n}\r\n\r\n/// Vérification de la validité d'une grille\r\n///\r\n/// ### Errors\r\n/// Retourne un [`BadRuleError`] si la grille n'est pas valide\r\npub fn check_bad_rules(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Result\u003c(), BadRuleError\u003e {\r\n    check_no_star_adjacent(handler, grid)?;\r\n    for region in handler.regions() {\r\n        check_zone(handler, grid, \u0026GridSurfer::Region(region))?;\r\n    }\r\n    for line in 0..handler.nb_lines() {\r\n        check_zone(handler, grid, \u0026GridSurfer::Line(line))?;\r\n    }\r\n    for column in 0..handler.nb_columns() {\r\n        check_zone(handler, grid, \u0026GridSurfer::Column(column))?;\r\n    }\r\n    Ok(())\r\n}\r\n\r\n/// Parcours les cases de la grille pour vérifier qu'aucune étoile n'est adjacent à une autre étoile\r\nfn check_no_star_adjacent(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Result\u003c(), BadRuleError\u003e {\r\n    for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\r\n        let cell = grid.cell(line_column);\r\n        if cell.value == CellValue::Star {\r\n            for adjacent_line_column in handler.adjacent_cells(line_column) {\r\n                let adjacent_cell = grid.cell(adjacent_line_column);\r\n                if adjacent_cell.value == CellValue::Star {\r\n                    return Err(BadRuleError::StarAdjacent(\r\n                        line_column,\r\n                        adjacent_line_column,\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\n/// Vérifie la validité du nombre d'étoile sur une zone (line, colonne ou région).\u003cbr\u003e\r\nfn check_zone(handler: \u0026GridHandler, grid: \u0026Grid, surfer: \u0026GridSurfer) -\u003e Result\u003c(), BadRuleError\u003e {\r\n    let mut nb_stars = 0;\r\n    let mut nb_possible_stars = 0;\r\n\r\n    for line_column in handler.surfer(grid, surfer) {\r\n        match grid.cell(line_column).value {\r\n            CellValue::Star =\u003e nb_stars += 1,\r\n            CellValue::Unknown =\u003e nb_possible_stars += 1,\r\n            CellValue::NoStar =\u003e (),\r\n        }\r\n    }\r\n\r\n    if nb_stars \u003e handler.nb_stars() {\r\n        return Err(BadRuleError::TooManyStarsInZone(surfer.clone()));\r\n    } else if nb_stars + nb_possible_stars \u003c handler.nb_stars() {\r\n        return Err(BadRuleError::NotEnoughStarsInZone(surfer.clone()));\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_no_star_adjacent() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // On place volontairement 2 étoiles dans 2 cases adjacentes de la grille\r\n        grid.cell_mut(LineColumn::new(0, 0)).value = CellValue::Star;\r\n        grid.cell_mut(LineColumn::new(1, 1)).value = CellValue::Star;\r\n\r\n        match check_bad_rules(\u0026grid_handler, \u0026grid) {\r\n            Err(BadRuleError::StarAdjacent(_, _)) =\u003e (),\r\n            _ =\u003e panic!(\"Échec détection de 2 étoiles adjacentes dans la grille\"),\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_too_many_stars_in_region() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement 2 étoiles non adjacentes dans la zone 'B' de la grille\r\n        grid.cell_mut(LineColumn::new(0, 1)).value = CellValue::Star;\r\n        grid.cell_mut(LineColumn::new(0, 4)).value = CellValue::Star;\r\n\r\n        if let Err(BadRuleError::TooManyStarsInZone(GridSurfer::Region(region))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(\r\n                region, 'B',\r\n                \"Échec détection trop d'étoiles dans la région 'B' (region '{region}' identifiée)\"\r\n            );\r\n        } else {\r\n            panic!(\"Échec détection trop d'étoiles dans une région\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_not_enough_stars_in_region() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement pas d'étoile dans les 2 case la zone 'A' de la grille\r\n        grid.cell_mut(LineColumn::new(0, 0)).value = CellValue::NoStar;\r\n        grid.cell_mut(LineColumn::new(1, 0)).value = CellValue::NoStar;\r\n\r\n        if let Err(BadRuleError::NotEnoughStarsInZone(GridSurfer::Region(region))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(region, 'A',\r\n                    \"Échec détection impossible de placer une étoile dans la région 'A' (region '{region}' identifiée)\");\r\n        } else {\r\n            panic!(\"Échec détection impossible de placer une étoile dans une région\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_too_many_stars_in_line() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement 2 étoiles non adjacentes dans 2eme ligne de la grille\r\n        grid.cell_mut(LineColumn::new(1, 0)).value = CellValue::Star;\r\n        grid.cell_mut(LineColumn::new(1, 4)).value = CellValue::Star;\r\n\r\n        if let Err(BadRuleError::TooManyStarsInZone(GridSurfer::Line(line))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(\r\n                line, 1,\r\n                \"Échec détection trop d'étoiles dans la ligne '1' (ligne '{line}' identifiée)\"\r\n            );\r\n        } else {\r\n            panic!(\"Échec détection trop d'étoiles dans une ligne\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_not_enough_stars_in_line() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement pas d'étoile dans les cases de la 2eme ligne de la grille\r\n        for column in 0..grid_handler.nb_columns() {\r\n            grid.cell_mut(LineColumn::new(1, column)).value = CellValue::NoStar;\r\n        }\r\n\r\n        if let Err(BadRuleError::NotEnoughStarsInZone(GridSurfer::Line(line))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(line, 1,\r\n                    \"Échec détection impossible de placer une étoile dans la ligne '1' (ligne '{line}' identifiée)\");\r\n        } else {\r\n            panic!(\"Échec détection impossible de placer une étoile dans une ligne\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_too_many_stars_in_column() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement 2 étoiles non adjacentes dans 2eme colonne de la grille\r\n        grid.cell_mut(LineColumn::new(0, 1)).value = CellValue::Star;\r\n        grid.cell_mut(LineColumn::new(4, 1)).value = CellValue::Star;\r\n\r\n        if let Err(BadRuleError::TooManyStarsInZone(GridSurfer::Column(column))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(\r\n                column, 1,\r\n                \"Échec détection trop d'étoiles dans la colonne '1' (colonne '{column}' identifiée)\"\r\n            );\r\n        } else {\r\n            panic!(\"Échec détection trop d'étoiles dans une colonne\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_not_enough_stars_in_colonne() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        assert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n\r\n        // On définit volontairement pas d'étoile dans les cases de la 2eme colonne de la grille\r\n        for line in 0..grid_handler.nb_lines() {\r\n            grid.cell_mut(LineColumn::new(line, 1)).value = CellValue::NoStar;\r\n        }\r\n\r\n        if let Err(BadRuleError::NotEnoughStarsInZone(GridSurfer::Column(column))) =\r\n            check_bad_rules(\u0026grid_handler, \u0026grid)\r\n        {\r\n            assert_eq!(column, 1,\r\n                    \"Échec détection impossible de placer une étoile dans la colonne '1' (colonne '{column}' identifiée)\");\r\n        } else {\r\n            panic!(\"Échec détection impossible de placer une étoile dans une colonne\");\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":7133701809754865665}},{"line":33,"address":[],"length":0,"stats":{"Line":15852670688344146127}},{"line":34,"address":[],"length":0,"stats":{"Line":10304235947423694775}},{"line":35,"address":[],"length":0,"stats":{"Line":7493989779944505546}},{"line":37,"address":[],"length":0,"stats":{"Line":5116089176692883697}},{"line":38,"address":[],"length":0,"stats":{"Line":6052837899185946750}},{"line":40,"address":[],"length":0,"stats":{"Line":15708555500268292408}},{"line":41,"address":[],"length":0,"stats":{"Line":1369094286720631945}},{"line":43,"address":[],"length":0,"stats":{"Line":14339461213547659269}},{"line":47,"address":[],"length":0,"stats":{"Line":7133701809754866755}},{"line":48,"address":[],"length":0,"stats":{"Line":5980780305148019849}},{"line":49,"address":[],"length":0,"stats":{"Line":17293822569102704710}},{"line":50,"address":[],"length":0,"stats":{"Line":17293822569102704710}},{"line":51,"address":[],"length":0,"stats":{"Line":14051230837395961798}},{"line":52,"address":[],"length":0,"stats":{"Line":9799832789158200049}},{"line":53,"address":[],"length":0,"stats":{"Line":9799832789158200049}},{"line":54,"address":[],"length":0,"stats":{"Line":8718968878589280391}},{"line":55,"address":[],"length":0,"stats":{"Line":8718968878589280391}},{"line":56,"address":[],"length":0,"stats":{"Line":8718968878589280391}},{"line":62,"address":[],"length":0,"stats":{"Line":16861477004875137230}},{"line":66,"address":[],"length":0,"stats":{"Line":12393906174523609737}},{"line":67,"address":[],"length":0,"stats":{"Line":12393906174523609737}},{"line":68,"address":[],"length":0,"stats":{"Line":12393906174523609737}},{"line":70,"address":[],"length":0,"stats":{"Line":13979173243358027764}},{"line":71,"address":[],"length":0,"stats":{"Line":1585267068834418027}},{"line":72,"address":[],"length":0,"stats":{"Line":1729382256910301473}},{"line":73,"address":[],"length":0,"stats":{"Line":5260204364768710019}},{"line":74,"address":[],"length":0,"stats":{"Line":13042424520864958151}},{"line":78,"address":[],"length":0,"stats":{"Line":12393906174523608444}},{"line":79,"address":[],"length":0,"stats":{"Line":9511602413006491004}},{"line":80,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":81,"address":[],"length":0,"stats":{"Line":11457157452030541828}},{"line":84,"address":[],"length":0,"stats":{"Line":9871890383196127244}}],"covered":33,"coverable":33},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_cell.rs"],"content":"//! Case de la grille\n\nuse crate::CellValue;\nuse crate::LineColumn;\nuse crate::Region;\n\n/// Case de la grille\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct GridCell {\n    /// Coordonnées de la case dans la grille\n    pub line_column: LineColumn,\n\n    /// Région de la case\n    pub region: Region,\n\n    /// Valeur de la case\n    pub value: CellValue,\n}\n\nimpl GridCell {\n    /// Retourne `true` si la case n'est pas définie\n    #[must_use]\n    pub fn is_unknown(\u0026self) -\u003e bool {\n        self.value == CellValue::Unknown\n    }\n\n    /// Retourne `true` si la case ne peut pas être une étoile\n    #[must_use]\n    pub fn is_no_star(\u0026self) -\u003e bool {\n        self.value == CellValue::NoStar\n    }\n\n    /// Retourne `true` si la case est une étoile\n    #[must_use]\n    pub fn is_star(\u0026self) -\u003e bool {\n        self.value == CellValue::Star\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":15348267530078650369}},{"line":24,"address":[],"length":0,"stats":{"Line":15348267530078650369}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":12321848580485679380}},{"line":36,"address":[],"length":0,"stats":{"Line":12321848580485679380}}],"covered":4,"coverable":6},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","collector.rs"],"content":"//! Examine toutes les possibilités pour poser les étoiles manquantes dans une zone et recherche\r\n//! si des cases sont invariantes pour toutes ces possibilités.\u003cbr\u003e\r\n\r\nuse crate::check_bad_rules;\r\nuse crate::CellValue;\r\nuse crate::Grid;\r\nuse crate::GridHandler;\r\nuse crate::LineColumn;\r\n\r\n/// Structure pour la recherche des combinaisons possibles qui positionnent\r\n/// le nombre attendu d'étoiles dans une zone.\u003cbr\u003e\r\n///\r\n/// Une zone est ici une région, une ligne, une colonne ou un groupe de lignes ou de colonnes.\r\n///\r\n/// Cette structure propose 2 méthodes pour la recherche des grilles possibles :\r\n///\r\n/// * `collect_possible_grids` : Recherche les combinaisons possibles dans la zone uniquement\r\n/// * `collect_recursive_possible_grids` : Recherche les combinaison de manière récursive en\r\n///   examinant les autres cases des grilles possibles\r\n///\r\n/// Pour cela, cette structure `Collector` s'utilise comme suit :\r\n///\r\n/// - On détermine la zone à examiner pour cette règle. C'est un vecteur de `LineColumn` issu d'un `GridSurfer`\r\n/// - On construit un `collector` pour cette zone `Collector::new(handler, grid, zone, nb_stars)`\r\n/// - On appelle la méthode `collect_possible_grids` ou `collect_recursive_possible_grids` pour rechercher toutes\r\n///   les grilles possibles pour cette zone\r\n///\r\n/// Ensuite, la fonction `Variant::check_for_invariants` permet examiner les différentes grilles possibles\r\n/// pour en extraire d'éventuelles cases invariantes dans toutes les combinaisons\r\npub struct Collector\u003c'a\u003e {\r\n    /// Handler de la grille à étudier\r\n    handler: \u0026'a GridHandler,\r\n\r\n    /// Contenu de la grille à étudier\r\n    grid: \u0026'a Grid,\r\n\r\n    /// Liste des cases de la zone à étudier\r\n    zone: \u0026'a Vec\u003cLineColumn\u003e,\r\n\r\n    /// Nombre d'étoiles à placer dans la zone\r\n    nb_stars: usize,\r\n\r\n    /// Liste des combinaisons de grilles possibles pour placer le nombre d'étoiles demandés dans la zone\r\n    pub possible_grids: Vec\u003cGrid\u003e,\r\n}\r\n\r\nimpl\u003c'a\u003e Collector\u003c'a\u003e {\r\n    /// Constructeur d'une zone à examiner\r\n    pub const fn new(\r\n        handler: \u0026'a GridHandler,\r\n        grid: \u0026'a Grid,\r\n        zone: \u0026'a Vec\u003cLineColumn\u003e,\r\n        nb_stars: usize,\r\n    ) -\u003e Self {\r\n        Self {\r\n            handler,\r\n            grid,\r\n            zone,\r\n            nb_stars,\r\n            possible_grids: Vec::new(),\r\n        }\r\n    }\r\n\r\n    /// Cherche les combinaisons possibles qui positionnent le nombre attendu d'étoiles dans la zone.\r\n    ///\r\n    /// On utilise ici la 'force brute' pour tester toutes les façons de poser les étoiles manquantes\r\n    /// dans la zone.\r\n    ///\r\n    /// S'il y a n étoiles à placer (n \u003e 0) dans les m cases non définies d'une zone,\r\n    /// on explore tous les nombres de 1 à 2**m -1 qui ont n bits à 1 et on positionne des étoiles\r\n    /// dans tous les i-eme cases si me i-eme bit est 1.\r\n    /// Si la grille obtenue est 'viable', on la retient comme combinaison possible.\r\n    pub fn collect_possible_grids(\u0026mut self) {\r\n        let mut cur_nb_stars = 0; // Nombre d'étoiles déjà placées dans la région\r\n        let mut cur_nb_unknown = 0; // Nombre de cases non définies dans la grille\r\n        let mut cur_line_column_unknown = Vec::new(); // Coordonnées des cases non définies dans la région\r\n        for line_column in self.zone {\r\n            match self.grid.cell(*line_column).value {\r\n                CellValue::Star =\u003e cur_nb_stars += 1,\r\n                CellValue::NoStar =\u003e (),\r\n                CellValue::Unknown =\u003e {\r\n                    cur_nb_unknown += 1;\r\n                    cur_line_column_unknown.push(*line_column);\r\n                }\r\n            }\r\n        }\r\n\r\n        if cur_nb_stars \u003e= self.nb_stars {\r\n            // Toutes les étoiles sont placées dans la région.\r\n            // Rien à explorer dans cette région\r\n            return;\r\n        }\r\n\r\n        // Nombre d'étoiles qui restent à placer dans la région\r\n        let nb_to_do_star = self.nb_stars - cur_nb_stars;\r\n\r\n        assert!(\r\n            nb_to_do_star \u003c= cur_nb_unknown,\r\n            \"Situation inattendue lors de l'examen de la région !\"\r\n        );\r\n\r\n        // Boucle sur toutes les façons de poser `nb_to_do_star` étoiles dans les\r\n        // `cur_nb_unknown` cases non définies.\r\n        for combinaison in 1..usize::pow(\r\n            2,\r\n            u32::try_from(cur_nb_unknown).expect(\"Région trop grande (32 cases inconnues max) !\"),\r\n        ) {\r\n            // On a besoin d'autant de bits à 1 dans combinaison qu'on d'étoiles à placer\r\n            if count_ones(combinaison) == nb_to_do_star {\r\n                // On crée un nouvelle grille possible avec toutes les étoiles positionnées dans la région\r\n                let mut new_grid = self.grid.clone();\r\n                for (i, line_column) in cur_line_column_unknown.iter().enumerate() {\r\n                    new_grid.cell_mut(*line_column).value = {\r\n                        if combinaison \u0026 (1 \u003c\u003c i) == 0 {\r\n                            CellValue::NoStar\r\n                        } else {\r\n                            CellValue::Star\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Si cette nouvelle grille est viable... on l'ajoute à la liste des grilles possibles\r\n                if check_bad_rules(self.handler, \u0026new_grid).is_ok() {\r\n                    self.possible_grids.push(new_grid);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Cherche récursivement les combinaisons possibles qui positionnent le nombre attendu d'étoiles dans la zone.\r\n    ///\r\n    /// L'algorithme de recherche 'récursif' avec un cheminement comme suit :\r\n    ///\r\n    /// - On repère la première case possible de la zone qui peut contenir une étoile\r\n    /// - On pose une étoile dans cette case et on recherche les grilles possibles avec cette combinaison.\r\n    ///   Cette recherche se fait en appelant à nouveau le même algorithme de recherche\r\n    /// - Puis, on définit qu'il n'y a pas d'étoile dans cette case et on recherche à nouveau les grilles possibles\r\n    ///   avec cette combinaison. Cette recherche se fait en appelant à nouveau le même algorithme de recherche\r\n    /// - En final, toutes les grilles possibles collectées 'récursivement' sont des grilles possibles pour la zone\r\n    pub fn collect_recursive_possible_grids(\u0026mut self) {\r\n        // Décompte du nombre d'étoiles qui restent à placer dans la zone\r\n        let nb_current_stars = self\r\n            .zone\r\n            .iter()\r\n            .filter(|line_column| self.grid.cell(**line_column).value == CellValue::Star)\r\n            .count();\r\n\r\n        if nb_current_stars == self.nb_stars {\r\n            // Toutes les étoiles sont placées dans la zone\r\n            // La grille courante est la seule possibilité dans ce cas...\r\n            // On complète les cases non définies de cette zone par des cases sans étoile\r\n            let mut new_grid = self.grid.clone();\r\n            for line_column in self.zone {\r\n                if new_grid.cell(*line_column).value == CellValue::Unknown {\r\n                    new_grid.cell_mut(*line_column).value = CellValue::NoStar;\r\n                }\r\n            }\r\n            self.possible_grids.push(new_grid);\r\n            // ...qu'on retourne\r\n            return;\r\n        }\r\n\r\n        // Au moins une étoile est à placer. On cherche la première case possible dans la zone pour cela\r\n        if let Some(line_column) = self.first_possible_line_column_for_a_star() {\r\n            // On construit alors une nouvelle grille possible\r\n            // Et on pose une étoile dans cette case dans une nouvelle grille possible\r\n            // et on invalide la possibilité d'une étoile pour toutes les cases adjacentes\r\n            let mut new_grid = self.grid.clone();\r\n            self.set_star(\u0026mut new_grid, line_column);\r\n            // Si cette nouvelle grille est viable...\r\n            if check_bad_rules(self.handler, \u0026new_grid).is_ok() {\r\n                // ...on recherche les grilles possibles pour cette nouvelle grille\r\n                let mut new_collector =\r\n                    Collector::new(self.handler, \u0026new_grid, self.zone, self.nb_stars);\r\n                new_collector.collect_recursive_possible_grids();\r\n                // Toutes les grilles trouvées par ce nouveau collector sont des grilles possibles pour la grille courante\r\n                self.possible_grids.extend(new_collector.possible_grids);\r\n            }\r\n\r\n            //  Puis on construit une autre grille possible pour la zone sans une étoile dans cette case\r\n            let mut new_grid = self.grid.clone();\r\n            new_grid.cell_mut(line_column).value = CellValue::NoStar;\r\n            // On recherche les grilles possibles pour cette nouvelle grille\r\n            let mut new_collector =\r\n                Collector::new(self.handler, \u0026new_grid, self.zone, self.nb_stars);\r\n            new_collector.collect_recursive_possible_grids();\r\n            // Toutes les grilles trouvées par ce nouveau collector sont des grilles possibles pour la grille courante\r\n            self.possible_grids.extend(new_collector.possible_grids);\r\n        }\r\n\r\n        // On retourne les grilles trouvées jusqu'ici\r\n    }\r\n\r\n    /// Recherche la première case possible pour poser une étoile dans la zone\r\n    fn first_possible_line_column_for_a_star(\u0026self) -\u003e Option\u003cLineColumn\u003e {\r\n        for line_column in self.zone {\r\n            // Case possible pour poser une étoile ?\r\n            if self.grid.cell(*line_column).is_unknown() {\r\n                // Il ne faut pas d'étoiles dans les cases adjacentes à cette case\r\n                if self\r\n                    .handler\r\n                    .adjacent_cells(*line_column)\r\n                    .iter()\r\n                    .filter(|line_column| self.grid.cell(**line_column).value == CellValue::Star)\r\n                    .count()\r\n                    == 0\r\n                {\r\n                    return Some(*line_column);\r\n                }\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Pose une étoile sur une grille possible et indique que toutes les cases autour de cette étoile\r\n    /// ne peuvent pas être une étoile\r\n    fn set_star(\u0026self, new_grid: \u0026mut Grid, line_column: LineColumn) {\r\n        // Pose une étoile dans cette case dans une nouvelle grille possible\r\n        new_grid.cell_mut(line_column).value = CellValue::Star;\r\n        // On indique que toutes les cases autour de cette étoile ne peuvent pas être une étoile\r\n        for adjacent_line_column in self.handler.adjacent_cells(line_column) {\r\n            match self.grid.cell(adjacent_line_column).value {\r\n                CellValue::Star =\u003e panic!(\"Bug dans l'algo !!! La case {adjacent_line_column} ne devrait pas être une étoile\"),\r\n                CellValue::NoStar =\u003e (),\r\n                CellValue::Unknown =\u003e new_grid.cell_mut(adjacent_line_column).value = CellValue::NoStar,\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Compte le nombre de bits à 1 dans un usize\r\nconst fn count_ones(n: usize) -\u003e usize {\r\n    let mut count = 0;\r\n    let mut num = n;\r\n\r\n    while num \u003e 0 {\r\n        count += num \u0026 1; // Ajoute 1 si le bit de poids faible est 1\r\n        num \u003e\u003e= 1; // Décale num vers la droite\r\n    }\r\n\r\n    count\r\n}\r\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":60,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":73,"address":[],"length":0,"stats":{"Line":4899916394579099723}},{"line":74,"address":[],"length":0,"stats":{"Line":4899916394579099723}},{"line":75,"address":[],"length":0,"stats":{"Line":4899916394579099723}},{"line":76,"address":[],"length":0,"stats":{"Line":4899916394579099723}},{"line":77,"address":[],"length":0,"stats":{"Line":13546827679130452142}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":5044031582654955544}},{"line":80,"address":[],"length":0,"stats":{"Line":9583660007044415496}},{"line":81,"address":[],"length":0,"stats":{"Line":8142508126285856771}},{"line":82,"address":[],"length":0,"stats":{"Line":8142508126285856771}},{"line":83,"address":[],"length":0,"stats":{"Line":8142508126285856771}},{"line":88,"address":[],"length":0,"stats":{"Line":4899916394579099694}},{"line":91,"address":[],"length":0,"stats":{"Line":1008806316530991112}},{"line":95,"address":[],"length":0,"stats":{"Line":3891110078048108582}},{"line":97,"address":[],"length":0,"stats":{"Line":3891110078048108582}},{"line":98,"address":[],"length":0,"stats":{"Line":3891110078048108582}},{"line":99,"address":[],"length":0,"stats":{"Line":31}},{"line":104,"address":[],"length":0,"stats":{"Line":6341068275337658382}},{"line":105,"address":[],"length":0,"stats":{"Line":3891110078048108551}},{"line":106,"address":[],"length":0,"stats":{"Line":3891110078048108551}},{"line":109,"address":[],"length":0,"stats":{"Line":2449958197289549831}},{"line":111,"address":[],"length":0,"stats":{"Line":7421932185906642366}},{"line":112,"address":[],"length":0,"stats":{"Line":17365880163140697621}},{"line":113,"address":[],"length":0,"stats":{"Line":9943947977234055255}},{"line":114,"address":[],"length":0,"stats":{"Line":9943947977234055255}},{"line":115,"address":[],"length":0,"stats":{"Line":8070450532247930470}},{"line":117,"address":[],"length":0,"stats":{"Line":1873497444986124785}},{"line":123,"address":[],"length":0,"stats":{"Line":17942340915444056396}},{"line":124,"address":[],"length":0,"stats":{"Line":10520408729537478822}},{"line":140,"address":[],"length":0,"stats":{"Line":2882303761517118748}},{"line":142,"address":[],"length":0,"stats":{"Line":2882303761517118748}},{"line":143,"address":[],"length":0,"stats":{"Line":2882303761517118748}},{"line":145,"address":[],"length":0,"stats":{"Line":6773413839565228600}},{"line":148,"address":[],"length":0,"stats":{"Line":2882303761517118748}},{"line":152,"address":[],"length":0,"stats":{"Line":4107282860161892419}},{"line":153,"address":[],"length":0,"stats":{"Line":12321848580485677224}},{"line":154,"address":[],"length":0,"stats":{"Line":4827858800541171720}},{"line":155,"address":[],"length":0,"stats":{"Line":4827858800541171720}},{"line":158,"address":[],"length":0,"stats":{"Line":4107282860161892362}},{"line":160,"address":[],"length":0,"stats":{"Line":4107282860161892362}},{"line":164,"address":[],"length":0,"stats":{"Line":8574853690513425605}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":13186539708940812308}},{"line":173,"address":[],"length":0,"stats":{"Line":13186539708940812308}},{"line":174,"address":[],"length":0,"stats":{"Line":13186539708940812308}},{"line":175,"address":[],"length":0,"stats":{"Line":13186539708940812308}},{"line":177,"address":[],"length":0,"stats":{"Line":13186539708940812308}},{"line":181,"address":[],"length":0,"stats":{"Line":8574853690513424431}},{"line":182,"address":[],"length":0,"stats":{"Line":8574853690513424431}},{"line":184,"address":[],"length":0,"stats":{"Line":8574853690513424431}},{"line":185,"address":[],"length":0,"stats":{"Line":8574853690513424431}},{"line":186,"address":[],"length":0,"stats":{"Line":8574853690513424431}},{"line":188,"address":[],"length":0,"stats":{"Line":8574853690513424431}},{"line":195,"address":[],"length":0,"stats":{"Line":17221764975064776885}},{"line":196,"address":[],"length":0,"stats":{"Line":12105675798371893393}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":8574853690513424302}},{"line":201,"address":[],"length":0,"stats":{"Line":8574853690513424302}},{"line":202,"address":[],"length":0,"stats":{"Line":8574853690513424302}},{"line":203,"address":[],"length":0,"stats":{"Line":8574853690513424302}},{"line":204,"address":[],"length":0,"stats":{"Line":15348267530078650947}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":8574853690513424394}},{"line":212,"address":[],"length":0,"stats":{"Line":8646911284551352629}},{"line":217,"address":[],"length":0,"stats":{"Line":8574853690513424420}},{"line":219,"address":[],"length":0,"stats":{"Line":8574853690513424420}},{"line":221,"address":[],"length":0,"stats":{"Line":15348267530078650440}},{"line":222,"address":[],"length":0,"stats":{"Line":6773413839565226020}},{"line":223,"address":[],"length":0,"stats":{"Line":237}},{"line":224,"address":[],"length":0,"stats":{"Line":13042424520864956416}},{"line":225,"address":[],"length":0,"stats":{"Line":12177733392409820983}},{"line":232,"address":[],"length":0,"stats":{"Line":2449958197289549950}},{"line":233,"address":[],"length":0,"stats":{"Line":2449958197289549950}},{"line":234,"address":[],"length":0,"stats":{"Line":2449958197289549950}},{"line":236,"address":[],"length":0,"stats":{"Line":2161727821137968122}},{"line":237,"address":[],"length":0,"stats":{"Line":18302628885633760702}},{"line":238,"address":[],"length":0,"stats":{"Line":18302628885633760702}},{"line":241,"address":[],"length":0,"stats":{"Line":2449958197289549950}}],"covered":76,"coverable":82},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","good_rule.rs"],"content":"//! Règles de construction/résolution d'une grille.\n//!\n//! Ce module expose les différentes règles permettant d'avancer dans la résolution d'une grille.\n\nuse std::fmt::Display;\n\nuse crate::check_bad_rules;\nuse crate::grid_action::display_vec_actions;\nuse crate::BadRuleError;\nuse crate::Grid;\nuse crate::GridAction;\nuse crate::GridHandler;\nuse crate::GridSurfer;\nuse crate::LineColumn;\nuse crate::Region;\n\nuse super::rule_no_star_adjacent_to_star::rule_no_star_adjacent_to_star;\nuse super::rule_region_combinations::{\n    rule_region_1_combinations, rule_region_2_combinations, rule_region_3_combinations,\n    rule_region_4_combinations,\n};\nuse super::rule_region_exclusions::{\n    rule_region_1_exclusions, rule_region_2_exclusions, rule_region_3_exclusions,\n    rule_region_4_exclusions,\n};\nuse super::rule_region_possible_stars::rule_region_possible_stars;\nuse super::rule_value_completed::rule_value_completed;\nuse super::rule_zone_possible_stars::{\n    rule_line_column_recursive_possible_stars, rule_multi_2_lines_columns_recursive_possible_stars,\n    rule_multi_3_lines_columns_recursive_possible_stars,\n    rule_multi_4_lines_columns_recursive_possible_stars, rule_region_recursive_possible_stars,\n};\n\n/// Énumération des règles applicables à la construction/résolution d'une grille\n#[derive(Clone, Debug)]\npub enum GoodRule {\n    /// Indique les cases adjacentes à une étoile qui ne peuvent pas contenir une étoile\n    NoStarAdjacentToStar(LineColumn, Vec\u003cGridAction\u003e),\n\n    /// Indique les cases restantes dans une zone ne peuvent pas être des étoiles\n    ZoneNoStarCompleted(GridSurfer, Vec\u003cGridAction\u003e),\n\n    /// Indique que les cases restantes des régions en dehors d'une combinaison de lignes ou colonnes\n    /// ne peuvent pas contenir des étoiles\n    ZoneExclusions(Vec\u003cRegion\u003e, GridSurfer, Vec\u003cGridAction\u003e),\n\n    /// Indique que les cases restantes en dehors d'une combinaison de régions/lignes ou colonnes\n    /// ne peuvent pas contenir des étoiles\n    ZoneCombinations(Vec\u003cRegion\u003e, GridSurfer, Vec\u003cGridAction\u003e),\n\n    /// Indique les cases restantes dans une zone sont forcement des étoiles\n    ZoneStarCompleted(GridSurfer, Vec\u003cGridAction\u003e),\n\n    /// Indique que quelle que soit la façon de placer les étoiles dans une zone, des cases n'ont\n    /// toujours qu'une seule et même possibilité\n    InvariantWithZone(GridSurfer, Vec\u003cGridAction\u003e),\n}\n\nimpl Display for GoodRule {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        // Texte pour une ligne de régions\n        fn display_vec_regions(regions: \u0026[Region]) -\u003e String {\n            let mut str_regions = String::new();\n            for region in regions {\n                if !str_regions.is_empty() {\n                    str_regions.push('+');\n                }\n                str_regions.push(*region);\n            }\n            str_regions\n        }\n\n        match self {\n            Self::NoStarAdjacentToStar(line_column, actions) =\u003e {\n                write!(f, \"Les cases adjacentes à l'étoile en {line_column} ne peuvent pas contenir une étoile : {}\", display_vec_actions(actions))\n            }\n            Self::ZoneNoStarCompleted(grid_surfer, actions) =\u003e {\n                write!(\n                    f,\n                    \"Les cases restantes pour {grid_surfer} ne peuvent pas contenir une étoile : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n            Self::ZoneExclusions(regions, grid_surfer, actions) =\u003e {\n                let str_regions = display_vec_regions(regions);\n                write!(\n                    f,\n                    \"Les cases restantes des regions {str_regions} qui ne sont pas dans {grid_surfer} ne peuvent être une étoile : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n            Self::ZoneCombinations(regions, grid_surfer, actions) =\u003e {\n                let str_regions = display_vec_regions(regions);\n                write!(\n                    f,\n                    \"Les cases restantes sur {grid_surfer} qui ne sont pas dans les régions {str_regions} ne peuvent être une étoile : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n            Self::ZoneStarCompleted(grid_surfer, actions) =\u003e {\n                write!(\n                    f,\n                    \"Les cases restantes pour {grid_surfer} peuvent être qu'une étoile : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n            Self::InvariantWithZone(surfer, actions) =\u003e {\n                write!(\n                    f,\n                    \"Toutes les possibilités pour {surfer} impliquent la seule possibilité : {}\",\n                    display_vec_actions(actions)\n                )\n            }\n        }\n    }\n}\n\nimpl Grid {\n    /// Application d'une règle de construction sur une grille\n    pub fn apply_good_rule(\u0026mut self, rule: \u0026GoodRule) {\n        match rule {\n            GoodRule::NoStarAdjacentToStar(_, actions)\n            | GoodRule::ZoneNoStarCompleted(_, actions)\n            | GoodRule::ZoneExclusions(_, _, actions)\n            | GoodRule::ZoneCombinations(_, _, actions)\n            | GoodRule::ZoneStarCompleted(_, actions)\n            | GoodRule::InvariantWithZone(_, actions) =\u003e {\n                for action in actions {\n                    self.apply_action(action);\n                }\n            }\n        }\n    }\n}\n\n/// Identification d'une règle de construction applicable à la grille.\u003cbr\u003e\n/// Retourne une règle applicable à la construction/résolution de la grille si trouvé. None sinon.\n/// ### Errors\n/// Retourne un [`BadRuleError`] si la grille n'est pas valide\n#[allow(clippy::module_name_repetitions)]\npub fn get_good_rule(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Result\u003cOption\u003cGoodRule\u003e, BadRuleError\u003e {\n    // Grille viable ?\n    check_bad_rules(handler, grid)?;\n\n    // Grille terminée ?\n    if handler.is_done(grid) {\n        return Ok(None);\n    }\n\n    for f in [\n        rule_no_star_adjacent_to_star,\n        rule_value_completed,\n        rule_region_1_exclusions,\n        rule_region_1_combinations,\n        rule_region_possible_stars,\n        rule_region_2_exclusions,\n        rule_region_2_combinations,\n        rule_region_recursive_possible_stars,\n        rule_region_3_exclusions,\n        rule_region_3_combinations,\n        rule_line_column_recursive_possible_stars,\n        rule_region_4_exclusions,\n        rule_region_4_combinations,\n        rule_multi_2_lines_columns_recursive_possible_stars,\n        rule_multi_3_lines_columns_recursive_possible_stars,\n        rule_multi_4_lines_columns_recursive_possible_stars,\n    ] {\n        if let Some(rule) = f(handler, grid) {\n            return Ok(Some(rule));\n        }\n    }\n\n    Ok(None)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::fs::File;\n    use std::io::Read;\n\n    use crate::GridParser;\n\n    // Liste des grilles d'exemple\n    const TEST_GRIDS_FILENAME_AND_NB_STARS: \u0026[(\u0026str, usize)] = \u0026[\n        (\"./test_grids/test01.txt\", 1),\n        (\"./test_grids/facile01_2.txt\", 2),\n        (\"./test_grids/moyen01_2.txt\", 2),\n        (\"./test_grids/difficile01_2.txt\", 2),\n        (\"./test_grids/expert01_2.txt\", 2),\n        (\"./test_grids/facile02_2.txt\", 2),\n        (\"./test_grids/moyen02_2.txt\", 2),\n        (\"./test_grids/difficile02_2.txt\", 2),\n        (\"./test_grids/expert02_2.txt\", 2),\n        (\"./test_grids/facile03_2.txt\", 2),\n        (\"./test_grids/moyen03_2.txt\", 2),\n        (\"./test_grids/difficile03_2.txt\", 2),\n        (\"./test_grids/expert03_2.txt\", 2),\n        (\"./test_grids/facile04_2.txt\", 2),\n        (\"./test_grids/moyen04_2.txt\", 2),\n        (\"./test_grids/difficile04_2.txt\", 2),\n        (\"./test_grids/expert04_2.txt\", 2),\n    ];\n\n    // #[test]\n    // fn test_grid_dd_debug() {\n    //     test_all_test_grids(\"facile03\");\n    // }\n\n    #[test]\n    fn test_grid_test() {\n        test_all_test_grids(\"test\");\n    }\n\n    #[test]\n    fn test_grid_facile() {\n        test_all_test_grids(\"facile\");\n    }\n\n    #[test]\n    fn test_grid_moyen() {\n        test_all_test_grids(\"moyen\");\n    }\n\n    #[test]\n    fn test_grid_difficile() {\n        test_all_test_grids(\"difficile\");\n    }\n\n    #[test]\n    fn test_grid_expert() {\n        test_all_test_grids(\"expert\");\n    }\n\n    /// Primitive générique qui teste les grilles de tests dont le nom de leur fichier contient\n    /// la chaîne `filename_part`\n    /// (Evite de tout tester silencieusement car c'est un peu long...)\n    fn test_all_test_grids(filename_part: \u0026str) {\n        for (grid_file_name, nb_stars) in TEST_GRIDS_FILENAME_AND_NB_STARS {\n            if grid_file_name.contains(filename_part) {\n                // Ouverture du fichier\n                println!(\"Fichier : {grid_file_name}\");\n                let mut file = File::open(grid_file_name).unwrap();\n                // Lecture du fichier\n                let mut file_contents = String::new();\n                file.read_to_string(\u0026mut file_contents).unwrap();\n                // Conversion en Grid\n                let grid_parser = GridParser::try_from(file_contents.as_str()).unwrap();\n                let grid_handler = GridHandler::new(\u0026grid_parser, *nb_stars);\n                let mut grid = Grid::from(\u0026grid_handler);\n                // Boucle de résolution\n                loop {\n                    match get_good_rule(\u0026grid_handler, \u0026grid) {\n                        Ok(option_good_rule) =\u003e {\n                            if option_good_rule.is_some() {\n                                let good_rule = option_good_rule.unwrap();\n                                grid.apply_good_rule(\u0026good_rule);\n                            } else {\n                                break;\n                            }\n                        }\n                        Err(bad_rule) =\u003e {\n                            panic!(\"{bad_rule} !!!\");\n                        }\n                    }\n                }\n\n                println!(\n                    \"\\nFILE {grid_file_name}\\n{}\",\n                    grid_handler.display(\u0026grid, true)\n                );\n                assert!(grid_handler.is_done(\u0026grid));\n            }\n        }\n    }\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":108,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":109,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":111,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":120,"address":[],"length":0,"stats":{"Line":3819052484010180614}},{"line":121,"address":[],"length":0,"stats":{"Line":3819052484010180614}},{"line":122,"address":[],"length":0,"stats":{"Line":14843864371813154819}},{"line":123,"address":[],"length":0,"stats":{"Line":6557241057451442179}},{"line":124,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":125,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":126,"address":[],"length":0,"stats":{"Line":17942340915444056064}},{"line":127,"address":[],"length":0,"stats":{"Line":16357073846609641472}},{"line":128,"address":[],"length":0,"stats":{"Line":12754194144713244678}},{"line":129,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":141,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":143,"address":[],"length":0,"stats":{"Line":4971973988617027587}},{"line":146,"address":[],"length":0,"stats":{"Line":4971973988617027581}},{"line":147,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":150,"address":[],"length":0,"stats":{"Line":6124895493223874560}},{"line":168,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":169,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":173,"address":[],"length":0,"stats":{"Line":3}}],"covered":24,"coverable":51},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","invariant.rs"],"content":"//! Recherche des cases invariantes dans une collection de grilles\r\n\r\nuse crate::CellValue;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\n\r\n/// Énumération de la situation pour les cases possiblement variantes dans toutes les\r\n/// combinaisons possibles de grilles\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\npub enum Variant {\r\n    // Case initialement inconnue\r\n    Init,\r\n\r\n    // Case vue comme une étoile dans une des grilles possibles\r\n    Star,\r\n\r\n    // Case vue comme sans étoile dans une des grilles possibles\r\n    NoStar,\r\n\r\n    // Case vue comme inconnue dans une des grilles possibles\r\n    Unknown,\r\n\r\n    // Case vue avec différentes possibilités dans les grilles possibles\r\n    Variable,\r\n}\r\n\r\nimpl Variant {\r\n    /// Retourne l'état `Variant` résultant de la combinaison de 2 `Variant`\r\n    pub const fn combine(self, other: Self) -\u003e Self {\r\n        match (self, other) {\r\n            /* Toutes les cases combinées avec un Variant::Init devient l'autre variant */\r\n            /* Une Variant::Star ne peut se combiner qu'avec un autre Variant::Star sinon c'est Variant::Variant */\r\n            /* Idem pour les Variant::NoStar */\r\n            /* Idem pour les Variant::Unknown */\r\n            /* Les Variant::Variant ne peuvent que rester Variant::Variant */\r\n            (Self::Init, other) | (other, Self::Init) =\u003e other,\r\n            (Self::Star, Self::Star) =\u003e Self::Star,\r\n            (Self::NoStar, Self::NoStar) =\u003e Self::NoStar,\r\n            (Self::Unknown, Self::Unknown) =\u003e Self::Unknown,\r\n            (Self::Star | Self::NoStar | Self::Unknown | Self::Variable, _) =\u003e Self::Variable,\r\n        }\r\n    }\r\n\r\n    /// Examine un ensemble des grilles possibles collectées à partir d'une grille initiale à la recherche\r\n    /// de cases invariantes pour toutes les possibilités de grilles\r\n    pub fn check_for_invariants(\r\n        handler: \u0026GridHandler,\r\n        grid: \u0026Grid,\r\n        possible_grids: \u0026Vec\u003cGrid\u003e,\r\n    ) -\u003e Vec\u003cGridAction\u003e {\r\n        // Liste des cases non déterminées dans la grille initiale\r\n        let mut cells = Vec::new();\r\n        // Liste des 'Variant' de ces cases\r\n        let mut variants = Vec::new();\r\n        for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\r\n            if grid.cell(line_column).is_unknown() {\r\n                cells.push(line_column);\r\n                variants.push(Self::Init);\r\n            }\r\n        }\r\n\r\n        // Parcours de toutes les grilles possibles collectées\r\n        for grid in possible_grids {\r\n            // On combine toutes les cases à examiner avec ce qu'on a déjà observé\r\n            for (line_column, variant) in cells.iter().zip(variants.iter_mut()) {\r\n                let prev_variant = *variant;\r\n                let new_variant = prev_variant.combine(match grid.cell(*line_column).value {\r\n                    CellValue::Star =\u003e Self::Star,\r\n                    CellValue::NoStar =\u003e Self::NoStar,\r\n                    CellValue::Unknown =\u003e Self::Unknown,\r\n                });\r\n                *variant = new_variant;\r\n            }\r\n        }\r\n\r\n        // Liste des invariants dans toutes les grilles examinées\r\n        let mut invariants_actions = Vec::new();\r\n        for (line_column, variant) in cells.iter().zip(variants.iter()) {\r\n            match variant {\r\n                Self::Star =\u003e {\r\n                    /* Cette case est toujours une étoile dans toutes les grilles possibles */\r\n                    invariants_actions.push(GridAction::SetStar(*line_column));\r\n                }\r\n                Self::NoStar =\u003e {\r\n                    /* Cette case n'est jamais une étoile dans toutes les grilles possibles */\r\n                    invariants_actions.push(GridAction::SetNoStar(*line_column));\r\n                }\r\n                _ =\u003e (),\r\n            }\r\n        }\r\n\r\n        invariants_actions\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_combine_variants() {\r\n        let expected = vec![\r\n            /* (variant1, variant2), expected variant1.combine(variant2) */\r\n\r\n            /* Toutes les cases combinées avec un Variant::Init devient l'autre variant */\r\n            ((Variant::Init, Variant::Init), Variant::Init),\r\n            ((Variant::Init, Variant::Star), Variant::Star),\r\n            ((Variant::Init, Variant::NoStar), Variant::NoStar),\r\n            ((Variant::Init, Variant::Unknown), Variant::Unknown),\r\n            ((Variant::Init, Variant::Variable), Variant::Variable),\r\n            ((Variant::Star, Variant::Init), Variant::Star),\r\n            ((Variant::NoStar, Variant::Init), Variant::NoStar),\r\n            ((Variant::Unknown, Variant::Init), Variant::Unknown),\r\n            ((Variant::Variable, Variant::Init), Variant::Variable),\r\n            /* Une Variant::Star ne peut se combiner qu'avec un autre Variant::Star sinon c'est Variant::Variant */\r\n            ((Variant::Star, Variant::Star), Variant::Star),\r\n            ((Variant::Star, Variant::NoStar), Variant::Variable),\r\n            ((Variant::Star, Variant::Unknown), Variant::Variable),\r\n            ((Variant::Star, Variant::Variable), Variant::Variable),\r\n            /* Une Variant::NoStar ne peut se combiner qu'avec un autre Variant::NoStar sinon c'est Variant::Variant */\r\n            ((Variant::NoStar, Variant::Star), Variant::Variable),\r\n            ((Variant::NoStar, Variant::NoStar), Variant::NoStar),\r\n            ((Variant::NoStar, Variant::Unknown), Variant::Variable),\r\n            ((Variant::NoStar, Variant::Variable), Variant::Variable),\r\n            /* Une Variant::Unknown ne peut se combiner qu'avec un autre Variant::Unknown sinon c'est Variant::Variant */\r\n            ((Variant::Unknown, Variant::Star), Variant::Variable),\r\n            ((Variant::Unknown, Variant::NoStar), Variant::Variable),\r\n            ((Variant::Unknown, Variant::Unknown), Variant::Unknown),\r\n            ((Variant::Unknown, Variant::Variable), Variant::Variable),\r\n            /* Les Variant::Variant ne peuvent que rester Variant::Variant */\r\n            ((Variant::Variable, Variant::Star), Variant::Variable),\r\n            ((Variant::Variable, Variant::NoStar), Variant::Variable),\r\n            ((Variant::Variable, Variant::Unknown), Variant::Variable),\r\n            ((Variant::Variable, Variant::Variable), Variant::Variable),\r\n        ];\r\n\r\n        for ((v1, v2), expected) in expected {\r\n            assert_eq!(v1.combine(v2), expected);\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":32,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":38,"address":[],"length":0,"stats":{"Line":2594073385365404676}},{"line":39,"address":[],"length":0,"stats":{"Line":12465963768561533173}},{"line":40,"address":[],"length":0,"stats":{"Line":15420325124116582988}},{"line":41,"address":[],"length":0,"stats":{"Line":5260204364768740190}},{"line":42,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":48,"address":[],"length":0,"stats":{"Line":4467570830351532042}},{"line":54,"address":[],"length":0,"stats":{"Line":4467570830351532042}},{"line":56,"address":[],"length":0,"stats":{"Line":4467570830351532042}},{"line":57,"address":[],"length":0,"stats":{"Line":10088063165309911061}},{"line":58,"address":[],"length":0,"stats":{"Line":13618885273168380810}},{"line":59,"address":[],"length":0,"stats":{"Line":7998392938210001791}},{"line":60,"address":[],"length":0,"stats":{"Line":7998392938210001791}},{"line":65,"address":[],"length":0,"stats":{"Line":15276209936040723439}},{"line":67,"address":[],"length":0,"stats":{"Line":864691128455135243}},{"line":68,"address":[],"length":0,"stats":{"Line":864691128455135243}},{"line":69,"address":[],"length":0,"stats":{"Line":1729382256910270486}},{"line":70,"address":[],"length":0,"stats":{"Line":17365880163140638889}},{"line":71,"address":[],"length":0,"stats":{"Line":14987979559889010897}},{"line":72,"address":[],"length":0,"stats":{"Line":5404319552844588689}},{"line":79,"address":[],"length":0,"stats":{"Line":4467570830351532139}},{"line":80,"address":[],"length":0,"stats":{"Line":12465963768561533046}},{"line":81,"address":[],"length":0,"stats":{"Line":7998392938210000907}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927398}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927398}},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927398}},{"line":86,"address":[],"length":0,"stats":{"Line":4107282860161892898}},{"line":87,"address":[],"length":0,"stats":{"Line":4107282860161892898}},{"line":88,"address":[],"length":0,"stats":{"Line":4107282860161892898}},{"line":90,"address":[],"length":0,"stats":{"Line":3819052484010180611}},{"line":94,"address":[],"length":0,"stats":{"Line":4467570830351532949}}],"covered":32,"coverable":32},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","mod.rs"],"content":"//! Gestion des règles de construction/résolution d'une grille\r\n\r\nmod collector;\r\nmod good_rule;\r\nmod invariant;\r\nmod rule_generic_possible_stars;\r\nmod rule_no_star_adjacent_to_star;\r\nmod rule_region_combinations;\r\nmod rule_region_exclusions;\r\nmod rule_region_possible_stars;\r\nmod rule_value_completed;\r\nmod rule_zone_possible_stars;\r\nmod star_adjacent;\r\n\r\npub use good_rule::{get_good_rule, GoodRule};\r\nuse rule_generic_possible_stars::{rule_generic_possible_stars, ZoneToExamine};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_generic_possible_stars.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche générique des cases invariantes pour toutes les combinaisons possibles d'une zone.\r\n//!\r\n\r\nuse crate::CellValue;\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\n\r\nuse super::collector::Collector;\r\nuse super::invariant::Variant;\r\nuse super::star_adjacent::StarAdjacent;\r\n\r\n/// Énumération des différentes zones possibles pour être examinées\r\n#[derive(Debug, PartialEq, Eq, Clone, Copy)]\r\npub enum ZoneToExamine {\r\n    Region,\r\n    LineAndColumn,\r\n    MultipleLinesAndColumns(usize),\r\n}\r\n\r\n/// Méthode générique qui cherche toutes les combinaisons possibles dans les différentes zones ou régions\r\npub fn rule_generic_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    zone_to_examine: ZoneToExamine,\r\n    recursive: bool,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    // Pour simplifier la règle présentée à un humain, on retient la région qui génère un minimum\r\n    // de grilles pour placer toutes les étoiles\r\n    #[derive(Debug, Default)]\r\n    struct BestCollector {\r\n        grid_surfer: Option\u003cGridSurfer\u003e,\r\n        nb_possible_grids: usize,\r\n        invariant_actions: Vec\u003cGridAction\u003e,\r\n    }\r\n\r\n    // zones: [(GridSurfer, nb_stars, combinaisons_count)]\r\n    let mut zones = Vec::new();\r\n\r\n    // Closure pour compléter la liste des zones à examiner (évite les répétitions de paramètres)\r\n    let mut add_zone = |grid_surfer: GridSurfer, nb_stars: usize| {\r\n        let nb_combinaisons = combinaisons_count(handler, grid, \u0026grid_surfer, nb_stars);\r\n        zones.push((grid_surfer, nb_stars, nb_combinaisons));\r\n    };\r\n\r\n    match zone_to_examine {\r\n        ZoneToExamine::Region =\u003e {\r\n            // Parcours de toutes les régions\r\n            for region in handler.regions() {\r\n                add_zone(GridSurfer::Region(region), handler.nb_stars());\r\n            }\r\n        }\r\n        ZoneToExamine::LineAndColumn =\u003e {\r\n            // Parcours de toutes les lignes\r\n            for line in 0..handler.nb_lines() {\r\n                add_zone(GridSurfer::Line(line), handler.nb_stars());\r\n            }\r\n            // Parcours de toutes les colonnes\r\n            for column in 0..handler.nb_columns() {\r\n                add_zone(GridSurfer::Column(column), handler.nb_stars());\r\n            }\r\n        }\r\n        ZoneToExamine::MultipleLinesAndColumns(2) =\u003e {\r\n            // Double-lignes\r\n            for line in 0..handler.nb_lines() - 1 {\r\n                add_zone(GridSurfer::Lines(line..=line + 1), 2 * handler.nb_stars());\r\n            }\r\n\r\n            // Double-colonnes\r\n            for column in 0..handler.nb_columns() - 1 {\r\n                add_zone(\r\n                    GridSurfer::Columns(column..=column + 1),\r\n                    2 * handler.nb_stars(),\r\n                );\r\n            }\r\n        }\r\n        ZoneToExamine::MultipleLinesAndColumns(3) =\u003e {\r\n            // Double-lignes\r\n            for line in 0..handler.nb_lines() - 2 {\r\n                add_zone(GridSurfer::Lines(line..=line + 2), 3 * handler.nb_stars());\r\n            }\r\n\r\n            // Double-colonnes\r\n            for column in 0..handler.nb_columns() - 2 {\r\n                add_zone(\r\n                    GridSurfer::Columns(column..=column + 2),\r\n                    3 * handler.nb_stars(),\r\n                );\r\n            }\r\n        }\r\n        ZoneToExamine::MultipleLinesAndColumns(4) =\u003e {\r\n            // Double-lignes\r\n            for line in 0..handler.nb_lines() - 3 {\r\n                add_zone(GridSurfer::Lines(line..=line + 3), 4 * handler.nb_stars());\r\n            }\r\n\r\n            // Double-colonnes\r\n            for column in 0..handler.nb_columns() - 3 {\r\n                add_zone(\r\n                    GridSurfer::Columns(column..=column + 3),\r\n                    4 * handler.nb_stars(),\r\n                );\r\n            }\r\n        }\r\n        ZoneToExamine::MultipleLinesAndColumns(_) =\u003e {\r\n            todo!(\r\n                \"rule_multi_lines_columns_recursive_possible_stars pour plus de 4 lignes/colonnes\"\r\n            )\r\n        }\r\n    }\r\n\r\n    // Tri des différentes zones par ordre croissant de combinaisons possible\r\n    zones.sort_by(|a, b| a.2.cmp(\u0026b.2));\r\n\r\n    let mut best_collector = BestCollector::default();\r\n    // Examine les différentes zones\r\n    for (grid_surfer, nb_stars, _) in zones {\r\n        let (invariant_actions, nb_possible_grids) =\r\n            try_star_complete(handler, grid, \u0026grid_surfer, nb_stars, recursive);\r\n        if !invariant_actions.is_empty()\r\n        // La règle s'applique pour cette zone...\r\n            \u0026\u0026 (best_collector.grid_surfer.is_none()\r\n            // ... et c'est la première zone qui permet d'appliquer la règle...\r\n                || nb_possible_grids \u003c best_collector.nb_possible_grids)\r\n        // ... ou le nombre de grilles possibles est moindre que ce qu'on a déjà vu\r\n        {\r\n            best_collector = BestCollector {\r\n                grid_surfer: Some(grid_surfer),\r\n                nb_possible_grids,\r\n                invariant_actions,\r\n            };\r\n        }\r\n    }\r\n    // Règle trouvée ?\r\n    if best_collector.grid_surfer.is_some() {\r\n        Some(GoodRule::InvariantWithZone(\r\n            best_collector.grid_surfer.unwrap(),\r\n            best_collector.invariant_actions,\r\n        ))\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n/// Calcul le nombre de combinaisons possible pour placer toutes les étoiles dans une zone\r\nfn combinaisons_count(\r\n    grid_handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    grid_surfer: \u0026GridSurfer,\r\n    nb_stars: usize,\r\n) -\u003e usize {\r\n    // Nombre d'étoiles déjà placées dans la zone\r\n    let cur_nb_stars =\r\n        grid_handler.surfer_cells_with_value_count(grid, grid_surfer, \u0026CellValue::Star);\r\n    if cur_nb_stars \u003e= nb_stars {\r\n        return usize::MAX; // Pas de combinaison possible\r\n    }\r\n    // Nombre d'étoiles restant à placer dans la zone\r\n    let nb_stars_left = nb_stars - cur_nb_stars;\r\n    // Nombre de case non définies dans la zone\r\n    let mut nb_cells =\r\n        grid_handler.surfer_cells_with_value_count(grid, grid_surfer, \u0026CellValue::Unknown);\r\n    if nb_cells \u003c= nb_stars_left {\r\n        return 0; // Pas de combinaison possible\r\n    }\r\n    let mut nb_combinaisons = 1;\r\n    for _ in 0..nb_stars_left {\r\n        // Pour chaque étoile restant à placer, on ajoute le nombre de combinaisons possible\r\n        nb_combinaisons *= nb_cells;\r\n        nb_cells -= 1;\r\n    }\r\n    nb_combinaisons\r\n}\r\n\r\n/// Vérifie si la règle est applicable sur la région définie.\u003cbr\u003e\r\n/// Si applicable, retourne la liste des actions déduites par la règle et le nombre de grilles possibles\r\n/// qui ont été examinées pour ces actions\r\nfn try_star_complete(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    grid_surfer: \u0026GridSurfer,\r\n    nb_stars: usize,\r\n    recursive: bool,\r\n) -\u003e (Vec\u003cGridAction\u003e, usize) {\r\n    let surfer = handler.surfer(grid, grid_surfer);\r\n    let mut collector = Collector::new(handler, grid, \u0026surfer, nb_stars);\r\n    if recursive {\r\n        collector.collect_recursive_possible_grids();\r\n    } else {\r\n        collector.collect_possible_grids();\r\n    }\r\n    // Liste des invariants dans la région pour toutes les grilles possibles\r\n    let mut invariants = Variant::check_for_invariants(handler, grid, \u0026collector.possible_grids);\r\n    // Qu'on complète avec les cases autour des régions qui sont toujours adjacentes à une étoile dans la\r\n    // région pour toutes les grilles possibles (et qui ne sont pas déjà présentes dans les invariants)\r\n    let star_adjacents =\r\n        StarAdjacent::check_for_star_adjacents(handler, grid, \u0026collector.possible_grids);\r\n    for action in star_adjacents {\r\n        if !invariants.contains(\u0026action) {\r\n            invariants.push(action);\r\n        }\r\n    }\r\n    (invariants, collector.possible_grids.len())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n    use crate::LineColumn;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_combinaisons_count() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // La zone A contient 2 cases non définies =\u003e 2 combinaisons pour placer une étoile\r\n        assert_eq!(\r\n            combinaisons_count(\u0026grid_handler, \u0026grid, \u0026GridSurfer::Region('A'), 1),\r\n            2\r\n        );\r\n\r\n        // La ligne 0 contient 5 cases non définies =\u003e 5 x 4 = 20 combinaisons pour placer 2 étoiles\r\n        assert_eq!(\r\n            combinaisons_count(\u0026grid_handler, \u0026grid, \u0026GridSurfer::Line(0), 2),\r\n            20\r\n        );\r\n\r\n        // On place une étoile en (0, 0)\r\n        grid.cell_mut(LineColumn::new(0, 0)).value = CellValue::Star;\r\n\r\n        // La colonne 0 contient 1 étoiles et 4 cases non définies =\u003e 4 combinaisons pour placer 2 étoiles\r\n        assert_eq!(\r\n            combinaisons_count(\u0026grid_handler, \u0026grid, \u0026GridSurfer::Column(0), 2),\r\n            4\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":3602879701896396807}},{"line":42,"address":[],"length":0,"stats":{"Line":3602879701896396807}},{"line":45,"address":[],"length":0,"stats":{"Line":8070450532247928849}},{"line":46,"address":[],"length":0,"stats":{"Line":4467570830351532042}},{"line":47,"address":[],"length":0,"stats":{"Line":4467570830351532042}},{"line":50,"address":[],"length":0,"stats":{"Line":3602879701896396807}},{"line":53,"address":[],"length":0,"stats":{"Line":3026418949592973320}},{"line":54,"address":[],"length":0,"stats":{"Line":432345564227567617}},{"line":59,"address":[],"length":0,"stats":{"Line":5476377146882523137}},{"line":60,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":63,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":64,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":20}},{"line":98,"address":[],"length":0,"stats":{"Line":10}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":13546827679130451979}},{"line":121,"address":[],"length":0,"stats":{"Line":12538021362599460882}},{"line":126,"address":[],"length":0,"stats":{"Line":10304235947423694857}},{"line":128,"address":[],"length":0,"stats":{"Line":12393906174523605000}},{"line":131,"address":[],"length":0,"stats":{"Line":1152921504606846977}},{"line":132,"address":[],"length":0,"stats":{"Line":1152921504606846977}},{"line":133,"address":[],"length":0,"stats":{"Line":1152921504606846977}},{"line":134,"address":[],"length":0,"stats":{"Line":1152921504606846977}},{"line":139,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":140,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":141,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":142,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":145,"address":[],"length":0,"stats":{"Line":5692549928996306943}},{"line":150,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":157,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":158,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":159,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":160,"address":[],"length":0,"stats":{"Line":7061644215716937739}},{"line":163,"address":[],"length":0,"stats":{"Line":16068843470457929717}},{"line":165,"address":[],"length":0,"stats":{"Line":16068843470457929717}},{"line":166,"address":[],"length":0,"stats":{"Line":16068843470457929717}},{"line":167,"address":[],"length":0,"stats":{"Line":16068843470457929717}},{"line":168,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":170,"address":[],"length":0,"stats":{"Line":15996785876420001780}},{"line":171,"address":[],"length":0,"stats":{"Line":10448351135499550717}},{"line":173,"address":[],"length":0,"stats":{"Line":12898309332789100553}},{"line":174,"address":[],"length":0,"stats":{"Line":12898309332789100553}},{"line":176,"address":[],"length":0,"stats":{"Line":15996785876420001792}},{"line":182,"address":[],"length":0,"stats":{"Line":4467570830351532049}},{"line":189,"address":[],"length":0,"stats":{"Line":4467570830351532049}},{"line":190,"address":[],"length":0,"stats":{"Line":4467570830351532049}},{"line":191,"address":[],"length":0,"stats":{"Line":4035225266123964444}},{"line":192,"address":[],"length":0,"stats":{"Line":18014398509481984011}},{"line":194,"address":[],"length":0,"stats":{"Line":4899916394579099654}},{"line":197,"address":[],"length":0,"stats":{"Line":4467570830351532049}},{"line":200,"address":[],"length":0,"stats":{"Line":4467570830351532049}},{"line":201,"address":[],"length":0,"stats":{"Line":4467570830351532049}},{"line":202,"address":[],"length":0,"stats":{"Line":5044031582654955558}},{"line":203,"address":[],"length":0,"stats":{"Line":13690942867206307842}},{"line":204,"address":[],"length":0,"stats":{"Line":13690942867206307842}},{"line":207,"address":[],"length":0,"stats":{"Line":4467570830351532036}}],"covered":55,"coverable":68},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_no_star_adjacent_to_star.rs"],"content":"//! Règle de construction/résolution d'une grille.\n//!\n//! Recherche les cases adjacentes à une étoile qui ne peuvent pas contenir une étoile.\n\nuse crate::GoodRule;\nuse crate::Grid;\nuse crate::GridAction;\nuse crate::GridHandler;\nuse crate::GridSurfer;\n\n/// Cherche si une étoile déjà placée à des cases adjacentes non définies.\n/// Si oui, ces cases peuvent être définie comme `NoStar`\npub fn rule_no_star_adjacent_to_star(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\n    for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\n        if grid.cell(line_column).is_star() {\n            let unknown_adjacent_cells: Vec\u003cGridAction\u003e = handler\n                .adjacent_cells(line_column)\n                .iter()\n                .filter(|line_column| grid.cell(**line_column).is_unknown())\n                .map(|line_column| GridAction::SetNoStar(*line_column))\n                .collect();\n            if !unknown_adjacent_cells.is_empty() {\n                return Some(GoodRule::NoStarAdjacentToStar(\n                    line_column,\n                    unknown_adjacent_cells,\n                ));\n            }\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use crate::GridParser;\n    use crate::LineColumn;\n\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\n        let grid_parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\n        let grid = Grid::from(\u0026grid_handler);\n        (grid_handler, grid)\n    }\n\n    #[test]\n    fn test_no_star_adjacent_to_star() {\n        let (grid_handler, mut grid) = get_test_grid();\n\n        // On place volontairement 1 étoile au centre de la grille\n        let center_line_column = LineColumn::new(2, 2);\n        grid.apply_action(\u0026GridAction::SetStar(center_line_column));\n\n        // Les 8 cases adjacentes ne peuvent pas contenir une étoile\n        let good_rule = rule_no_star_adjacent_to_star(\u0026grid_handler, \u0026grid);\n        match good_rule {\n            Some(GoodRule::NoStarAdjacentToStar(line_column, actions)) =\u003e {\n                assert_eq!(line_column, center_line_column);\n                assert_eq!(actions.len(), 8);\n                let adjacent_to_center_line_column =\n                    grid_handler.surfer(\u0026grid, \u0026GridSurfer::Adjacent(center_line_column));\n                for action in actions {\n                    match action {\n                        GridAction::SetNoStar(line_column) =\u003e {\n                            assert!(adjacent_to_center_line_column.contains(\u0026line_column));\n                        }\n                        _ =\u003e panic!(\"L'action n'est pas détectée\"),\n                    }\n                }\n            }\n            _ =\u003e panic!(\"La règle n'est pas détectée\"),\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":14,"address":[],"length":0,"stats":{"Line":15204152342002794496}},{"line":15,"address":[],"length":0,"stats":{"Line":11961560610296037376}},{"line":16,"address":[],"length":0,"stats":{"Line":11096869481840902368}},{"line":17,"address":[],"length":0,"stats":{"Line":11096869481840902368}},{"line":19,"address":[],"length":0,"stats":{"Line":7998392938210001367}},{"line":20,"address":[],"length":0,"stats":{"Line":8214565720323785302}},{"line":22,"address":[],"length":0,"stats":{"Line":11096869481840902368}},{"line":23,"address":[],"length":0,"stats":{"Line":14915921965851082754}},{"line":24,"address":[],"length":0,"stats":{"Line":14915921965851082754}},{"line":25,"address":[],"length":0,"stats":{"Line":14915921965851082754}},{"line":30,"address":[],"length":0,"stats":{"Line":6773413839565225987}}],"covered":12,"coverable":12},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_region_combinations.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche des combinaisons de 'n' régions occupent 'n' lignes ou 'n' colonnes.\u003cbr\u003e\r\n//! Dans ce cas, toutes les cases dans ces 'n' lignes ou colonnes qui n'appartiennent pas aux\r\n//! régions ne peuvent pas être des étoiles.\r\n//!\r\n//! En effect, les 'n' régions sur 'n' lignes positionnent toutes les étoiles sur ces 'n' lignes\r\n//! et il ne peut donc pas y avoir d'autres étoiles sur ce 'n' lignes.\u003cbr\u003e\r\n//! Idem pour les colonnes.\r\n//!\r\n//! //! Cette règle est l'opposée de la règle [`rule_region_exclusions`]\r\n\r\n/// Crate qui recherche n combinaisons possibles dans un vecteur d'elements\r\nuse combination::combine;\r\n\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\nuse crate::LineColumn;\r\n\r\n/// Recherche les régions de 1 ligne ou 1 colonne. Les autres cases de cette ligne ou colonne\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_1_combinations(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_combinations(handler, grid, 1)\r\n}\r\n\r\n/// Recherche les couples de régions sur 2 ligne ou 2 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_2_combinations(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_combinations(handler, grid, 2)\r\n}\r\n\r\n/// Recherche les triplets de régions sur 3 ligne ou 3 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_3_combinations(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_combinations(handler, grid, 3)\r\n}\r\n\r\n/// Recherche les quadruplets de régions sur 4 ligne ou 4 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_4_combinations(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_combinations(handler, grid, 4)\r\n}\r\n\r\n/// Cherche les combinaisons de 'n' régions occupent exactement 'n' lignes ou 'n' colonnes.\u003cbr\u003e\r\n/// Si des cases appartement à d'autres régions sont dans ces lignes ou colonnes, elles ne peuvent\r\n/// pas être des étoiles\r\nfn rule_region_generic_combinations(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    n: usize,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    // On utilise le crate 'combination' pour trouver toutes les combinaisons possibles\r\n    for vec_regions in combine::from_vec_at(\u0026handler.regions(), n) {\r\n        // On cherche les cases qui sont dans la combinaison et on détermine les lignes/colonnes minimales/maximales\r\n        let all_cells = handler.surfer(grid, \u0026GridSurfer::AllCells);\r\n        let mut min_line = usize::MAX;\r\n        let mut max_line = 0;\r\n        let mut min_column = usize::MAX;\r\n        let mut max_column = 0;\r\n        for line_column in all_cells {\r\n            let cell = grid.cell(line_column);\r\n            if vec_regions.contains(\u0026cell.region) {\r\n                // Cette case de la grille est dans une des régions de la combinaison\r\n                let (line, column) = (cell.line_column.line, cell.line_column.column);\r\n                if line \u003c min_line {\r\n                    min_line = line;\r\n                }\r\n                if line \u003e max_line {\r\n                    max_line = line;\r\n                }\r\n                if column \u003c min_column {\r\n                    min_column = column;\r\n                }\r\n                if column \u003e max_column {\r\n                    max_column = column;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (max_line - min_line + 1) == n {\r\n            // Les 'n' régions occupent exactement 'n' lignes\r\n            // Existe-t-il des cases dans ces lignes qui n'appartiennent pas à ces régions et qui sont indéfinies ?\r\n            let grid_surfer = GridSurfer::Lines(min_line..=max_line);\r\n            let surfer = handler.surfer(grid, \u0026grid_surfer);\r\n            let candidates: Vec\u003cLineColumn\u003e = surfer\r\n                .iter()\r\n                .filter(|line_column| grid.cell(**line_column).is_unknown())\r\n                .filter(|line_column| !vec_regions.contains(\u0026grid.cell(**line_column).region))\r\n                .copied()\r\n                .collect();\r\n\r\n            if !candidates.is_empty() {\r\n                let mut actions = Vec::new();\r\n                for line_column in candidates {\r\n                    actions.push(GridAction::SetNoStar(line_column));\r\n                }\r\n\r\n                return Some(GoodRule::ZoneCombinations(\r\n                    vec_regions,\r\n                    grid_surfer,\r\n                    actions,\r\n                ));\r\n            }\r\n        }\r\n\r\n        if (max_column - min_column + 1) == n {\r\n            // Les 'n' regions occupent exactement 'n'\r\n            // Existe-t-il des cases dans ces colonnes qui n'appartiennent pas à ces régions et qui sont indéfinies ?\r\n            let grid_surfer = GridSurfer::Columns(min_column..=max_column);\r\n            let surfer = handler.surfer(grid, \u0026grid_surfer);\r\n            let candidates: Vec\u003cLineColumn\u003e = surfer\r\n                .iter()\r\n                .filter(|line_column| grid.cell(**line_column).is_unknown())\r\n                .filter(|line_column| !vec_regions.contains(\u0026grid.cell(**line_column).region))\r\n                .copied()\r\n                .collect();\r\n\r\n            if !candidates.is_empty() {\r\n                let mut actions = Vec::new();\r\n                for line_column in candidates {\r\n                    actions.push(GridAction::SetNoStar(line_column));\r\n                }\r\n\r\n                return Some(GoodRule::ZoneCombinations(\r\n                    vec_regions,\r\n                    grid_surfer,\r\n                    actions,\r\n                ));\r\n            }\r\n        }\r\n    }\r\n\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_region_combinations() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // Au moins la région 'A' ou 'C' déclenche cette règle\r\n        let option_good_rule = rule_region_1_combinations(\u0026grid_handler, \u0026grid);\r\n        assert!(\u0026option_good_rule.is_some());\r\n        let good_rule = option_good_rule.unwrap();\r\n        grid.apply_good_rule(\u0026good_rule);\r\n\r\n        // println!(\"Rule: {}\", \u0026good_rule);\r\n        // println!(\"Grid :\\n{}\", grid_handler.display(\u0026grid, true));\r\n        // panic!(\"stop test\")\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":3891110078048108545}},{"line":32,"address":[],"length":0,"stats":{"Line":3891110078048108545}},{"line":37,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":38,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":56,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":58,"address":[],"length":0,"stats":{"Line":14123288431433875457}},{"line":59,"address":[],"length":0,"stats":{"Line":14123288431433875457}},{"line":60,"address":[],"length":0,"stats":{"Line":14123288431433875457}},{"line":61,"address":[],"length":0,"stats":{"Line":14123288431433875457}},{"line":62,"address":[],"length":0,"stats":{"Line":14123288431433875457}},{"line":63,"address":[],"length":0,"stats":{"Line":17005592192950992239}},{"line":67,"address":[],"length":0,"stats":{"Line":11024811887802972940}},{"line":68,"address":[],"length":0,"stats":{"Line":6701356245527296780}},{"line":69,"address":[],"length":0,"stats":{"Line":14123288431433875456}},{"line":71,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":72,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":74,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":75,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":77,"address":[],"length":0,"stats":{"Line":16573246628723425280}},{"line":78,"address":[],"length":0,"stats":{"Line":16573246628723425280}},{"line":83,"address":[],"length":0,"stats":{"Line":14123288431433876795}},{"line":86,"address":[],"length":0,"stats":{"Line":5260204364768739348}},{"line":87,"address":[],"length":0,"stats":{"Line":5260204364768739348}},{"line":88,"address":[],"length":0,"stats":{"Line":5260204364768739348}},{"line":90,"address":[],"length":0,"stats":{"Line":4827858800541171752}},{"line":91,"address":[],"length":0,"stats":{"Line":7421932185906577450}},{"line":95,"address":[],"length":0,"stats":{"Line":5260204364768739348}},{"line":96,"address":[],"length":0,"stats":{"Line":936748722493063188}},{"line":97,"address":[],"length":0,"stats":{"Line":16717361816799281232}},{"line":98,"address":[],"length":0,"stats":{"Line":5260204364768739348}},{"line":101,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":102,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":103,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":104,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":109,"address":[],"length":0,"stats":{"Line":13186539708940813607}},{"line":112,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":113,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":114,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":116,"address":[],"length":0,"stats":{"Line":11745387828182253568}},{"line":117,"address":[],"length":0,"stats":{"Line":17726168133330272259}},{"line":121,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":122,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":123,"address":[],"length":0,"stats":{"Line":648518346341351730}},{"line":124,"address":[],"length":0,"stats":{"Line":5908722711110090854}},{"line":127,"address":[],"length":0,"stats":{"Line":1369094286720630785}},{"line":128,"address":[],"length":0,"stats":{"Line":1369094286720630785}},{"line":129,"address":[],"length":0,"stats":{"Line":1369094286720630785}},{"line":130,"address":[],"length":0,"stats":{"Line":1369094286720630785}},{"line":136,"address":[],"length":0,"stats":{"Line":3026418949592973332}}],"covered":50,"coverable":54},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_region_exclusions.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche des combinaisons de 'n' lignes ou colonnes qui ne sont occupées que 'n' régions.\u003cbr\u003e\r\n//! Dans ce cas, toutes les autres cases dans ces 'n' régions qui ne sont pas dans les 'n' lignes ou colonnes\r\n//! ne peuvent pas être des étoiles.\r\n//!\r\n//! S'il existe déjà des étoiles dans ces 'n' lignes ou colonnes, La règle n'est pas applicable.\r\n//!\r\n//! S'il existe des cases d'autres régions qui sont déjà définies comme pouvant pas être des étoiles,\r\n//! on peut les ignorer.\r\n//!\r\n//! En effect, les 'n' lignes ou colonnes positionnent toutes les étoiles pour ces 'n' régions\r\n//! et il ne peut donc pas y avoir d'autres étoiles dans ces 'n' régions.\r\n//!\r\n//! Par exemple, pour n = 1, si une seule région occupe toute une ligne (ou colonne) alors les étoiles de\r\n//! cette région sont sur cette ligne (ou colonne) et les cases des cette région qui ne sont pas dans cette\r\n//! ligne (ou colonne) ne peuvent pas être des étoiles.\r\n//!\r\n//! Cette règle est l'opposée de la règle [`rule_region_combinations`]\r\n\r\nuse crate::CellValue;\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\nuse crate::LineColumn;\r\nuse crate::Region;\r\n\r\n/// Recherche les régions de 1 ligne ou 1 colonne. Les autres cases de cette ligne ou colonne\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_1_exclusions(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_exclusions(handler, grid, 1)\r\n}\r\n\r\n/// Recherche les couples de régions sur 2 ligne ou 2 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_2_exclusions(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_exclusions(handler, grid, 2)\r\n}\r\n\r\n/// Recherche les triplets de régions sur 3 ligne ou 3 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_3_exclusions(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_exclusions(handler, grid, 3)\r\n}\r\n\r\n/// Recherche les quadruplets de régions sur 4 ligne ou 4 colonne. Les autres cases de ces lignes ou colonnes\r\n/// ne peuvent pas être des étoiles\r\npub fn rule_region_4_exclusions(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_region_generic_exclusions(handler, grid, 4)\r\n}\r\n\r\n/// Cherche les combinaisons de 'n' lignes ou colonnes qui contiennent exactement 'n' régions.\u003cbr\u003e\r\n/// S'il existe des cases appartement à ces régions dans d'autres lignes ou colonnes, elles ne peuvent\r\n/// pas être des étoiles\r\n#[allow(clippy::range_minus_one)]\r\nfn rule_region_generic_exclusions(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    n: usize,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    for line in 0..=handler.nb_lines() - n {\r\n        let grid_surfer = GridSurfer::Lines(line..=line + n - 1);\r\n        if let Some((vec_regions, candidates)) =\r\n            rule_region_more_generic_exclusions(handler, grid, n, \u0026grid_surfer)\r\n        {\r\n            let mut actions = Vec::new();\r\n            for line_column in candidates {\r\n                actions.push(GridAction::SetNoStar(line_column));\r\n            }\r\n            return Some(GoodRule::ZoneExclusions(vec_regions, grid_surfer, actions));\r\n        }\r\n    }\r\n    for column in 0..=handler.nb_columns() - n {\r\n        let grid_surfer = GridSurfer::Columns(column..=column + n - 1);\r\n        if let Some((vec_regions, candidates)) =\r\n            rule_region_more_generic_exclusions(handler, grid, n, \u0026grid_surfer)\r\n        {\r\n            let mut actions = Vec::new();\r\n            for line_column in candidates {\r\n                actions.push(GridAction::SetNoStar(line_column));\r\n            }\r\n            return Some(GoodRule::ZoneExclusions(vec_regions, grid_surfer, actions));\r\n        }\r\n    }\r\n    None\r\n}\r\n\r\n/// Spécialisation de `rule_region_generic_exclusions` pour 'n' lignes ou 'n' colonnes.\u003cbr\u003e\r\n/// Compte combien de régions différentes sont présentes dans le `grid_surfer`. Si 'n' régions alors\r\n/// recherche des cases candidates qui ne sont pas définies pour ces régions en dehors de `grid_surfer`\r\nfn rule_region_more_generic_exclusions(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    n: usize,\r\n    grid_surfer: \u0026GridSurfer,\r\n) -\u003e Option\u003c(Vec\u003cRegion\u003e, Vec\u003cLineColumn\u003e)\u003e {\r\n    let surfer = handler.surfer(grid, grid_surfer);\r\n    let mut vec_regions = Vec::new();\r\n    for line_column in \u0026surfer {\r\n        match grid.cell(*line_column).value {\r\n            // S'il existe déjà des étoiles dans les n lignes ou colonnes, on abandonne la recherche\r\n            // (la règle n'est pas applicable)\r\n            CellValue::Star =\u003e return None,\r\n            // Si la case est déjà définie comme ne pouvant pas être une étoile, on l'ignore : Quelle que soit\r\n            // sa région, la règle reste applicable\r\n            CellValue::NoStar =\u003e continue,\r\n            // Case non définie, on comptabilise sa région\r\n            CellValue::Unknown =\u003e {\r\n                let region = grid.cell(*line_column).region;\r\n                if !vec_regions.contains(\u0026region) {\r\n                    vec_regions.push(region);\r\n                    if vec_regions.len() \u003e n {\r\n                        return None;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // vec_regions contient toutes les regions qui sont dans le 'grid_surfer' et il n'y a pas plus de 'n'.\r\n    // On cherche des cases non définies de ces régions qui ne sont pas dans 'grid_surfer'\r\n    let mut candidates = Vec::new();\r\n    for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\r\n        if !surfer.contains(\u0026line_column) {\r\n            let cell = grid.cell(line_column);\r\n            if cell.is_unknown() \u0026 vec_regions.contains(\u0026cell.region) {\r\n                candidates.push(line_column);\r\n            }\r\n        }\r\n    }\r\n\r\n    if candidates.is_empty() {\r\n        None\r\n    } else {\r\n        Some((vec_regions, candidates))\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_region_exclusions() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // Au moins la 4eme ligne 'DDDDD' déclenche cette règle\r\n        let option_good_rule = rule_region_1_exclusions(\u0026grid_handler, \u0026grid);\r\n        assert!(\u0026option_good_rule.is_some());\r\n        let good_rule = option_good_rule.unwrap();\r\n        grid.apply_good_rule(\u0026good_rule);\r\n\r\n        // println!(\"Rule: {}\", \u0026good_rule);\r\n        // println!(\"Grid :\\n{}\", grid_handler.display(\u0026grid, true));\r\n        // panic!(\"stop test\")\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":792633534417207331}},{"line":33,"address":[],"length":0,"stats":{"Line":792633534417207331}},{"line":38,"address":[],"length":0,"stats":{"Line":3891110078048108545}},{"line":39,"address":[],"length":0,"stats":{"Line":3891110078048108545}},{"line":44,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":45,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":6413125869375586304}},{"line":63,"address":[],"length":0,"stats":{"Line":14555633995661443073}},{"line":64,"address":[],"length":0,"stats":{"Line":8142508126285856769}},{"line":65,"address":[],"length":0,"stats":{"Line":864691128455135243}},{"line":66,"address":[],"length":0,"stats":{"Line":8142508126285856769}},{"line":68,"address":[],"length":0,"stats":{"Line":864691128455135243}},{"line":69,"address":[],"length":0,"stats":{"Line":9943947977234055179}},{"line":70,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":72,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":75,"address":[],"length":0,"stats":{"Line":10232178353385766914}},{"line":76,"address":[],"length":0,"stats":{"Line":4683743612465315841}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":78,"address":[],"length":0,"stats":{"Line":4683743612465315841}},{"line":80,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":81,"address":[],"length":0,"stats":{"Line":2882303761517117451}},{"line":82,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":84,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":87,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":93,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":99,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":100,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":101,"address":[],"length":0,"stats":{"Line":15852670688344146080}},{"line":105,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":108,"address":[],"length":0,"stats":{"Line":10808639105689190422}},{"line":111,"address":[],"length":0,"stats":{"Line":1585267068834414638}},{"line":112,"address":[],"length":0,"stats":{"Line":1585267068834414638}},{"line":113,"address":[],"length":0,"stats":{"Line":3602879701896396811}},{"line":114,"address":[],"length":0,"stats":{"Line":3602879701896396811}},{"line":115,"address":[],"length":0,"stats":{"Line":3746994889972252677}},{"line":123,"address":[],"length":0,"stats":{"Line":8646911284551352344}},{"line":124,"address":[],"length":0,"stats":{"Line":10376293541461622808}},{"line":125,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":126,"address":[],"length":0,"stats":{"Line":4611686018427387867}},{"line":127,"address":[],"length":0,"stats":{"Line":8502796096475496416}},{"line":128,"address":[],"length":0,"stats":{"Line":3891110078048108549}},{"line":133,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":134,"address":[],"length":0,"stats":{"Line":7493989779944505361}},{"line":136,"address":[],"length":0,"stats":{"Line":1152921504606846976}}],"covered":44,"coverable":46},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_region_possible_stars.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche les combinaisons d'étoiles possibles dans une région.\r\n//! Plus simplement que `rule_region_star_complete`, on n'examine ici que le contenu des différentes\r\n//! combinaisons dans une région sans examiner l'impact sur l'ensemble de la grille grille.\r\n//! On intègre également dans cette recherche, toutes les cases environnant une région qui sont\r\n//! forcément pas des étoles puisque toujours à proximité d'une étoile dans la région.\r\n//! Les règles qui apparaissent ainsi sont plus compréhensible pour un humain.\r\n\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridHandler;\r\n\r\nuse super::rule_generic_possible_stars;\r\nuse super::ZoneToExamine;\r\n\r\n/// Cherche toutes les combinaisons d'étoiles possibles dans les différentes régions.\r\n/// Version simplifiée de `rule_region_recursive_possible_stars` qui se limite au contenu des\r\n/// différentes régions pour une compréhension plus aisées pour un humain\r\npub fn rule_region_possible_stars(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(handler, grid, ZoneToExamine::Region, false)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_region_stars() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        println!(\"Grille initiale :\\n{}\", grid_handler.display(\u0026grid, true));\r\n\r\n        // Cette règle s'applique sur la région 'CC' dans la 3eme ligne : Les cases adjacentes ne peuvent\r\n        // pas être une étoile...\r\n        let option_good_rule = rule_region_possible_stars(\u0026grid_handler, \u0026grid);\r\n        assert!(option_good_rule.is_some());\r\n        grid.apply_good_rule(\u0026option_good_rule.unwrap());\r\n\r\n        // Cette règle s'applique sur l'avant dernière ligne de 'DDDDD' : On doit mettre une étoile\r\n        // sur cette ligne donc les D sur la ligne suivante ne peuvent pas être une étoile...\r\n        let option_good_rule = rule_region_possible_stars(\u0026grid_handler, \u0026grid);\r\n        assert!(option_good_rule.is_some());\r\n        grid.apply_good_rule(\u0026option_good_rule.unwrap());\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":21,"address":[],"length":0,"stats":{"Line":17005592192950992896}}],"covered":2,"coverable":2},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_value_completed.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche les cases implicites compte-tenu des autres cases dans une zone :\r\n//! * Une étoile si une seule possibilité pour la zone\r\n//! * Pas d'étoile si toutes les étoiles sont déjà placées dans la zone\r\n\r\nuse crate::CellValue;\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\n\r\n/// Cherche dans les régions, les lignes et les colonnes s'il y a des contenus de cases 'évidents :\r\n/// * Pas d'étoile si toutes les étoiles sont déjà placées dans la zone\r\n/// * Une étoile si une seule possibilité pour la zone\r\npub fn rule_value_completed(handler: \u0026GridHandler, grid: \u0026Grid) -\u003e Option\u003cGoodRule\u003e {\r\n    let mut zones = Vec::new();\r\n\r\n    // Parcours de toutes les régions\r\n    for region in handler.regions() {\r\n        zones.push(GridSurfer::Region(region));\r\n    }\r\n\r\n    // Parcours de toutes les lignes\r\n    for line in 0..handler.nb_lines() {\r\n        zones.push(GridSurfer::Line(line));\r\n    }\r\n\r\n    // Parcours de toutes les colonnes\r\n    for column in 0..handler.nb_columns() {\r\n        zones.push(GridSurfer::Column(column));\r\n    }\r\n\r\n    // Examine toutes les zones prévues\r\n    for zone in zones {\r\n        if let Some(good_rule) = try_value_completed(handler, grid, \u0026zone, handler.nb_stars()) {\r\n            return Some(good_rule);\r\n        }\r\n    }\r\n    None\r\n}\r\n\r\n/// Détermine s'il y a des contenus de cases 'évidents' pour une zone\r\nfn try_value_completed(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n    grid_surfer: \u0026GridSurfer,\r\n    nb_stars: usize,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    let surfer = handler.surfer(grid, grid_surfer);\r\n\r\n    // Décompte de cases inconnue/avec étoile/sans étoile dans la zone\r\n    let mut cur_nb_stars = 0;\r\n    let mut _cur_nb_no_stars = 0;\r\n    // Nombre et cases restantes à placer dans la zone\r\n    let mut cur_nb_unknown = 0;\r\n    let mut line_column_unknown = Vec::new();\r\n    // On pourrait compter les types de valeurs avec `handler.surfer_cells_with_value_count` mais\r\n    // nécessiterait de créer à chaque fois un nouveau surfer (coûteux...)\r\n    for line_column in surfer {\r\n        match grid.cell(line_column).value {\r\n            CellValue::Star =\u003e cur_nb_stars += 1,\r\n            CellValue::NoStar =\u003e _cur_nb_no_stars += 1,\r\n            CellValue::Unknown =\u003e {\r\n                cur_nb_unknown += 1;\r\n                line_column_unknown.push(line_column);\r\n            }\r\n        }\r\n    }\r\n\r\n    if cur_nb_unknown \u003e 0 {\r\n        // Il reste des cases non définies dans la zone...\r\n        if cur_nb_stars == nb_stars {\r\n            // ...et la zone possède déjà toutes les étoiles attendues\r\n            // =\u003e les cases inconnues sont forcement sans étoile\r\n            let mut actions = Vec::new();\r\n            for line_column in line_column_unknown {\r\n                actions.push(GridAction::SetNoStar(line_column));\r\n            }\r\n            return Some(GoodRule::ZoneNoStarCompleted(grid_surfer.clone(), actions));\r\n        }\r\n        if cur_nb_unknown == nb_stars - cur_nb_stars {\r\n            // ... et il reste dans la zone autant de cases indéfinies qu'il reste d'étoiles à placer\r\n            // =\u003e les cases inconnues sont forcement avec une étoile\r\n            let mut actions = Vec::new();\r\n            for line_column in line_column_unknown {\r\n                actions.push(GridAction::SetStar(line_column));\r\n            }\r\n            return Some(GoodRule::ZoneStarCompleted(grid_surfer.clone(), actions));\r\n        }\r\n    }\r\n\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n    use crate::LineColumn;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_zone_no_star_completed() {\r\n        let (grid_handler, grid) = get_test_grid();\r\n\r\n        for line in 0..grid_handler.nb_lines() {\r\n            for column in 0..grid_handler.nb_columns() {\r\n                let mut test_grid = grid.clone();\r\n\r\n                // On place volontairement 1 étoile dans la grille\r\n                test_grid.apply_action(\u0026GridAction::SetStar(LineColumn::new(line, column)));\r\n\r\n                // La règle doit détecter une région qui doit être complétée avec des cases sans étoile\r\n                let good_rule = rule_value_completed(\u0026grid_handler, \u0026test_grid);\r\n                match good_rule {\r\n                    Some(GoodRule::ZoneNoStarCompleted(_, _)) =\u003e (),\r\n                    _ =\u003e panic!(\"La règle n'est pas détectée\"),\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_zone_star_completed() {\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        // On place volontairement 1 case sans étoile dans la zone A de 2 cases\r\n        grid.apply_action(\u0026GridAction::SetNoStar(LineColumn::new(1, 0)));\r\n\r\n        // La règle doit détecter une région qui doit être complétée avec des cases avec étoile\r\n        let good_rule = rule_value_completed(\u0026grid_handler, \u0026grid);\r\n        match good_rule {\r\n            Some(GoodRule::ZoneStarCompleted(_, _)) =\u003e (),\r\n            _ =\u003e panic!(\"La règle n'est pas détectée\"),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":18,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":21,"address":[],"length":0,"stats":{"Line":14411518807585587204}},{"line":22,"address":[],"length":0,"stats":{"Line":12105675798371893250}},{"line":26,"address":[],"length":0,"stats":{"Line":14411518807585587225}},{"line":27,"address":[],"length":0,"stats":{"Line":12105675798371893250}},{"line":31,"address":[],"length":0,"stats":{"Line":14411518807585587225}},{"line":32,"address":[],"length":0,"stats":{"Line":12105675798371893250}},{"line":36,"address":[],"length":0,"stats":{"Line":7061644215716937729}},{"line":37,"address":[],"length":0,"stats":{"Line":7926335344172072961}},{"line":38,"address":[],"length":0,"stats":{"Line":7926335344172072961}},{"line":41,"address":[],"length":0,"stats":{"Line":720575940379279405}},{"line":45,"address":[],"length":0,"stats":{"Line":3170534137668829185}},{"line":51,"address":[],"length":0,"stats":{"Line":3170534137668829185}},{"line":54,"address":[],"length":0,"stats":{"Line":3170534137668829185}},{"line":55,"address":[],"length":0,"stats":{"Line":3170534137668829185}},{"line":57,"address":[],"length":0,"stats":{"Line":3170534137668829185}},{"line":58,"address":[],"length":0,"stats":{"Line":3170534137668829185}},{"line":61,"address":[],"length":0,"stats":{"Line":11240984669916758329}},{"line":63,"address":[],"length":0,"stats":{"Line":11889503016258109619}},{"line":64,"address":[],"length":0,"stats":{"Line":3458764513820540975}},{"line":65,"address":[],"length":0,"stats":{"Line":7133701809754865696}},{"line":66,"address":[],"length":0,"stats":{"Line":7133701809754865696}},{"line":67,"address":[],"length":0,"stats":{"Line":7133701809754865696}},{"line":72,"address":[],"length":0,"stats":{"Line":3170534137668829389}},{"line":74,"address":[],"length":0,"stats":{"Line":4899916394579099695}},{"line":77,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":78,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":79,"address":[],"length":0,"stats":{"Line":9079256848778919936}},{"line":81,"address":[],"length":0,"stats":{"Line":8358680908399640610}},{"line":83,"address":[],"length":0,"stats":{"Line":14987979559889010735}},{"line":86,"address":[],"length":0,"stats":{"Line":18014398509481984011}},{"line":87,"address":[],"length":0,"stats":{"Line":6485183463413514254}},{"line":88,"address":[],"length":0,"stats":{"Line":2305843009213693953}},{"line":90,"address":[],"length":0,"stats":{"Line":18014398509481984000}},{"line":94,"address":[],"length":0,"stats":{"Line":13690942867206308034}}],"covered":36,"coverable":36},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","rule_zone_possible_stars.rs"],"content":"//! Règle de construction/résolution d'une grille.\r\n//!\r\n//! Recherche les cases invariantes pour toutes les combinaisons possibles d'une zone\r\n\r\nuse crate::GoodRule;\r\nuse crate::Grid;\r\nuse crate::GridHandler;\r\n\r\nuse super::rule_generic_possible_stars;\r\nuse super::ZoneToExamine;\r\n\r\n/// Cherche toutes les combinaisons possibles dans les différentes régions.\r\npub fn rule_region_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(handler, grid, ZoneToExamine::Region, true)\r\n}\r\n\r\n/// Cherche toutes les combinaisons possibles dans les différentes ligne ou colonne.\r\npub fn rule_line_column_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(handler, grid, ZoneToExamine::LineAndColumn, true)\r\n}\r\n\r\n/// Cherche toutes les combinaisons possibles dans les groupes de 2 lignes ou 2 colonnes\r\npub fn rule_multi_2_lines_columns_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(\r\n        handler,\r\n        grid,\r\n        ZoneToExamine::MultipleLinesAndColumns(2),\r\n        true,\r\n    )\r\n}\r\n\r\n/// Cherche toutes les combinaisons possibles dans les groupes de 3 lignes ou 3 colonnes\r\npub fn rule_multi_3_lines_columns_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(\r\n        handler,\r\n        grid,\r\n        ZoneToExamine::MultipleLinesAndColumns(3),\r\n        true,\r\n    )\r\n}\r\n\r\n/// Cherche toutes les combinaisons possibles dans les groupes de 4 lignes ou 3 colonnes\r\npub fn rule_multi_4_lines_columns_recursive_possible_stars(\r\n    handler: \u0026GridHandler,\r\n    grid: \u0026Grid,\r\n) -\u003e Option\u003cGoodRule\u003e {\r\n    rule_generic_possible_stars(\r\n        handler,\r\n        grid,\r\n        ZoneToExamine::MultipleLinesAndColumns(4),\r\n        true,\r\n    )\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    use crate::GridParser;\r\n\r\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\r\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\r\n        let grid_parser =\r\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n        let grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\n        let grid = Grid::from(\u0026grid_handler);\r\n        (grid_handler, grid)\r\n    }\r\n\r\n    #[test]\r\n    fn test_complete_start_number() {\r\n        // La grille de test peut être complètement résolue avec cette seule règle sur les zones\r\n        let (grid_handler, mut grid) = get_test_grid();\r\n\r\n        println!(\"Grille initiale :\\n{}\", grid_handler.display(\u0026grid, true));\r\n\r\n        loop {\r\n            let option_good_rule = rule_line_column_recursive_possible_stars(\u0026grid_handler, \u0026grid);\r\n            if option_good_rule.is_some() {\r\n                let good_rule = option_good_rule.unwrap();\r\n                println!(\"{good_rule}\");\r\n                grid.apply_good_rule(\u0026good_rule);\r\n\r\n                println!(\"\\n{}\", grid_handler.display(\u0026grid, true));\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        assert!(grid_handler.is_done(\u0026grid));\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":3602879701896396821}},{"line":17,"address":[],"length":0,"stats":{"Line":3602879701896396821}},{"line":21,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":25,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":16},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_good_ruler","star_adjacent.rs"],"content":"//! Recherche des cases toujours adjacentes à une étoile dans une collection de grilles\r\n\r\nuse crate::CellValue;\r\nuse crate::Grid;\r\nuse crate::GridAction;\r\nuse crate::GridHandler;\r\nuse crate::GridSurfer;\r\n\r\n/// Énumération de la situation pour les cases possiblement toujours adjacentes à une étoile\r\n/// dans toutes les combinaisons possibles de grilles\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\npub enum StarAdjacent {\r\n    // Case initialement inconnue\r\n    Init,\r\n\r\n    // Case vue adjacente à une une étoile dans une des grilles possibles\r\n    Always,\r\n\r\n    // Case vue avec différentes possibilités dans les grilles possibles\r\n    Variable,\r\n}\r\n\r\nimpl StarAdjacent {\r\n    /// Examine un ensemble des grilles possibles collectées à partir d'une grille initiale à la recherche\r\n    /// de cases toujours adjacentes à une étoile pour toutes les possibilités de grilles\r\n    pub fn check_for_star_adjacents(\r\n        handler: \u0026GridHandler,\r\n        grid: \u0026Grid,\r\n        possible_grids: \u0026Vec\u003cGrid\u003e,\r\n    ) -\u003e Vec\u003cGridAction\u003e {\r\n        // Liste des cases non déterminées dans la grille initiale\r\n        let mut cells = Vec::new();\r\n        // Liste des 'Variant' de ces cases\r\n        let mut star_adjacents = Vec::new();\r\n        for line_column in handler.surfer(grid, \u0026GridSurfer::AllCells) {\r\n            if grid.cell(line_column).is_unknown() {\r\n                cells.push(line_column);\r\n                star_adjacents.push(Self::Init);\r\n            }\r\n        }\r\n\r\n        // Parcours de toutes les grilles possibles collectées\r\n        for grid in possible_grids {\r\n            // On combine toutes les cases à examiner avec ce qu'on a déjà observé\r\n            for (line_column, variant) in cells.iter().zip(star_adjacents.iter_mut()) {\r\n                // Seules les cases avec une situation différente de `CellValue::Star` peuvent prétendre\r\n                // à être toujours adjacentes à une étoile\r\n                if grid.cell(*line_column).value == CellValue::Star {\r\n                    *variant = Self::Variable;\r\n                } else {\r\n                    // Et qu'elles n'ont pas été déjà identifiées comme StarAdjacent::Variable\r\n                    if *variant != Self::Variable {\r\n                        // Liste des cases adjacentes\r\n                        let adjacents = handler.adjacent_cells(*line_column);\r\n                        if adjacents\r\n                            .iter()\r\n                            .any(|line_column| grid.cell(*line_column).value == CellValue::Star)\r\n                        {\r\n                            *variant = Self::Always;\r\n                        } else {\r\n                            *variant = Self::Variable;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Liste des cases toujours adjacentes à une étoile dans toutes les grilles examinées\r\n        let mut adjacent_star_actions = Vec::new();\r\n        for (line_column, star_adjacent) in cells.iter().zip(star_adjacents.iter()) {\r\n            if star_adjacent == \u0026Self::Always {\r\n                /* Cette case est toujours adjacent à une étoile dans toutes les grilles possibles */\r\n                adjacent_star_actions.push(GridAction::SetNoStar(*line_column));\r\n            }\r\n        }\r\n\r\n        adjacent_star_actions\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":4467570830351532269}},{"line":32,"address":[],"length":0,"stats":{"Line":4467570830351532269}},{"line":34,"address":[],"length":0,"stats":{"Line":4467570830351532269}},{"line":35,"address":[],"length":0,"stats":{"Line":10088063165309911288}},{"line":36,"address":[],"length":0,"stats":{"Line":13618885273168380810}},{"line":37,"address":[],"length":0,"stats":{"Line":7998392938210001791}},{"line":38,"address":[],"length":0,"stats":{"Line":7998392938210001791}},{"line":43,"address":[],"length":0,"stats":{"Line":15276209936040723439}},{"line":45,"address":[],"length":0,"stats":{"Line":864691128455135243}},{"line":48,"address":[],"length":0,"stats":{"Line":18230571291595774132}},{"line":49,"address":[],"length":0,"stats":{"Line":17365880163140638889}},{"line":52,"address":[],"length":0,"stats":{"Line":1945555039024047970}},{"line":54,"address":[],"length":0,"stats":{"Line":4323455642275676369}},{"line":55,"address":[],"length":0,"stats":{"Line":4323455642275676369}},{"line":57,"address":[],"length":0,"stats":{"Line":10016005571271983748}},{"line":59,"address":[],"length":0,"stats":{"Line":7926335344172073615}},{"line":61,"address":[],"length":0,"stats":{"Line":14843864371813154370}},{"line":69,"address":[],"length":0,"stats":{"Line":4467570830351532139}},{"line":70,"address":[],"length":0,"stats":{"Line":12465963768561533046}},{"line":71,"address":[],"length":0,"stats":{"Line":17509995351216489005}},{"line":72,"address":[],"length":0,"stats":{"Line":9511602413006488098}},{"line":73,"address":[],"length":0,"stats":{"Line":9511602413006488098}},{"line":77,"address":[],"length":0,"stats":{"Line":4467570830351532225}}],"covered":23,"coverable":23},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_handler.rs"],"content":"//! Structure d'une grille en cours de résolution.\n\nuse crate::check_bad_rules;\nuse crate::CellValue;\nuse crate::Grid;\nuse crate::GridParser;\nuse crate::LineColumn;\nuse crate::Region;\nuse crate::{display_column, display_line};\n\n/// Description d'une grille en cours de résolution\n#[derive(Debug)]\npub struct GridHandler {\n    /// Taille de la grille\n    size: LineColumn,\n\n    /// Nombre d'étoiles à placer dans chaque ligne, colonne ou région dans la grille\n    nb_stars: usize,\n\n    /// Liste des régions de la grille\n    regions: Vec\u003cRegion\u003e,\n\n    /// Liste des lignes avec la région correspondant à chaque case de la ligne\n    cells_region: Vec\u003cVec\u003cRegion\u003e\u003e,\n}\n\nimpl GridHandler {\n    /// Constructeur selon un grid parser et le nombre d'étoiles à placer dans la grille\n    /// # Panics\n    /// Panic si la taille de la grille est \u003c= 0 ou qu'il y a trop d'étoiles à placer selon la taille de la grille\n    #[must_use]\n    pub fn new(parser: \u0026GridParser, nb_stars: usize) -\u003e Self {\n        let nb_lines = parser.nb_lines();\n        let nb_columns = parser.nb_columns();\n        assert!(nb_lines \u003e 0, \"nb_lines doit être \u003e 0\");\n        assert!(nb_columns \u003e 0, \"nb_columns doit être \u003e 0\");\n        assert!(nb_stars \u003e 0, \"nb_stars doit être \u003e 0\");\n\n        // Liste des regions de la grille\n        let mut regions: Vec\u003cchar\u003e = parser.regions();\n        // Tri par taille de la region (en nombre de cases)\n        regions.sort_by(|a, b| {\n            parser\n                .region_cells(*a)\n                .len()\n                .cmp(\u0026parser.region_cells(*b).len())\n        });\n\n        // Pour mettre nb_stars sans qu'elles se touchent, il faut au moins ((2 * nb_stars) - 1) cases...\n        let min_nb_cells = (2 * nb_stars) - 1;\n        assert!(\n            nb_lines \u003e= min_nb_cells,\n            \"Trop d'étoiles à placer ({nb_stars}) pour une grille de {nb_lines} lignes\"\n        );\n        assert!(\n            nb_columns \u003e= min_nb_cells,\n            \"Trop d'étoiles à placer ({nb_stars}) pour une grille de {nb_columns} colonnes\"\n        );\n        for region in parser.regions() {\n            let nb_cells = parser.region_cells(region).len();\n            assert!(nb_cells \u003e= min_nb_cells,\n                \"Trop d'étoiles à placer ({nb_stars}) pour la region '{region}' de {nb_cells} cases dans la grille\");\n        }\n\n        // Reconstruction de la région de chaque case\n        let mut cells_region = Vec::with_capacity(nb_lines);\n        for line in 0..nb_lines {\n            let mut vec_line_regions = Vec::with_capacity(nb_columns);\n            for column in 0..nb_columns {\n                vec_line_regions.push(parser.cell(LineColumn::new(line, column)).unwrap().region);\n            }\n            cells_region.push(vec_line_regions);\n        }\n\n        Self {\n            size: LineColumn::new(nb_lines, nb_columns),\n            regions,\n            cells_region,\n            nb_stars,\n        }\n    }\n\n    /// Nombre de lignes de la grille\n    #[must_use]\n    pub const fn nb_lines(\u0026self) -\u003e usize {\n        self.size.line\n    }\n\n    /// Nombre de colonnes de la grille\n    #[must_use]\n    pub const fn nb_columns(\u0026self) -\u003e usize {\n        self.size.column\n    }\n\n    /// Nombre d'étoiles à placer dans la grille\n    #[must_use]\n    pub const fn nb_stars(\u0026self) -\u003e usize {\n        self.nb_stars\n    }\n\n    /// Liste des régions de la grille\n    #[must_use]\n    pub fn regions(\u0026self) -\u003e Vec\u003cRegion\u003e {\n        self.regions.clone()\n    }\n\n    /// Région d'une case de la grille\n    #[must_use]\n    pub fn cell_region(\u0026self, line_column: LineColumn) -\u003e Region {\n        self.cells_region[line_column.line][line_column.column]\n    }\n\n    /// Nombre de cases dans une région\n    #[must_use]\n    pub fn region_cells_count(\u0026self, region: Region) -\u003e usize {\n        let mut nb = 0;\n        for line in 0..self.nb_lines() {\n            for column in 0..self.nb_columns() {\n                if self.cell_region(LineColumn::new(line, column)) == region {\n                    nb += 1;\n                }\n            }\n        }\n        nb\n    }\n\n    /// Liste des cases adjacentes d'une case de la grille (y compris en diagonale)\n    #[must_use]\n    pub fn adjacent_cells(\u0026self, line_column: LineColumn) -\u003e Vec\u003cLineColumn\u003e {\n        let (line, column) = (line_column.line, line_column.column);\n        let mut adjacent_cells = vec![];\n        // North\n        if line \u003e 0 {\n            adjacent_cells.push(LineColumn::new(line - 1, column));\n            // North-West\n            if column \u003e 0 {\n                adjacent_cells.push(LineColumn::new(line - 1, column - 1));\n            }\n            // North-East\n            if column \u003c (self.nb_columns() - 1) {\n                adjacent_cells.push(LineColumn::new(line - 1, column + 1));\n            }\n        }\n        // West\n        if column \u003e 0 {\n            adjacent_cells.push(LineColumn::new(line, column - 1));\n            // South-West\n            if line \u003c (self.nb_lines() - 1) {\n                adjacent_cells.push(LineColumn::new(line + 1, column - 1));\n            }\n        }\n        // East\n        if line \u003c (self.nb_lines() - 1) {\n            adjacent_cells.push(LineColumn::new(line + 1, column));\n            // South-East\n            if column \u003c (self.nb_columns() - 1) {\n                adjacent_cells.push(LineColumn::new(line + 1, column + 1));\n            }\n        }\n        // South\n        if column \u003c (self.nb_columns() - 1) {\n            adjacent_cells.push(LineColumn::new(line, column + 1));\n        }\n        adjacent_cells\n    }\n\n    /// Retourne `true`si une des cases adjacentes de la case `line_column` est une étoile\n    #[must_use]\n    pub fn is_star_adjacent(\u0026self, grid: \u0026Grid, line_column: LineColumn) -\u003e bool {\n        for line_column in self.adjacent_cells(line_column) {\n            if grid.cell(line_column).is_star() {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Retourne true si toutes les cases de la grille sont définies et que la grille est 'viable'\n    #[must_use]\n    pub fn is_done(\u0026self, grid: \u0026Grid) -\u003e bool {\n        for line in 0..self.nb_lines() {\n            for column in 0..self.nb_columns() {\n                if grid.cell(LineColumn::new(line, column)).value == CellValue::Unknown {\n                    return false;\n                }\n            }\n        }\n        check_bad_rules(self, grid).is_ok()\n    }\n\n    /// Affichage du contenu d'une grille.\u003cbr\u003e\n    /// Si `with_coordinates` est `true`, affiche les coordonnées\n    /// horizontales ('A\", 'B', ...) et verticales (1, 2, ...)\n    #[must_use]\n    pub fn display(\u0026self, grid: \u0026Grid, with_coordinates: bool) -\u003e String {\n        let mut output = String::new();\n        if with_coordinates {\n            // On indique les lettre 'A', 'B', ... en entête pour les coordonnées horizontales\n            output.push_str(\"   \"); /* Espace pour les coordonnées verticales à gauche */\n            for column in 0..self.nb_columns() {\n                output.push_str(\u0026format!(\" {:\u003c2}\", display_column(column)));\n            }\n            output.push('\\n');\n            // Suivi d'une ligne de séparation\n            output.push_str(\"   \");\n            for _ in 0..self.nb_columns() {\n                output.push_str(\"---\");\n            }\n            output.push('\\n');\n        }\n        for line in 0..self.nb_lines() {\n            if with_coordinates {\n                // On indique les chiffres 1, 2, ... en entête pour les coordonnées verticales\n                output.push_str(\u0026format!(\"{:\u003e2}|\", display_line(line)));\n            }\n            for column in 0..self.nb_columns() {\n                let line_column = LineColumn::new(line, column);\n                let region = self.cell_region(line_column);\n                match grid.cell(line_column).value {\n                    CellValue::Star =\u003e output.push_str(\u0026format!(\" {region}*\")),\n                    CellValue::Unknown =\u003e output.push_str(\u0026format!(\" {region}?\")),\n                    CellValue::NoStar =\u003e output.push_str(\u0026format!(\" {region}-\")),\n                }\n            }\n            output.push('\\n');\n        }\n        output\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::collections::HashSet;\n\n    #[test]\n    #[allow(clippy::cognitive_complexity)]\n    fn test_ok() {\n        let parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n\n        assert_eq!(handler.nb_lines(), 5);\n        assert_eq!(handler.nb_columns(), 5);\n        assert_eq!(handler.nb_stars(), 1);\n        for region in ['A', 'B', 'C', 'D', 'E'] {\n            assert!(handler.regions().contains(\u0026region));\n        }\n\n        // Région A\n        assert_eq!(handler.cell_region(LineColumn::new(0, 0)), 'A');\n        assert_eq!(handler.cell_region(LineColumn::new(1, 0)), 'A');\n\n        // Région B\n        assert_eq!(handler.cell_region(LineColumn::new(0, 1)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(0, 2)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(0, 3)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(0, 4)), 'B');\n\n        assert_eq!(handler.cell_region(LineColumn::new(1, 1)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(1, 2)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(1, 3)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(1, 4)), 'B');\n\n        assert_eq!(handler.cell_region(LineColumn::new(2, 2)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(2, 3)), 'B');\n        assert_eq!(handler.cell_region(LineColumn::new(2, 4)), 'B');\n\n        // Région C\n        assert_eq!(handler.cell_region(LineColumn::new(2, 0)), 'C');\n        assert_eq!(handler.cell_region(LineColumn::new(2, 1)), 'C');\n\n        // Région D\n        assert_eq!(handler.cell_region(LineColumn::new(3, 0)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(3, 1)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(3, 2)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(3, 3)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(3, 4)), 'D');\n\n        assert_eq!(handler.cell_region(LineColumn::new(4, 0)), 'D');\n        assert_eq!(handler.cell_region(LineColumn::new(4, 4)), 'D');\n\n        // Région E\n        assert_eq!(handler.cell_region(LineColumn::new(4, 1)), 'E');\n        assert_eq!(handler.cell_region(LineColumn::new(4, 2)), 'E');\n        assert_eq!(handler.cell_region(LineColumn::new(4, 3)), 'E');\n    }\n\n    #[test]\n    #[rustfmt::skip]\n    fn test_adjacent() {\n        fn assert_adjacents(handler: \u0026GridHandler, (line, column):(usize, usize), expected: Vec\u003c(usize, usize)\u003e, ) {\n            let adjacent_cells:HashSet\u003cLineColumn\u003e = handler.adjacent_cells(LineColumn::new(line, column)).into_iter().collect();\n            let expected_cells:HashSet\u003cLineColumn\u003e = expected.into_iter().map(|(line, column)| LineColumn::new(line, column)).collect();\n            assert_eq!(adjacent_cells, expected_cells);\n        }\n\n        //  A A A\n        //  B B B\n        //  C C C\n        let parser =\n            GridParser::try_from(vec![\"AAA\", \"BBB\", \"CCC\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n\n        assert_adjacents(\u0026handler, (0, 0), vec![(0, 1), (1, 0), (1, 1)]);\n        assert_adjacents(\u0026handler, (0, 1), vec![(0, 0), (0, 2), (1, 0), (1, 1), (1, 2)]);\n        assert_adjacents(\u0026handler, (0, 2), vec![(0, 1), (1, 1), (1, 2)]);\n        assert_adjacents(\u0026handler, (1, 0), vec![(0, 0), (0, 1), (1, 1), (2, 0), (2, 1)]);\n        assert_adjacents(\u0026handler, (1, 1), vec![(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]);\n        assert_adjacents(\u0026handler, (1, 2), vec![(0, 1), (0, 2), (1, 1), (2, 1), (2, 2)]);\n        assert_adjacents(\u0026handler, (2, 0), vec![(1, 0), (1, 1), (2, 1),]);\n        assert_adjacents(\u0026handler, (2, 1), vec![(1, 0), (1, 1), (1, 2), (2, 0), (2, 2)]);\n        assert_adjacents(\u0026handler, (2, 2), vec![(1, 1), (1, 2), (2, 1)]);\n    }\n\n    #[test]\n    fn test_is_star_adjacent() {\n        let parser = GridParser::try_from(vec![\"AAA\", \"BBB\", \"CCC\"]).unwrap();\n        let handler = GridHandler::new(\u0026parser, 1);\n        let mut grid = Grid::from(\u0026handler);\n\n        let line_column = LineColumn::new(0, 0);\n        assert!(!handler.is_star_adjacent(\u0026grid, line_column));\n\n        let adjacent_line_column = LineColumn::new(1, 1);\n        grid.cell_mut(adjacent_line_column).value = crate::CellValue::Star;\n        assert!(handler.is_star_adjacent(\u0026grid, line_column));\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":33,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":34,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":35,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":36,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":37,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":40,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":42,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":43,"address":[],"length":0,"stats":{"Line":17437937757178560512}},{"line":44,"address":[],"length":0,"stats":{"Line":17437937757178560512}},{"line":45,"address":[],"length":0,"stats":{"Line":17437937757178560512}},{"line":46,"address":[],"length":0,"stats":{"Line":17437937757178560512}},{"line":50,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":51,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":52,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":56,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":11961560610296037376}},{"line":60,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":61,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":67,"address":[],"length":0,"stats":{"Line":11961560610296037376}},{"line":68,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":69,"address":[],"length":0,"stats":{"Line":7854277750134145024}},{"line":70,"address":[],"length":0,"stats":{"Line":9151314442816847872}},{"line":72,"address":[],"length":0,"stats":{"Line":7998392938210000906}},{"line":76,"address":[],"length":0,"stats":{"Line":3963167672086036481}},{"line":85,"address":[],"length":0,"stats":{"Line":18158513697557839873}},{"line":86,"address":[],"length":0,"stats":{"Line":18158513697557839873}},{"line":91,"address":[],"length":0,"stats":{"Line":15780613094306224748}},{"line":92,"address":[],"length":0,"stats":{"Line":15780613094306224748}},{"line":97,"address":[],"length":0,"stats":{"Line":4539628424389498485}},{"line":98,"address":[],"length":0,"stats":{"Line":4539628424389498485}},{"line":103,"address":[],"length":0,"stats":{"Line":14915921965851089711}},{"line":104,"address":[],"length":0,"stats":{"Line":14915921965851089711}},{"line":109,"address":[],"length":0,"stats":{"Line":15420325124116578444}},{"line":110,"address":[],"length":0,"stats":{"Line":15420325124116578444}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":4323455642275676178}},{"line":130,"address":[],"length":0,"stats":{"Line":4323455642275676178}},{"line":131,"address":[],"length":0,"stats":{"Line":4323455642275676178}},{"line":133,"address":[],"length":0,"stats":{"Line":4323455642275676178}},{"line":134,"address":[],"length":0,"stats":{"Line":3746994889972254176}},{"line":136,"address":[],"length":0,"stats":{"Line":3891110078048111376}},{"line":137,"address":[],"length":0,"stats":{"Line":144115188075857200}},{"line":140,"address":[],"length":0,"stats":{"Line":11529215046068472417}},{"line":141,"address":[],"length":0,"stats":{"Line":7782220156096218241}},{"line":145,"address":[],"length":0,"stats":{"Line":4323455642275676970}},{"line":146,"address":[],"length":0,"stats":{"Line":2305843009213694136}},{"line":148,"address":[],"length":0,"stats":{"Line":14411518807585588696}},{"line":149,"address":[],"length":0,"stats":{"Line":12105675798371894560}},{"line":154,"address":[],"length":0,"stats":{"Line":13835058055282164882}},{"line":156,"address":[],"length":0,"stats":{"Line":13330654897016670645}},{"line":157,"address":[],"length":0,"stats":{"Line":17942340915444057379}},{"line":161,"address":[],"length":0,"stats":{"Line":16717361816799282291}},{"line":162,"address":[],"length":0,"stats":{"Line":16717361816799282291}},{"line":169,"address":[],"length":0,"stats":{"Line":144115188075857175}},{"line":170,"address":[],"length":0,"stats":{"Line":504403158265496855}},{"line":171,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":172,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":180,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":181,"address":[],"length":0,"stats":{"Line":14483576401623515139}},{"line":182,"address":[],"length":0,"stats":{"Line":3819052484010180614}},{"line":183,"address":[],"length":0,"stats":{"Line":14627691589699371011}},{"line":184,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":188,"address":[],"length":0,"stats":{"Line":3674937295934324743}},{"line":195,"address":[],"length":0,"stats":{"Line":2305843009213693998}},{"line":196,"address":[],"length":0,"stats":{"Line":2305843009213693998}},{"line":197,"address":[],"length":0,"stats":{"Line":2305843009213693998}},{"line":199,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":200,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":2305843009213693953}},{"line":205,"address":[],"length":0,"stats":{"Line":2305843009213693953}},{"line":206,"address":[],"length":0,"stats":{"Line":2305843009213693953}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":211,"address":[],"length":0,"stats":{"Line":2305843009213693998}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":6917529027641081857}},{"line":217,"address":[],"length":0,"stats":{"Line":6917529027641081857}},{"line":218,"address":[],"length":0,"stats":{"Line":6917529027641081857}},{"line":219,"address":[],"length":0,"stats":{"Line":6917529027641081857}},{"line":220,"address":[],"length":0,"stats":{"Line":14123288431433875464}},{"line":221,"address":[],"length":0,"stats":{"Line":6557241057451442168}},{"line":222,"address":[],"length":0,"stats":{"Line":4683743612465315841}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":2305843009213693953}}],"covered":88,"coverable":99},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_parser.rs"],"content":"//! Parser des lignes 'textuelles' de définition d'une grille.\r\n//!\r\n//! Un fichier au format 'texte' est utilisé pour définir la grille initiale.\r\n//!\r\n//! Dans ce fichier, chaque ligne de texte correspond à une ligne de la grille. Les différentes régions sont identifiées par une 'lettre' distincte dans la case correspondante.\r\n//!\r\n//! Les lignes 'vides' ou qui commencent par l'un des caractères suivants sont ignorées : '*', '#', '/' (considérées comme d'éventuels commentaires dans le fichier).\r\n//!\r\n//! Chaque ligne 'utile' de ce fichier doit définir le même nombre de cases. Elles doivent donc toutes avoir la même longueur.\r\n//!\r\n//! Par exemple :\r\n//!\r\n//! ```text\r\n//! # Exemple de grille 1★\r\n//! ABBBB\r\n//! ABBBB\r\n//! CCBBB\r\n//! DDDDD\r\n//! DEEED\r\n//! ```\r\n\r\nuse std::collections::HashSet;\r\n\r\nuse crate::CellValue;\r\nuse crate::GridCell;\r\nuse crate::GridParserChecker;\r\nuse crate::LineColumn;\r\nuse crate::Region;\r\n\r\n/// Caractères de commentaire au début d'une ligne du fichier pour une grille à résoudre\r\npub const COMMENT_CHARS: [char; 3] = ['#', ';', '@'];\r\n\r\n/// Caractères non admissibles comme symboles d'une région\r\nconst ILLEGAL_REGION_CHARS: [char; 4] = [' ', '\\t', '\\n', '\\r'];\r\n\r\n/// Ligne de la grille\r\n#[derive(Clone, Debug, Default)]\r\nstruct ParsedLine(Vec\u003cGridCell\u003e);\r\n\r\n/// Grille\r\n#[derive(Clone, Debug, Default)]\r\nstruct ParsedGrid(Vec\u003cParsedLine\u003e);\r\n\r\n/// Grid parser\r\n#[derive(Clone, Debug, Default)]\r\npub struct GridParser {\r\n    /// Symboles identifiés comme 'région' dans la grille\r\n    regions: HashSet\u003cRegion\u003e,\r\n\r\n    /// Grille parsée\r\n    parsed_grid: ParsedGrid,\r\n}\r\n\r\nimpl TryFrom\u003c\u0026Vec\u003cString\u003e\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: \u0026Vec\u003cString\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        let mut grid_parsed = Self::default();\r\n        // Parsing des lignes de la définition de la grille\r\n        for (num_line, text_line) in value.iter().enumerate() {\r\n            let text_line = text_line.trim();\r\n            if !text_line.is_empty() \u0026\u0026 !text_line.starts_with(COMMENT_CHARS) {\r\n                if let Err(e) = grid_parsed.parse_text_line(text_line) {\r\n                    return Err(format!(\r\n                        \"Erreur à la ligne #{} '{}': {}\",\r\n                        num_line + 1,\r\n                        text_line,\r\n                        e\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Des régions identifiées ?\r\n        if grid_parsed.regions.is_empty() || grid_parsed.parsed_grid.0.is_empty() {\r\n            return Err(\"La grille n'a aucune région définie\".to_string());\r\n        }\r\n\r\n        // Contrôle de la grille parsée\r\n        let checker = GridParserChecker::new(grid_parsed.clone());\r\n        checker.check()?;\r\n\r\n        Ok(grid_parsed)\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003cVec\u003cString\u003e\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: Vec\u003cString\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        Self::try_from(\u0026value)\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003c\u0026[String]\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: \u0026[String]) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        Self::try_from(value.to_vec())\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003c\u0026str\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        let lines: Vec\u003cString\u003e = value.split('\\n').map(|s: \u0026str| s.to_string()).collect();\r\n        Self::try_from(\u0026lines)\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003cVec\u003c\u0026str\u003e\u003e for GridParser {\r\n    type Error = String;\r\n\r\n    fn try_from(value: Vec\u003c\u0026str\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        let lines: Vec\u003cString\u003e = value.iter().map(|\u0026s: \u0026\u0026str| s.to_string()).collect();\r\n        Self::try_from(lines)\r\n    }\r\n}\r\n\r\nimpl GridParser {\r\n    /// Nombre de lignes dans la grille parsée\r\n    #[must_use]\r\n    pub fn nb_lines(\u0026self) -\u003e usize {\r\n        self.parsed_grid.0.len()\r\n    }\r\n\r\n    /// Nombre de colonnes dans la grille parsée\r\n    #[must_use]\r\n    pub fn nb_columns(\u0026self) -\u003e usize {\r\n        self.parsed_grid.0[0].0.len()\r\n    }\r\n\r\n    /// Liste des régions de la grille parsée\r\n    #[must_use]\r\n    pub fn regions(\u0026self) -\u003e Vec\u003cRegion\u003e {\r\n        self.regions.iter().copied().collect()\r\n    }\r\n\r\n    /// Retourne la case de la grille en (line, column) (si existe)\r\n    #[must_use]\r\n    pub fn cell(\u0026self, line_column: LineColumn) -\u003e Option\u003cGridCell\u003e {\r\n        if line_column.line \u003c self.nb_lines() \u0026\u0026 line_column.column \u003c self.nb_columns() {\r\n            Some(self.parsed_grid.0[line_column.line].0[line_column.column].clone())\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// région de la case (line, column)\r\n    #[must_use]\r\n    pub fn cell_region(\u0026self, line_column: LineColumn) -\u003e Region {\r\n        self.parsed_grid.0[line_column.line].0[line_column.column].region\r\n    }\r\n\r\n    /// Liste des cases d'une grille parsée\r\n    #[must_use]\r\n    pub fn list_cells(\u0026self) -\u003e Vec\u003cGridCell\u003e {\r\n        let mut cells = vec![];\r\n        for line_parsed in \u0026self.parsed_grid.0 {\r\n            for cell in \u0026line_parsed.0 {\r\n                cells.push(cell.clone());\r\n            }\r\n        }\r\n        cells\r\n    }\r\n\r\n    /// Liste des cases d'une région d'une grille parsée\r\n    #[must_use]\r\n    pub fn region_cells(\u0026self, region: Region) -\u003e Vec\u003cGridCell\u003e {\r\n        self.list_cells()\r\n            .iter()\r\n            .filter(|c| c.region == region)\r\n            .cloned()\r\n            .collect()\r\n    }\r\n\r\n    /// Analyse une ligne textuelle de définition d'une ligne la grille.\r\n    /// Ici, la ligne textuelle n'est pas vide et n'est pas un commentaire.\r\n    fn parse_text_line(\u0026mut self, text_line: \u0026str) -\u003e Result\u003c(), String\u003e {\r\n        let mut line_parsed = ParsedLine::default();\r\n        let line = self.parsed_grid.0.len();\r\n\r\n        // Parsing de la ligne\r\n        for (column, region) in text_line.chars().enumerate() {\r\n            if ILLEGAL_REGION_CHARS.contains(\u0026region) {\r\n                return Err(format!(\r\n                    \"Le caractère '{region}' n'est pas valide pour identifier une région\"\r\n                ));\r\n            }\r\n            self.regions.insert(region);\r\n            let cur_cell = GridCell {\r\n                line_column: LineColumn::from((line, column)),\r\n                region,\r\n                value: CellValue::Unknown,\r\n            };\r\n            line_parsed.0.push(cur_cell);\r\n        }\r\n\r\n        // Nombre de colonnes correct ?\r\n        if !self.parsed_grid.0.is_empty() \u0026\u0026 self.parsed_grid.0[0].0.len() != line_parsed.0.len() {\r\n            return Err(\"La ligne de la grille n'est pas la même longueur\".to_string());\r\n        }\r\n\r\n        // Ajout de la ligne à la grille\r\n        self.parsed_grid.0.push(line_parsed);\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    #[allow(clippy::cognitive_complexity)]\r\n    fn test_try_from_ok() {\r\n        let result_grid = GridParser::try_from(\r\n            \"\r\n            # Exemple de grille 1★\r\n            ABBBB\r\n            ABBBB\r\n            CCBBB\r\n            DDDDD\r\n            DEEED\r\n        \",\r\n        );\r\n        assert!(result_grid.is_ok());\r\n\r\n        let grid = result_grid.unwrap();\r\n        assert_eq!(grid.nb_lines(), 5);\r\n        assert_eq!(grid.nb_columns(), 5);\r\n\r\n        // Région A\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 0)), 'A');\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 0)), 'A');\r\n\r\n        // Région B\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 1)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 2)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 3)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(0, 4)), 'B');\r\n\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 1)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 2)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 3)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(1, 4)), 'B');\r\n\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 2)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 3)), 'B');\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 4)), 'B');\r\n\r\n        // Région C\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 0)), 'C');\r\n        assert_eq!(grid.cell_region(LineColumn::new(2, 1)), 'C');\r\n\r\n        // Région D\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 0)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 1)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 2)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 3)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(3, 4)), 'D');\r\n\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 0)), 'D');\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 4)), 'D');\r\n\r\n        // Région E\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 1)), 'E');\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 2)), 'E');\r\n        assert_eq!(grid.cell_region(LineColumn::new(4, 3)), 'E');\r\n    }\r\n\r\n    // Toutes les grilles suivantes sont invalides\r\n    const INVALID_GRIDS: [\u0026str; 4] = [\r\n        \"\r\n            # Grille invalide: Vide de toute définition\r\n            # Manque des définitions de symboles\r\n        \",\r\n        \"\r\n            # Grille invalide: Symboles non admissibles\r\n            A\\tA\r\n            BBB\r\n        \",\r\n        \"\r\n            # Grille invalide: Nombre inconsistant de colonnes\r\n            AAA\r\n            BB\r\n        \",\r\n        \"\r\n            # Grille invalide: Zone inconsistante\r\n            AAA\r\n            BBA\r\n            AAB\r\n        \",\r\n    ];\r\n\r\n    #[test]\r\n    fn test_try_from_nok() {\r\n        for s in INVALID_GRIDS {\r\n            let grid = GridParser::try_from(s);\r\n            assert!(grid.is_err());\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":4323455642275676182}},{"line":58,"address":[],"length":0,"stats":{"Line":4323455642275676182}},{"line":60,"address":[],"length":0,"stats":{"Line":22}},{"line":61,"address":[],"length":0,"stats":{"Line":14123288431433875456}},{"line":62,"address":[],"length":0,"stats":{"Line":8502796096475496447}},{"line":63,"address":[],"length":0,"stats":{"Line":8935141660703064063}},{"line":64,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":75,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":81,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":83,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":90,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":91,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":107,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":108,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":115,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":116,"address":[],"length":0,"stats":{"Line":14339461213547659265}},{"line":117,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":124,"address":[],"length":0,"stats":{"Line":17077649786988920832}},{"line":125,"address":[],"length":0,"stats":{"Line":17077649786988920832}},{"line":130,"address":[],"length":0,"stats":{"Line":17077649786988920889}},{"line":131,"address":[],"length":0,"stats":{"Line":17077649786988920889}},{"line":136,"address":[],"length":0,"stats":{"Line":12033618204333965369}},{"line":137,"address":[],"length":0,"stats":{"Line":12033618204333965369}},{"line":142,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":143,"address":[],"length":0,"stats":{"Line":3602879701896396846}},{"line":144,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":1801439850948198446}},{"line":153,"address":[],"length":0,"stats":{"Line":1801439850948198446}},{"line":158,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":159,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":160,"address":[],"length":0,"stats":{"Line":10664523917613334478}},{"line":161,"address":[],"length":0,"stats":{"Line":2161727821137838046}},{"line":162,"address":[],"length":0,"stats":{"Line":7493989779944505352}},{"line":165,"address":[],"length":0,"stats":{"Line":14411518807585587266}},{"line":170,"address":[],"length":0,"stats":{"Line":14411518807585587741}},{"line":171,"address":[],"length":0,"stats":{"Line":14411518807585587741}},{"line":173,"address":[],"length":0,"stats":{"Line":17870283321406129210}},{"line":180,"address":[],"length":0,"stats":{"Line":8791026472627208200}},{"line":181,"address":[],"length":0,"stats":{"Line":8791026472627208200}},{"line":182,"address":[],"length":0,"stats":{"Line":8791026472627208200}},{"line":185,"address":[],"length":0,"stats":{"Line":2449958197289549832}},{"line":186,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":187,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":188,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":191,"address":[],"length":0,"stats":{"Line":12033618204333965311}},{"line":193,"address":[],"length":0,"stats":{"Line":12033618204333965311}},{"line":197,"address":[],"length":0,"stats":{"Line":12033618204333965311}},{"line":201,"address":[],"length":0,"stats":{"Line":13258597302978740225}},{"line":202,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":206,"address":[],"length":0,"stats":{"Line":8646911284551352321}},{"line":207,"address":[],"length":0,"stats":{"Line":8646911284551352321}}],"covered":58,"coverable":61},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_parser_checker.rs"],"content":"//! Vérifie la validité d'une grille parsée\n\nuse super::LineColumn;\nuse super::Region;\nuse super::{GridCell, GridParser};\n\npub struct GridParserChecker {\n    /// Grille parsée\n    parser: GridParser,\n}\n\nimpl GridParserChecker {\n    /// Constructeur d'un 'checker' d'une grille parsée\n    pub const fn new(parser: GridParser) -\u003e Self {\n        Self { parser }\n    }\n\n    /// Vérifie la validité d'une grille parsée\n    pub fn check(\u0026self) -\u003e Result\u003c(), String\u003e {\n        for region in \u0026self.parser.regions() {\n            if !self.region_ok(*region) {\n                return Err(format!(\n                    \"La region '{region}' n'est pas un bloc consistant dans cette grille\",\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Vérifie la validité d'une région de la grille\n    fn region_ok(\u0026self, region: Region) -\u003e bool {\n        // Liste des cases de la région\n        let all_region_cells = self.parser.region_cells(region);\n        if all_region_cells.is_empty() {\n            return false;\n        }\n\n        // Première case de la region\n        let first_cell = all_region_cells[0].clone();\n\n        // On construit la liste de toutes les cases adjacentes à cette 'first_cell'\n        // Pour cela, on a une liste des cases à parcourir qu'on initialise avec first_cell et qu'on\n        // enrichit des cases adjacentes qui sont dans la zone.\n        let mut cells_to_check = vec![first_cell];\n        let mut cells_checked = vec![];\n\n        while let Some(current_cell) = cells_to_check.pop() {\n            // Traitement d'une case à vérifier de la région\n            if !cells_checked.contains(\u0026current_cell) {\n                // Pas déjà vérifiée...\n                cells_checked.push(current_cell.clone());\n\n                // Liste des cases adjacentes à cette case dans la région...\n                let adjacent_region_cells = self.adjacent_region_cells(\u0026current_cell);\n\n                // ... qu'on ajoute à la liste des cases à traiter si pas déjà traitées\n                for adjacent_region_cell in \u0026adjacent_region_cells {\n                    if !cells_checked.contains(adjacent_region_cell) {\n                        cells_to_check.push(adjacent_region_cell.clone());\n                    }\n                }\n            }\n        }\n\n        // Ici, 'cells_checked' contient toutes les cases de la region.\n        // On doit en avoir le même nombre que celles de la grille\n        cells_checked.len() == all_region_cells.len()\n    }\n\n    // Liste des case adjacentes à une case\n    fn adjacent_cells(\u0026self, cell: \u0026GridCell) -\u003e Vec\u003cGridCell\u003e {\n        let mut cells = vec![];\n        let (line, column) = (cell.line_column.line, cell.line_column.column);\n\n        // North ?\n        if line \u003e 0 {\n            cells.push(self.parser.cell(LineColumn::new(line - 1, column)).unwrap());\n        }\n\n        // South ?\n        if line \u003c self.parser.nb_lines() - 1 {\n            cells.push(self.parser.cell(LineColumn::new(line + 1, column)).unwrap());\n        }\n\n        // West ?\n        if column \u003e 0 {\n            cells.push(self.parser.cell(LineColumn::new(line, column - 1)).unwrap());\n        }\n\n        // East ?\n        if column \u003c self.parser.nb_columns() - 1 {\n            cells.push(self.parser.cell(LineColumn::new(line, column + 1)).unwrap());\n        }\n\n        cells\n    }\n\n    /// Liste des cases adjacentes à la case (line, column) de la même région\n    fn adjacent_region_cells(\u0026self, cell: \u0026GridCell) -\u003e Vec\u003cGridCell\u003e {\n        self.adjacent_cells(cell)\n            .iter()\n            .filter(|c| c.region == cell.region)\n            .cloned()\n            .collect()\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":4107282860161892544}},{"line":19,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":20,"address":[],"length":0,"stats":{"Line":12538021362599460864}},{"line":21,"address":[],"length":0,"stats":{"Line":8430738502437568512}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":28,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":32,"address":[],"length":0,"stats":{"Line":8430738502437568513}},{"line":34,"address":[],"length":0,"stats":{"Line":8430738502437568513}},{"line":35,"address":[],"length":0,"stats":{"Line":8430738502437568513}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":8430738502437568512}},{"line":45,"address":[],"length":0,"stats":{"Line":8430738502437568512}},{"line":46,"address":[],"length":0,"stats":{"Line":8430738502437568512}},{"line":48,"address":[],"length":0,"stats":{"Line":15636497906230362118}},{"line":52,"address":[],"length":0,"stats":{"Line":11240984669916758018}},{"line":55,"address":[],"length":0,"stats":{"Line":11240984669916758018}},{"line":58,"address":[],"length":0,"stats":{"Line":10376293541461622828}},{"line":59,"address":[],"length":0,"stats":{"Line":13618885273168379915}},{"line":60,"address":[],"length":0,"stats":{"Line":13618885273168379915}},{"line":68,"address":[],"length":0,"stats":{"Line":8430738502437568512}},{"line":72,"address":[],"length":0,"stats":{"Line":11240984669916758027}},{"line":73,"address":[],"length":0,"stats":{"Line":11240984669916758027}},{"line":74,"address":[],"length":0,"stats":{"Line":11240984669916758027}},{"line":77,"address":[],"length":0,"stats":{"Line":13907115649320091669}},{"line":78,"address":[],"length":0,"stats":{"Line":2666130979403333642}},{"line":82,"address":[],"length":0,"stats":{"Line":14123288431433875476}},{"line":83,"address":[],"length":0,"stats":{"Line":2882303761517117449}},{"line":87,"address":[],"length":0,"stats":{"Line":14051230837395947540}},{"line":88,"address":[],"length":0,"stats":{"Line":2810246167479189513}},{"line":92,"address":[],"length":0,"stats":{"Line":13979173243358019604}},{"line":93,"address":[],"length":0,"stats":{"Line":2738188573441261577}},{"line":96,"address":[],"length":0,"stats":{"Line":11240984669916758027}},{"line":100,"address":[],"length":0,"stats":{"Line":11240984669916758025}},{"line":101,"address":[],"length":0,"stats":{"Line":11240984669916758025}},{"line":103,"address":[],"length":0,"stats":{"Line":15132094747964866578}}],"covered":36,"coverable":36},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","grid_surfer.rs"],"content":"//! [`Surfer`] permet de déterminer une façon de naviguer à travers la grille.\u003cbr\u003e\n//!\n//! Applicable sur un objet [`GridHandler`] associé à une grille définie par un [`Grid`].\n\nuse std::fmt::Display;\nuse std::ops::RangeInclusive;\n\nuse crate::line_column::{display_column, display_line};\nuse crate::CellValue;\nuse crate::Grid;\nuse crate::GridCell;\nuse crate::GridHandler;\nuse crate::LineColumn;\nuse crate::Region;\n\n/// Navigation dans la grille\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum GridSurfer {\n    /// Navigation sur toutes les case de la grille\n    AllCells,\n\n    /// Navigation sur toutes les cases d'une région\n    Region(Region),\n\n    /// Navigation sur toutes les cases adjacentes à une case donnée (y compris les diagonales)\n    Adjacent(LineColumn),\n\n    /// Navigation sur toutes les cases d'un ligne\n    Line(usize),\n\n    /// Navigation sur toutes les cases d'une colonne\n    Column(usize),\n\n    /// Navigation sur plusieurs lignes\n    Lines(RangeInclusive\u003cusize\u003e),\n\n    /// Navigation sur plusieurs colonnes\n    Columns(RangeInclusive\u003cusize\u003e),\n}\n\nimpl Display for GridSurfer {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::AllCells =\u003e write!(f, \"Toute la grille\"),\n            Self::Region(region) =\u003e write!(f, \"Region '{region}'\"),\n            Self::Adjacent(line_column) =\u003e write!(f, \"Cases adjacentes à '{line_column}'\"),\n            Self::Line(line) =\u003e write!(f, \"Ligne {}\", display_line(*line)),\n            Self::Column(column) =\u003e write!(f, \"Colonne {}\", display_column(*column)),\n            Self::Lines(range) =\u003e {\n                if *range.start() == *range.end() {\n                    write!(f, \"Ligne {}\", display_line(*range.start()))\n                } else {\n                    write!(\n                        f,\n                        \"Lignes {}-{}\",\n                        display_line(*range.start()),\n                        display_line(*range.end())\n                    )\n                }\n            }\n            Self::Columns(range) =\u003e {\n                if *range.start() == *range.end() {\n                    write!(f, \"Colonne {}\", display_column(*range.start()))\n                } else {\n                    write!(\n                        f,\n                        \"Colonnes {}-{}\",\n                        display_column(*range.start()),\n                        display_column(*range.end())\n                    )\n                }\n            }\n        }\n    }\n}\n\nimpl GridHandler {\n    /// Retourne la liste des cases d'une grille qui satisfont à un certain critère.\u003cbr\u003e\n    /// Le critère est défini par l'énumération `GridSurfer`\n    #[must_use]\n    pub fn surfer(\u0026self, grid: \u0026Grid, surfer: \u0026GridSurfer) -\u003e Vec\u003cLineColumn\u003e {\n        let mut cells = Vec::new();\n        for line in 0..self.nb_lines() {\n            for column in 0..self.nb_columns() {\n                let line_column = LineColumn::new(line, column);\n                let cell: \u0026GridCell = grid.cell(line_column);\n                let cell_is_matching = match surfer {\n                    // Toutes les case de la grille\n                    GridSurfer::AllCells =\u003e true,\n                    // Toutes les cases d'une région\n                    GridSurfer::Region(region) =\u003e cell.region == *region,\n                    // Toutes les cases adjacentes à une case donnée (y compris les diagonales)\n                    GridSurfer::Adjacent(line_column) =\u003e {\n                        let adjacent_cells = self.adjacent_cells(*line_column);\n                        adjacent_cells\n                            .iter()\n                            .any(|cell| cell.line == line \u0026\u0026 cell.column == column)\n                    }\n                    // Toutes les cases d'une ligne\n                    GridSurfer::Line(select_line) =\u003e *select_line == line,\n                    // Toutes les cases d'une colonne\n                    GridSurfer::Column(select_column) =\u003e *select_column == column,\n                    // Toutes les cases de plusieurs lignes\n                    GridSurfer::Lines(line_range) =\u003e line_range.contains(\u0026line),\n                    // Toutes les cases de plusieurs colonnes\n                    GridSurfer::Columns(column_range) =\u003e column_range.contains(\u0026column),\n                };\n                if cell_is_matching {\n                    cells.push(line_column);\n                }\n            }\n        }\n\n        cells\n    }\n\n    /// Retourne le nombre de cases sans la zone définie par le `GridSurfer`\n    #[must_use]\n    pub fn surfer_cells_count(\u0026self, grid: \u0026Grid, surfer: \u0026GridSurfer) -\u003e usize {\n        self.surfer(grid, surfer).len()\n    }\n\n    /// Retourne le nombre de cases contenant une valeur particulière dans la zone définie par le `GridSurfer`\n    #[must_use]\n    pub fn surfer_cells_with_value_count(\n        \u0026self,\n        grid: \u0026Grid,\n        surfer: \u0026GridSurfer,\n        value: \u0026CellValue,\n    ) -\u003e usize {\n        self.surfer(grid, surfer)\n            .iter()\n            .filter(|line_column| grid.cell(**line_column).value == *value)\n            .count()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use crate::GridParser;\n\n    // Construction d'un objet GridHandler et d'un Grid à partir d'une grille de test\n    fn get_test_grid() -\u003e (GridHandler, Grid) {\n        let parser =\n            GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\n        let grid_handler = GridHandler::new(\u0026parser, 1);\n        let grid = Grid::from(\u0026grid_handler);\n        (grid_handler, grid)\n    }\n\n    #[test]\n    fn test_all_cells() {\n        let (grid_handler, grid) = get_test_grid();\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::AllCells);\n        assert_eq!(\n            surfer.len(),\n            grid_handler.nb_lines() * grid_handler.nb_columns()\n        );\n    }\n\n    #[test]\n    fn test_region() {\n        let (grid_handler, grid) = get_test_grid();\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Region('A'));\n        assert_eq!(surfer, vec![LineColumn::new(0, 0), LineColumn::new(1, 0)]);\n    }\n\n    #[test]\n    fn test_adjacent() {\n        let (grid_handler, grid) = get_test_grid();\n        // 8 cases adjacentes à la case (2, 2) au milieu de la grille\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Adjacent(LineColumn::new(2, 2)));\n        assert_eq!(surfer.len(), 8);\n    }\n\n    #[test]\n    fn test_line() {\n        let (grid_handler, grid) = get_test_grid();\n        // 5 cases de la 2eme ligne\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Line(1));\n        assert_eq!(surfer.len(), 5);\n        assert_eq!(\n            surfer\n                .iter()\n                .filter(|line_column| line_column.line == 1)\n                .count(),\n            5\n        );\n    }\n\n    #[test]\n    fn test_column() {\n        let (grid_handler, grid) = get_test_grid();\n        // 5 cases de la 2eme colonne\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Column(1));\n        assert_eq!(surfer.len(), 5);\n        assert_eq!(\n            surfer\n                .iter()\n                .filter(|line_column| line_column.column == 1)\n                .count(),\n            5\n        );\n    }\n\n    #[test]\n    fn test_multi_lines() {\n        let (grid_handler, grid) = get_test_grid();\n        // 15 cases de la 2eme, 3eme et 4eme lignes\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Lines(1..=3));\n        assert_eq!(surfer.len(), 15);\n        assert_eq!(\n            surfer\n                .iter()\n                .filter(|line_column| (1..=3).contains(\u0026line_column.line))\n                .count(),\n            15\n        );\n    }\n\n    #[test]\n    fn test_multi_columns() {\n        let (grid_handler, grid) = get_test_grid();\n        // 10 cases de la 4eme et dernière colonnes\n        let surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Columns(3..=4));\n        assert_eq!(surfer.len(), 10);\n        assert_eq!(\n            surfer\n                .iter()\n                .filter(|line_column| (3..=4).contains(\u0026line_column.column))\n                .count(),\n            10\n        );\n    }\n\n    #[test]\n    fn test_surfer_cells_count() {\n        let (grid_handler, grid) = get_test_grid();\n        assert_eq!(\n            grid_handler.surfer_cells_count(\u0026grid, \u0026GridSurfer::Region('A')),\n            2\n        );\n    }\n\n    #[test]\n    fn test_surfer_cells_with_value_count() {\n        let (grid_handler, mut grid) = get_test_grid();\n\n        // Par défaut, toutes les cases sont à la valeur `CellValue::Unknown`\n        // On place une étoile et une case qui ne peut pas contenir d'étoile sur la 1ere ligne\n        grid.cell_mut(LineColumn::new(0, 1)).value = CellValue::Star;\n        grid.cell_mut(LineColumn::new(0, 3)).value = CellValue::NoStar;\n\n        assert_eq!(\n            grid_handler.surfer_cells_with_value_count(\n                \u0026grid,\n                \u0026GridSurfer::Line(0),\n                \u0026CellValue::Star\n            ),\n            1\n        );\n        assert_eq!(\n            grid_handler.surfer_cells_with_value_count(\n                \u0026grid,\n                \u0026GridSurfer::Line(0),\n                \u0026CellValue::NoStar\n            ),\n            1\n        );\n        assert_eq!(\n            grid_handler.surfer_cells_with_value_count(\n                \u0026grid,\n                \u0026GridSurfer::Line(0),\n                \u0026CellValue::Unknown\n            ),\n            3\n        );\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639691}},{"line":43,"address":[],"length":0,"stats":{"Line":360287970189639691}},{"line":44,"address":[],"length":0,"stats":{"Line":11}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":15852670688344145926}},{"line":70,"address":[],"length":0,"stats":{"Line":15852670688344145926}},{"line":71,"address":[],"length":0,"stats":{"Line":15276209936040726246}},{"line":72,"address":[],"length":0,"stats":{"Line":15852670688344153536}},{"line":73,"address":[],"length":0,"stats":{"Line":16429131440647573216}},{"line":74,"address":[],"length":0,"stats":{"Line":16429131440647573216}},{"line":75,"address":[],"length":0,"stats":{"Line":14411518807585594816}},{"line":77,"address":[],"length":0,"stats":{"Line":12177733392409230647}},{"line":79,"address":[],"length":0,"stats":{"Line":18086456103520219798}},{"line":81,"address":[],"length":0,"stats":{"Line":3602879701896498367}},{"line":82,"address":[],"length":0,"stats":{"Line":3602879701896498367}},{"line":83,"address":[],"length":0,"stats":{"Line":3602879701896498367}},{"line":85,"address":[],"length":0,"stats":{"Line":6196953087262005631}},{"line":88,"address":[],"length":0,"stats":{"Line":18158513697557839872}},{"line":90,"address":[],"length":0,"stats":{"Line":5620492334958473636}},{"line":92,"address":[],"length":0,"stats":{"Line":16357073846609730814}},{"line":94,"address":[],"length":0,"stats":{"Line":16212958658533786546}},{"line":96,"address":[],"length":0,"stats":{"Line":12321848580485677993}},{"line":97,"address":[],"length":0,"stats":{"Line":12321848580485677993}},{"line":102,"address":[],"length":0,"stats":{"Line":15852670688344180152}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037980356}},{"line":108,"address":[],"length":0,"stats":{"Line":72057594037980356}},{"line":113,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":119,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":121,"address":[],"length":0,"stats":{"Line":16212958658533785600}}],"covered":30,"coverable":40},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","lib.rs"],"content":"/*!\r\nStar Battle Solver\r\n\r\nStar Battle est un puzzle logique avec des règles simples et des solutions stimulantes.\r\n\r\nLes règles de Star Battle sont simples :\r\nVous devez placer des étoiles sur la grille selon ces règles :\r\n\r\n* 2 étoiles ne peuvent pas être adjacentes horizontalement, verticalement ou en diagonale.\r\n* Pour les puzzles 1★, vous devez placer 1 étoile sur chaque ligne, colonne et région.\r\n* Pour les puzzles 2★, les étoiles par ligne, colonne et région doivent être 2, etc.\r\n* Il existe également des puzzles 3★.\r\n\r\n## Sites internet\r\n\r\n* [Site en français](https://fr.puzzle-star-battle.com/)\r\n* [Vidéo en français](https://www.youtube.com/watch?v=dG-xkOYYkwY)\r\n* [Site en anglais](https://starbattle.puzzlebaron.com/)\r\n\r\n## [`Region`]\r\n\r\n[`Region`] est une zone de cases dans laquelle il faut également placer le nombre d'étoiles attendus.\u003cbr\u003e\r\nPour ce crate, une région est identifiée par un [`char`] issu de la formalisation textuelle reconnue par le [`GridParser`].\r\n\r\n## [`GridParser`]\r\n\r\n[`GridParser`] construit une grille depuis une formalisation textuelle d'une grille à résoudre.\r\n\r\nLe constructeur est une forme de [`TryFrom`] pour l'un des types suivants :\r\n\r\n* `TryFrom\u003c\u0026Vec\u003cString\u003e\u003e for Parser`\r\n* `TryFrom\u003cVec\u003cString\u003e\u003e for Parser`\r\n* `TryFrom\u003c\u0026[String]\u003e for Parser`\r\n* `TryFrom\u003cVec\u003c\u0026str\u003e\u003e for `\r\n* `TryFrom\u003c\u0026str\u003e for Parser`\r\n\r\nChaque ligne du texte (ou chaque élément du vecteur) correspond à une ligne de la grille à résoudre.\u003cbr\u003e\r\nLes différentes régions de la grille sont identifiées par des caractères distincts dans les cases correspondantes.\u003cbr\u003e\r\nLes espaces ou séparateurs équivalents (e.g. TAB) sont ignorés.\u003cbr\u003e\r\nLes lignes 'vides' ou qui débutent par l'un des caractères suivants sont ignorées : '*', '#' ou '/'\r\n(considérés comme d'éventuels commentaires).\u003cbr\u003e\r\n\r\n```rust\r\nuse star_battle::GridParser;\r\n\r\n// Représentation textuelle d'une grille de 5 lignes et 5 colonnes contenant 5 régions\r\n// distinctes repérées par les lettres 'A', 'B', 'C', 'D' et 'E'.\r\nassert!(GridParser::try_from(\"\r\n    ABBBB\r\n    ABBBB\r\n    CCBBB\r\n    DDDDD\r\n    DEEED\r\n\").is_ok());\r\n```\r\n\r\nLe [`GridParser`] est utilisé pour définir la grille initiale. La cohérence de la grille est vérifiée:\r\n\r\n* Syntaxe correcte dans le texte descriptif de la grille\r\n* Nombre cohérent de colonnes dans chaque ligne\r\n* Régions connexes dans la grille\r\n\r\n## [`LineColumn`]\r\n\r\n[`LineColumn`] repère une case dans la grille par ses coordonnées (`line`, `column`) base 0.\r\n\r\nLorsque les coordonnées d'une case sont affichées (`Display`), les colonnes sont référencées par les lettres\r\n'A', 'B', ... et les lignes par des chiffres'1', '2'.\u003cbr\u003e\r\nLa case (0, 0) en haut et à gauche de la grille correspond donc avec 'A1'.\r\n\r\n```rust\r\nuse star_battle::LineColumn;\r\n\r\nlet line_column = LineColumn::new(0, 1);\r\n\r\nassert_eq!(line_column.line(), 0);\r\nassert_eq!(line_column.column(), 1);\r\nassert_eq!(format!(\"{}\", line_column), \"B1\");\r\n```\r\n\r\n## [`CellValue`]\r\n\r\n[`CellValue`] définit une valeur possible d'une case de la grille parmi:\r\n\r\n* `Unknown` : Contenu inconnu de la case (valeur par défaut)\r\n* `Star` : La case contient une étoile\r\n* `NoStar` : La case ne peut pas contenir une étoile\r\n\r\n```rust\r\nuse star_battle::CellValue;\r\nassert_eq!(CellValue::default(), CellValue::Unknown);\r\n```\r\n\r\n## [`GridCell`]\r\n\r\n[`GridCell`] décrit une case de la grille parsée par [`GridParser`] ou gérée par [`Grid`]:\r\n\r\n* `line_column`: [`LineColumn`] de la case dans la grille (base 0)\r\n* `region`: [`Region`] de la case\r\n* `value`: [`CellValue`] de la case. Par défaut, `CellValue::Unknown`.\r\n\r\n```rust\r\nuse star_battle::{GridParser, LineColumn, CellValue};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\n\r\nassert_eq!(grid_parser.cell(LineColumn::new(0, 0)).unwrap().region, 'A');\r\nassert_eq!(grid_parser.cell(LineColumn::new(0, 0)).unwrap().value, CellValue::Unknown);\r\n```\r\n\r\n## [`GridHandler`]\r\n\r\n[`GridHandler`] définit les caractéristiques d'une grille à résoudre:\r\n\r\n* `nb_lines`: nombre de lignes de la grille\r\n* `nb_columns`: nombre de colonnes de la grille\r\n* `nb_stars`: nombre d'étoiles à placer dans chaque ligne, colonne et région de la grille\r\n* `regions`: liste des régions de la grille (par ordre de taille croissante)\r\n* `cell_region`: région d'une case de la grille\r\n\r\nLes contenus des cases de la grille ne sont pas définis dans la structure [`GridHandler`].\u003cbr\u003e\r\nC'est la structure [`Grid`] qui représente le contenu des cases de la grille.\r\n\r\nInitialement, le [`GridHandler`] est construite à partir d'un [`GridParser`] en indiquant le nombre d'étoiles à\r\nplacer sur chaque ligne, colonne et région.\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, LineColumn};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid = GridHandler::new(\u0026grid_parser, 1);\r\n\r\nassert_eq!(grid.nb_lines(), 5);\r\nassert_eq!(grid.nb_columns(), 5);\r\nassert_eq!(grid.nb_stars(), 1);\r\nassert_eq!(grid.regions().len(), 5);\r\nassert_eq!(grid.cell_region(LineColumn::new(0, 0)), 'A');\r\n```\r\n\r\nLa fonction [`GridHandler::is_done`] retourne `true` si toutes les cases de la grille ont une valeur définie.\r\n\r\n## [`Grid`]\r\n\r\n[`Grid`] est la structure avec le contenu des cases de la grille.\r\n\r\nCette structure est utilisée pour la resolution du jeu. Elle est allégée des informations détenues par la\r\nstructure associée [`GridHandler`]; Ce qui permet d'examiner des évolutions de la grille en optimisant\r\nl'occupation de mémoire.\r\n\r\nInitialement, la [`Grid`] est construite à partir d'un [`GridHandler`].\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet grid = Grid::from(\u0026grid_handler);\r\n\r\nassert_eq!(grid.nb_lines(), 5);\r\nassert_eq!(grid.nb_columns(), 5);\r\n```\r\n\r\nOn peut ainsi utiliser la structure [`Grid`] pour résoudre le jeu en clonant cette structure et en\r\npostulant sur la valeur des cases de la grille pour évaluer les possibilités.\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, LineColumn, CellValue};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet grid = Grid::from(\u0026grid_handler);\r\n\r\nlet mut grid_cloned = grid.clone();\r\nlet line_column = LineColumn::new(0, 0);\r\ngrid_cloned.cell_mut(line_column).value = CellValue::Star;\r\nassert_eq!(grid.cell(line_column).value, CellValue::Unknown);\r\nassert_eq!(grid_cloned.cell(line_column).value, CellValue::Star);\r\n```\r\n\r\n## [`GridSurfer`]\r\n\r\n[`GridSurfer`] est une  énumération qui permet de naviguer sur les case de la grille qui répondre à certains\r\ncritères pour parcourir les cases d'une grille.\r\n\r\n Cette énumération est applicable sur un objet [`GridHandler`] associé à une grille définie par un [`Grid`].\r\n\r\n On peut ainsi parcourir les cases de la grille suivant les critères suivants:\r\n\r\n* Toutes les cases de la grille\r\n* Toutes les cases d'une region\r\n* Toutes les cases adjacentes à une case donnée (y compris les diagonales)\r\n* Toutes les cases d'une ligne\r\n* Toutes les cases d'une colonne\r\n* Toutes les cases de plusieurs lignes consécutives\r\n* Toutes les cases de plusieurs colonnes consécutives\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, LineColumn, GridSurfer};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet grid = Grid::from(\u0026grid_handler);\r\n\r\n// Liste des cases d'une région\r\nlet grid_surfer = grid_handler.surfer(\u0026grid, \u0026GridSurfer::Region('A'));\r\nassert_eq!(grid_surfer, vec![LineColumn::new(0, 0), LineColumn::new(1, 0)]);\r\n```\r\n\r\n## [`BadRuleError`]\r\n\r\n[`BadRuleError`] identifie une situation qui invalide le contenu d'une grille.\r\n\r\nLa fonction [`check_bad_rules`] permet de vérifier qu'une une grille est valide ou non.\r\nCette fonction retourne une erreur [`BadRuleError`] si la grille n'est pas valide et `Ok(())` si la grille est valide.\r\n\r\nLes situations invalides étant :\r\n\r\n* 2 cases adjacentes contenant chacune une étoile\r\n* Une 'zone' qui contient trop d'étoiles\r\n* Une 'zone' dans laquelle il n'est pas possible de placer suffisamment d'étoiles\r\n\r\nIci une 'zone' étant :\r\n\r\n* Une [`Region`]\r\n* Une ligne de la grille\r\n* Une colonne de la grille\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, check_bad_rules};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet grid = Grid::from(\u0026grid_handler);\r\n\r\nassert!(check_bad_rules(\u0026grid_handler, \u0026grid).is_ok());\r\n```\r\n\r\n# [`GridAction`]\r\n\r\n[`GridAction`] représente une action possible sur une case de la grille :\r\n\r\n* Placer une étoile\r\n* Indiquer qu'une étoile n'est possible dans cette case\r\n* Indiquer que le contenu d'une case est inconnu\r\n\r\nCes actions sont liées au contenu possible d'une case de la grille défini par un [`CellValue`].\r\n\r\n[`GridAction`] implémente la méthode [`GridAction::apply_action`] qui permet d'appliquer une action sur une [`Grid`].\r\n\r\nSymétriquement, le module [`Grid`] implémente la méthode [`Grid::apply_action`] qui permet d'appliquer une\r\nde ces actions à une case de la grille.\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, CellValue, GridAction, LineColumn};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet mut grid = Grid::from(\u0026grid_handler);\r\n\r\ngrid.apply_action(\u0026GridAction::SetStar(LineColumn::new(1, 1)));\r\nassert_eq!(grid.cell(LineColumn::new(1, 1)).value, CellValue::Star);\r\n\r\nGridAction::SetNoStar(LineColumn::new(1, 1)).apply_action(\u0026mut grid);\r\nassert_eq!(grid.cell(LineColumn::new(1, 1)).value, CellValue::NoStar);\r\n```\r\n\r\n# [`GoodRule`]\r\n\r\n[`GoodRule`] identifie les règles qui permettent d'avancer dans la construction/résolution d\"une grille :\r\n\r\n* `NoStarAdjacentToStar(LineColumn, Vec\u003cGridAction\u003e)`:  Indique les cases adjacentes à une étoile qui ne peuvent\r\n   pas contenir une étoile et indique les actions à effectuer pour les définir\r\n* `ZoneNoStarCompleted`: Indique les cases restantes dans une zone ne peuvent pas être des étoiles\r\n* `ZoneStarCompleted`: Indique les cases restantes dans une zone sont forcement des étoiles\r\n* `InvariantWithZone(GridSurfer, Vec\u003cGridAction\u003e)`: Indique que quelle que soit la façon de placer les étoiles\r\n   dans une zone, des cases n'ont toujours qu'une seule et même possibilité\r\n\r\nLa fonction [`get_good_rule`] recherche une règle [`GoodRule`] applicable à une grille.\u003cbr\u003e\r\nCette fonction retourne une erreur [`BadRuleError`] si la grille n'est pas valide.\u003cbr\u003e\r\nSinon un `Option\u003cGoodRule\u003e` est retourné.\u003cbr\u003e\r\nNone signifie alors qu'aucune règle permettant d'avancer dans la construction de la grille n'a été trouvée.\r\n\r\nLes règles examinées sont :\r\n\r\n* Une case non définie et adjacente à une étoile ne peut pas être une étoile\r\n\r\n* Toutes les cases non définies dans une 'zone' (région, ligne ou colonne) qui possède déjà toutes ces étoiles\r\n  sont des cases qui ne peuvent pas contenir une étoile\r\n\r\n* S'il reste autant de cases non définies dans une 'zone' (région, ligne ou colonne) que d'étoiles manquantes\r\n  dans cette 'zone' alors ce sont forcément des étoiles\r\n\r\n* Si toutes les combinaisons possibles pour positioner les étoiles dans une région ont des cases toujours avec une\r\n  étoile (ou jamais une étoile) alors ces cases contiennent une étoile (ou ne peuvent pas contenir une étoile)\r\n\r\n* Si une case autour d'une région est toujours adjacente à une étoile pour toutes les combinaisons possibles d'étoiles\r\n  dans cette région alors cette case ne peut pas être des étoiles\r\n\r\n* On examine toutes les combinaisons de 1, 2, 3 ou 4 lignes ou colonnes qui sont occupées par max. 'n' régions :\r\n  S'il existe des cases de ces régions en dehors de ces 1, 2, 3 ou 4 lignes ou colonnes, elles ne peuvent pas\r\n  contenir une étoile puisque toutes les étoiles de ces régions sont forcement dans les 1, 2, 3 ou 4 lignes\r\n  ou colonnes examinés.\u003cbr\u003e\r\n  (cette règle est l'inverse de la suivante)\r\n\r\n* On examine toutes les combinaisons de 1, 2, 3 ou 4 régions qui occupent respectivement uniquement 1, 2, 3 ou 4 lignes\r\n  ou colonnes : S'il restent des cases n'appartenant pas à ces combinaisons dans ces lignes ou colonnes, elles ne\r\n  peuvent pas contenir une étoile.\u003cbr\u003e\r\n  (cette règle est l'inverse de la précédente)\r\n\r\n* Toutes les combinaisons possibles pour positionner une étoile dans une ligne ou colonne ont des\r\n  cases toujours avec une étoile ou jamais une étoile dans toutes les grilles possibles pour ces combinaisons\r\n\r\n* Toutes les combinaisons possibles pour positionner une étoile dans plusieurs ligne ou colonnes consécutives\r\n  (2, 3 ou 4) nt des cases toujours avec une étoile ou jamais une étoile dans toutes les grilles possibles\r\n  pour ces combinaisons\r\n\r\n```rust\r\nuse star_battle::{GridParser, GridHandler, Grid, get_good_rule};\r\n\r\nlet grid_parser = GridParser::try_from(vec![\"ABBBB\", \"ABBBB\", \"CCBBB\", \"DDDDD\", \"DEEED\"]).unwrap();\r\nlet grid_handler = GridHandler::new(\u0026grid_parser, 1);\r\nlet mut grid = Grid::from(\u0026grid_handler);\r\n\r\nlet ok_good_rule = get_good_rule(\u0026grid_handler, \u0026grid);\r\nassert!(ok_good_rule.is_ok());\r\nlet some_good_rule = ok_good_rule.unwrap();\r\nassert!(some_good_rule.is_some());\r\nlet good_rule = some_good_rule.unwrap();\r\ngrid.apply_good_rule(\u0026good_rule);\r\n```\r\n\r\n*/\r\n\r\n/// Une région est identifiée par un caractère.\r\npub type Region = char;\r\n\r\n// Modules\r\nmod cell_value;\r\nmod grid;\r\nmod grid_action;\r\nmod grid_bad_ruler;\r\nmod grid_cell;\r\nmod grid_good_ruler;\r\nmod grid_handler;\r\nmod grid_parser;\r\nmod grid_parser_checker;\r\nmod grid_surfer;\r\nmod line_column;\r\n\r\n// Internal\r\nuse grid_parser_checker::GridParserChecker;\r\nuse line_column::{display_column, display_line};\r\n\r\n// Exported\r\npub use cell_value::CellValue;\r\npub use grid::Grid;\r\npub use grid_action::GridAction;\r\npub use grid_bad_ruler::{check_bad_rules, BadRuleError};\r\npub use grid_cell::GridCell;\r\npub use grid_good_ruler::{get_good_rule, GoodRule};\r\npub use grid_handler::GridHandler;\r\npub use grid_parser::GridParser;\r\npub use grid_surfer::GridSurfer;\r\npub use line_column::LineColumn;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","line_column.rs"],"content":"//! Help for grid line and column coordinates.\n\nuse std::fmt::Display;\n\n/// Coordonnées d'une case de la grille (`line`, `column`) base 0\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]\npub struct LineColumn {\n    /// Numéro de la ligne (base 0). Ligne 0 correspond à la première ligne u haut.\n    pub line: usize,\n\n    /// Numéro de la colonne (base 0). Colonne 0 correspond à la première colonne de gauche\n    pub column: usize,\n}\n\nimpl From\u003c(usize, usize)\u003e for LineColumn {\n    fn from((line, column): (usize, usize)) -\u003e Self {\n        Self { line, column }\n    }\n}\n\n/// Affichage du numéro de ligne : 0, 1, ... devient '1', '2', ...\npub fn display_line(line: usize) -\u003e String {\n    format!(\"{}\", line + 1)\n}\n\n/// Affichage du numéro de colonne 0, 1, ... devient 'A', 'B', ...\npub fn display_column(column: usize) -\u003e String {\n    std::char::from_u32(u32::from(b'A') + u32::try_from(column).unwrap())\n        .unwrap()\n        .to_string()\n}\n\nimpl Display for LineColumn {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        // On choisit d'utiliser les lettres 'A', 'B', 'C', 'D', 'E' pour les lignes\n        // La case de la ligne 0, colonne 0 est donc 'A1'.\n        write!(\n            f,\n            \"{}{}\",\n            display_column(self.column),\n            display_line(self.line)\n        )\n    }\n}\n\nimpl LineColumn {\n    /// Constructeur\n    #[must_use]\n    pub const fn new(line: usize, column: usize) -\u003e Self {\n        Self { line, column }\n    }\n\n    /// Ligne de la case dans la grille (base 0)\n    #[must_use]\n    pub const fn line(\u0026self) -\u003e usize {\n        self.line\n    }\n\n    /// Colonne de la case dans la grille (base 0)\n    #[must_use]\n    pub const fn column(\u0026self) -\u003e usize {\n        self.column\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_from() {\n        let lc = LineColumn::from((1, 2));\n        assert_eq!(lc.line(), 1);\n        assert_eq!(lc.column(), 2);\n    }\n\n    #[test]\n    fn test_new() {\n        let lc = LineColumn::new(2, 1);\n        assert_eq!(lc.line(), 2);\n        assert_eq!(lc.column(), 1);\n    }\n\n    #[test]\n    fn test_eq() {\n        assert_eq!(LineColumn::new(1, 2), LineColumn::from((1, 2)));\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":12177733392411022095}},{"line":22,"address":[],"length":0,"stats":{"Line":2017612633061982218}},{"line":23,"address":[],"length":0,"stats":{"Line":2017612633061982218}},{"line":27,"address":[],"length":0,"stats":{"Line":1945555039024054273}},{"line":28,"address":[],"length":0,"stats":{"Line":1945555039024054273}},{"line":34,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":37,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":38,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":40,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":41,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":49,"address":[],"length":0,"stats":{"Line":14627691589699371008}},{"line":55,"address":[],"length":0,"stats":{"Line":144115188076173715}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188076173715}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":15,"coverable":15},{"path":["C:","\\","Users","PC-ASUS","Desktop","Trucs Denis","Essais Rust","star_battle","src","main.rs"],"content":"//! Star Battle Solver\n\nuse std::env;\nuse std::fs::File;\nuse std::io::Read;\n\nuse star_battle::get_good_rule;\nuse star_battle::Grid;\nuse star_battle::GridHandler;\nuse star_battle::GridParser;\n\n/// Message d'aide pour l'utilisateur\nconst HELP_MESSAGE: \u0026str = \"\nSTAR BATTLE Usage: ./star-battle \u003cgrille\u003e {\u003cnb étoiles\u003e}\n\n\u003cgrille\u003e est le nom d'un fichier contenant une grille à résoudre.\n\u003cnb_étoiles\u003e est le nombre d'étoiles à placer dans chaque ligne, colonne et région de la grille.\nPar défaut, ce nombre d'étoile est 1.\n\nLe fichier \u003cgrille\u003e définit chaque région de la grille par un caractère.\nPar exemple :\n\n# Exemple de grille 1★ avec 5 régions 'A', 'B', 'C', 'D' et 'E'\nABBBB\nABBBB\nCCBBB\nDDDDD\nDEEED\n\";\n\nfn main() {\n    // Nom du fichier contenant la grille à résoudre en paramètre\n    let args: Vec\u003cString\u003e = env::args().collect();\n    let (file_name, nb_stars) = match args.len() {\n        2 =\u003e (\u0026args[1], 1),\n        3 =\u003e (\n            \u0026args[1],\n            args[2]\n                .parse::\u003cusize\u003e()\n                .expect(\"Le nombre d'étoiles doit être un nombre\"),\n        ),\n        _ =\u003e {\n            println!(\"{HELP_MESSAGE}\");\n            return;\n        }\n    };\n\n    // Demande d'aide ?\n    if [\"-h\", \"--help\", \"aide\"].contains(\u0026file_name.to_lowercase().as_str()) {\n        println!(\"{HELP_MESSAGE}\");\n        return;\n    }\n\n    // Traitement du contenu du fichier\n    match read_lines(file_name) {\n        Ok(lines) =\u003e match GridParser::try_from(\u0026lines) {\n            Ok(grid_parsed) =\u003e solve(\u0026grid_parsed, nb_stars),\n\n            Err(e) =\u003e {\n                println!(\"Erreur dans le fichier {file_name}: {e}\");\n            }\n        },\n        Err(e) =\u003e println!(\"Erreur dans le fichier {file_name}: {e}\"),\n    }\n}\n\nfn solve(grid_parsed: \u0026GridParser, nb_stars: usize) {\n    let grid_handler = GridHandler::new(grid_parsed, nb_stars);\n    let mut grid = Grid::from(\u0026grid_handler);\n\n    println!(\"\\nGrid {nb_stars}★\\n{}\", grid_handler.display(\u0026grid, true));\n    loop {\n        match get_good_rule(\u0026grid_handler, \u0026grid) {\n            Ok(option_good_rule) =\u003e {\n                if option_good_rule.is_some() {\n                    let good_rule = option_good_rule.unwrap();\n                    println!(\"{good_rule}\");\n                    grid.apply_good_rule(\u0026good_rule);\n                    println!(\"\\n{}\", grid_handler.display(\u0026grid, true));\n                } else {\n                    break;\n                }\n            }\n            Err(bad_rule) =\u003e {\n                println!(\"{bad_rule} !!!\");\n                break;\n            }\n        }\n    }\n\n    if grid_handler.is_done(\u0026grid) {\n        println!(\"Grille résolue !\\n\");\n    } else {\n        println!(\"Grille non résolue :(\\n\");\n    }\n}\n\nfn read_lines(filename: \u0026str) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n    // Ouverture du fichier\n    let mut file = match File::open(filename) {\n        Ok(file) =\u003e file,\n        Err(e) =\u003e return Err(format!(\"Erreur ouverture du fichier {filename}: {e}\")),\n    };\n    // Lecture du fichier\n    let mut file_contents = String::new();\n    match file.read_to_string(\u0026mut file_contents) {\n        Ok(_) =\u003e {}\n        Err(e) =\u003e return Err(format!(\"Erreur lecture du fichier {filename}: {e}\")),\n    }\n\n    // Extraction des lignes du fichier\n    let lines: Vec\u003cString\u003e = file_contents\n        .split('\\n')\n        .map(|s: \u0026str| s.to_string())\n        .collect();\n    Ok(lines)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_main() {\n        // Liste de fichiers de tests avec des grilles à résoudre\n        let test_files = vec![\"./test_grids/test01.txt\"];\n\n        for test_file in test_files {\n            let lines = read_lines(test_file).unwrap();\n            let grid_parsed = GridParser::try_from(\u0026lines).unwrap();\n            let grid_handler = GridHandler::new(\u0026grid_parsed, 1);\n            let grid = Grid::from(\u0026grid_handler);\n            println!(\"Grid: \\n{grid}\");\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":100,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":6,"coverable":46}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>